<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陆陆陆啊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-07T05:13:25.061Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陆陆陆啊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序学习第二天</title>
    <link href="http://yoursite.com/2019/09/07/wxml2/"/>
    <id>http://yoursite.com/2019/09/07/wxml2/</id>
    <published>2019-09-07T05:09:24.590Z</published>
    <updated>2019-09-07T05:13:25.061Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h6 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h6><pre><code>添加 scroll-x就可看到滑动</code></pre><h2 id="理解display"><a href="#理解display" class="headerlink" title="理解display"></a>理解display</h2><pre><code>display: flex;display: inline-block;</code></pre><p>问题：<br>white-space: nowrap;<br> justify-content: center;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序学习第一天</title>
    <link href="http://yoursite.com/2019/09/06/wxml1/"/>
    <id>http://yoursite.com/2019/09/06/wxml1/</id>
    <published>2019-09-06T12:36:17.421Z</published>
    <updated>2019-09-06T13:00:08.583Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><pre><code>pages    index        index.js    Pages({})        index.json  可以设置顶部文字和颜色        index.wxml  相当于html        index.wxss  相当于cssapp.jsapp.json    导入页面的文件app.wxss    设置全局样式</code></pre><h4 id="设置顶部"><a href="#设置顶部" class="headerlink" title="设置顶部"></a>设置顶部</h4><pre><code>"navigationBarTitleText": "String" 顶部文字"navigationBarBackgroundColor": "color", 顶部颜色"navigationBarTextStyle": "black" 仅支持白色和黑色"enablePullDownRefresh": false, //是否开启下拉刷新</code></pre><h4 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h4><pre><code>在swiper标签加swiper-item，swiper-item就是每一页的内容幻灯片小圆点:indicator-dots="true"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Jquery</title>
    <link href="http://yoursite.com/2019/09/02/jQuery/"/>
    <id>http://yoursite.com/2019/09/02/jQuery/</id>
    <published>2019-09-02T13:03:41.273Z</published>
    <updated>2019-09-02T13:06:24.508Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h1><hr><p>看来 jQuery 你已经用得很爽了，想学习如何自己编写插件。非常好，这篇文档正适合你。用插件和方法来扩展 jQuery 非常强大，把最聪明的功能封装到插件中可以为你及团队节省大量开发时间。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>要编写一个 jQuery 插件，需要为 jQuery.fn 对象增加一个新的函数属性，属性名就是插件的名字</p><pre><code>jQuery.fn.myPlugin = function() {    // 插件的具体内容放在这里};</code></pre><p>等一下！ 我熟悉并钟爱的 $ 哪儿去了？ 它还在，只是为了确保你的插件不与其它使用 $ 的库发生冲突，有一个最佳实践： 把 jQuery 传递给 IIFE（立即调用函数），并通过它映射成 $ ，这样就避免了在执行的作用域里被其它库所覆盖。</p><pre><code>(function( $ ) {    $.fn.myPlugin = function() {        // 插件的具体内容放在这里    };})( jQuery );</code></pre><p>恩，这样好一些。 现在，在此闭包内我们可以随意用 $ 替换 jQuery。</p><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>现在，已经有了外壳，可以开始编写真正的插件代码了。但在这之前，关于上下文我有话要说。在插件函数的立即作用域中，关键字 this 指向调用插件的 jQuery 对象。这是个经常出错的地方，因为有些情况下 jQuery 接受一个回调函数，此时 this 指向原生的 DOM 元素。这常常导致开发者在 jQuery 函数中对 this 关键字多作一次无必要的包装。</p><pre><code>(function( $ ){    $.fn.myPlugin = function() {        // 没有必要再作 $(this) ，因为"this"已经是 jQuery 对象了        // $(this) 与 $($('#element')) 是相同的        this.fadeIn('normal', function(){            // 在这里 this 关键字指向 DOM 元素        });                            };          })( jQuery );</code></pre><p>​<br>    $(‘#element’).myPlugin();</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>现在理解了 jQuery 插件的上下文以后， 我们来写一个真正能做点儿事儿的插件。</p><pre><code>(function( $ ){  $.fn.maxHeight = function() {    var max = 0;    this.each(function() {      max = Math.max( max, $(this).height() );    });    return max;  };})( jQuery );--var tallest = $('div').maxHeight(); // 返回最高 div 的高度</code></pre><p>这个简单的插件利用 <a href="http://docs.jquery.com/action/edit/Manipulation/height" title="Manipulation/height" target="_blank" rel="noopener">.height()</a> 来返回页面中最高 div 的高度</p><h2 id="保持-chainability"><a href="#保持-chainability" class="headerlink" title="保持 chainability"></a>保持 chainability</h2><p>前面的例子返回了页面上最高 div 的一个整数值，但很多时候插件只是以某种方式修改元素集合，并把它们传给调用链的下一个方法。 这正是 jQuery 设计的漂亮之处，也是它如此流行的原因之一。为保持插件的 chainability ，必须确保插件返回 this 关键字。</p><pre><code>(function( $ ){  $.fn.lockDimensions = function( type ) {      return this.each(function() {      var $this = $(this);      if ( !type || type == 'width' ) {        $this.width( $this.width() );      }      if ( !type || type == 'height' ) {        $this.height( $this.height() );      }    });  };})( jQuery );--$('div').lockDimensions('width').css('color', 'red');</code></pre><p>插件在立即作用域中返回了 this 关键字，保持了 chainability ，所以 jQuery 集合可以被其它方法操作，例如 <a href="http://docs.jquery.com/CSS/css" title="CSS/css " target="_blank" rel="noopener">.css()</a>。因此，若插件无需真正的返回值，你应该一直在插件函数的立即作用域中返回 this 关键字。同样，如你所想，调用插件时的参数会被传递到插件函数的立即作用域中。在上例中，字符串 “width” 成了插件函数的  type 参数。</p><h2 id="默认设置和选项"><a href="#默认设置和选项" class="headerlink" title="默认设置和选项"></a>默认设置和选项</h2><p>对于那些提供许多选项、更复杂、更可配置的插件，最佳实践是提供一个默认设置，它可在插件调用时（通过 <a href="http://docs.jquery.com/Utilities/jQuery.extend" title="Utilities/jQuery.extend" target="_blank" rel="noopener">$.extend</a>）被扩展。这样调用插件时无需大量参数， 只要一个对象参数，内容为你希望不同于默认值的那部分设置。做法如下：</p><pre><code>(function( $ ){  $.fn.tooltip = function( options ) {      // Create some defaults, extending them with any options that were provided    var settings = $.extend( {      'location'         : 'top',      'background-color' : 'blue'    }, options);    return this.each(function() {              // Tooltip plugin code here    });  };})( jQuery );--$('div').tooltip({  'location' : 'left'});    </code></pre><p>在本例中，用给定选项调用 tooltip 插件后， 默认的 location 设置被覆盖为 “left”， 但 bacground-color 设置仍为默认值 “blue”。最终的设置对象看起来这样的：</p><pre><code>{  'location'         : 'left',  'background-color' : 'blue'}</code></pre><p>这是一个非常好的方式， 可以提供一个高度可配置的插件，又不必强制开发者定义所有选项。</p><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>合理地为插件定义名称空间是插件开发中很重要的一部分。 正确的定义名称空间可以确保你的插件很难被其它插件或同一页面中的其它代码所覆盖。名称空间也可以让插件开发者的日子好过一些，因为它能帮你跟踪你的方法、事件和数据。</p><h2 id="插件方法"><a href="#插件方法" class="headerlink" title="插件方法"></a>插件方法</h2><p>单个插件<strong>永远不要</strong>在 jQuery.fn 对象中声明一个以上的名称空间</p><pre><code>(function( $ ){  $.fn.tooltip = function( options ) {     // 这  };  $.fn.tooltipShow = function( ) {    // 不  };  $.fn.tooltipHide = function( ) {     // 好  };  $.fn.tooltipUpdate = function( content ) {     // !!!    };})( jQuery );</code></pre><p>​<br>这非常不好，因为它搞乱了 $.fn 名称空间。 要修正这个问题，你应该把所有插件方法收集到一个对象定义当中，并通过传递方法名称字符串调用。</p><pre><code>(function( $ ){  var methods = {    init : function( options ) {       // 这     },    show : function( ) {      // 很    },    hide : function( ) {       // 好    },    update : function( content ) {       // !!!     }  };  $.fn.tooltip = function( method ) {    // Method calling logic    if ( methods[method] ) {      return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));    } else if ( typeof method === 'object' || ! method ) {      return methods.init.apply( this, arguments );    } else {      $.error( 'Method ' +  method + ' does not exist on jQuery.tooltip' );    }      };})( jQuery );// 调用  init 方法$('div').tooltip(); // 调用  init 方法$('div').tooltip({  foo : 'bar'});--// 调用 hide 方法$('div').tooltip('hide'); --// 调用 update 方法$('div').tooltip('update', 'This is the new tooltip content!');</code></pre><p>​<br>这种插件架构使你可以在插件的父闭包中封装所有方法，调用时先传方法名称字符串，接下来再把你需要的其它参数传给该方法。这种封装和架构是 jQuery 插件社区的一个标准，已经被无数插件所使用，包括 <a href="http://jqueryui.com/" target="_blank" rel="noopener">jQueryUI</a> 中的插件和小部件。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><a href="http://docs.jquery.com/Events/bind" title="Events/bind" target="_blank" rel="noopener">bind</a> 方法有个鲜为人知的特性：它支持为绑定事件定义名称空间。如果你的插件要绑定事件，最好为其定义名称空间。这样，回头想 <a href="http://docs.jquery.com/Events/unbind" title="Events/unbind" target="_blank" rel="noopener">unbind</a> 的时候就不会影响到相同事件类型上的其它已绑定事件。要为事件定义名称空间，把 “.&lt;namespace&gt;“ 附到要绑定的事件类型后面即可。</p><pre><code>(function( $ ){  var methods = {     init : function( options ) {       return this.each(function(){         $(window).bind('resize.tooltip', methods.reposition);       });     },     destroy : function( ) {       return this.each(function(){         $(window).unbind('.tooltip');       })     },     reposition : function( ) {        // ...      },     show : function( ) {        // ...      },     hide : function( ) {       // ...      },     update : function( content ) {        // ...     }  };  $.fn.tooltip = function( method ) {    if ( methods[method] ) {      return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));    } else if ( typeof method === 'object' || ! method ) {      return methods.init.apply( this, arguments );    } else {      $.error( 'Method ' +  method + ' does not exist on jQuery.tooltip' );    }      };})( jQuery );</code></pre><p>​<br>    –<br>    $(‘#fun’).tooltip();<br>    // Some time later…<br>    $(‘#fun’).tooltip(‘destroy’);</p><p>在本例中，当 tooltip 被 init 方法初始化的时候，它把 reposition 方法绑定到 window 对象的 resize 事件上，名称空间为 “tooltip”。 之后，如果开发者想要销毁对象，可以把插件的名称空间（即 “tooltip”）传给 unbind 方法，以便解除本插件对所有事件的绑定。这使得我们可以安全的地解除本插件的事件绑定，避免意外影响插件之外绑定的事件。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>插件开发中，你可能经常需要维护状态，或检查你的插件是否已在给定元素上做过初始化。jQuery <a href="http://docs.jquery.com/action/edit/Utilities/data" title="Utilities/data" target="_blank" rel="noopener">data</a> 方法是针对每个元素跟踪变量的好办法。不过最好能用单一对象容纳所有变量并用单一名称空间访问此对象，而不是分别跟踪一堆不同名字的数据。</p><pre><code>(function( $ ){  var methods = {     init : function( options ) {       return this.each(function(){         var $this = $(this),             data = $this.data('tooltip'),             tooltip = $('&lt;div /&gt;', {               text : $this.attr('title')             });         // If the plugin hasn't been initialized yet         if ( ! data ) {           /*             Do more setup stuff here           */           $(this).data('tooltip', {               target : $this,               tooltip : tooltip           });         }       });     },     destroy : function( ) {       return this.each(function(){         var $this = $(this),             data = $this.data('tooltip');         // Namespacing FTW         $(window).unbind('.tooltip');         data.tooltip.remove();         $this.removeData('tooltip');       })     },     reposition : function( ) { // ... },     show : function( ) { // ... },     hide : function( ) { // ... },     update : function( content ) { // ...}  };  $.fn.tooltip = function( method ) {    if ( methods[method] ) {      return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));    } else if ( typeof method === 'object' || ! method ) {      return methods.init.apply( this, arguments );    } else {      $.error( 'Method ' +  method + ' does not exist on jQuery.tooltip' );    }      };})( jQuery );</code></pre><p>data 方法可以帮你在插件的多次方法调用之间跟踪变量和状态。 把数据置于单一对象中，并为其定义名称空间有利于集中访问插件的所有属性，同时也减少了名称空间以便需要时删除。</p><h2 id="总结及最佳实践"><a href="#总结及最佳实践" class="headerlink" title="总结及最佳实践"></a>总结及最佳实践</h2><p>编写  jQuery 插件使库更加高效。把你最聪明、最有用的功能抽象成可重用代码，这将节省你的时间，进一步提高开发效率。下面是本文档的简要总结以及你开发下一个 jQuery 插件时的注意事项：</p><ul><li>总是把插件包装在闭包中 <code>{ /* plugin goes here */ })( jQuery );</code></li><li>不在插件函数的立即作用域中额外包装 this 关键字</li><li>总是让插件函数返回 this 关键字以保持 chainability ，除非插件有真正的返回值。</li><li>不要传给插件大量参数，应该传一个可以覆盖插件默认选项的设置对象。</li><li>在单个插件中，不要让一个以上的名称空间搞乱了 jQuery.fn 对象。</li><li>总是为方法、事件和数据定义名称空间。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>windows安装虚拟机</title>
    <link href="http://yoursite.com/2019/09/01/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2019/09/01/虚拟机/</id>
    <published>2019-09-01T11:48:14.695Z</published>
    <updated>2019-09-01T11:55:21.248Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>下载VMware Workstation，CentOS<br>在VMware Workstation中安装CentOS镜像<br>配置跟着里面安装就行</p><blockquote><p>在CentOS中还可以安装图形化界面</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>行列式</title>
    <link href="http://yoursite.com/2019/09/01/%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/01/行列式/</id>
    <published>2019-09-01T11:18:04.350Z</published>
    <updated>2019-09-01T11:59:45.145Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h5 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h5><pre><code>n个数就是n阶排列</code></pre><h5 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h5><pre><code>前面的数比后面的小</code></pre><h5 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h5><pre><code>前面的数比后面的大</code></pre><h5 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h5><pre><code>两种判断方法：    1.一个排列中前面的数比他大的有几个，总和    2.一个排列中前面的数比他小的有几个，总和</code></pre><blockquote><p>总和为奇数就是奇排列，为偶数就是偶排列</p></blockquote><blockquote><p>行列式的计算：其实可以观察矩阵用连线来记住，多少阶就一次连多少个数字，都具有一定的规律，<code>\</code>这样连线数据是想加，<code>/</code>再减去这样连线的数据就得到结果。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="线性代数" scheme="http://yoursite.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>豆瓣插件</title>
    <link href="http://yoursite.com/2019/09/01/%E8%B1%86%E7%93%A3%20%E6%8F%92%E4%BB%B6%E7%88%AC%E5%8F%96%E5%A4%B1%E8%B4%A5/"/>
    <id>http://yoursite.com/2019/09/01/豆瓣 插件爬取失败/</id>
    <published>2019-09-01T05:56:24.776Z</published>
    <updated>2019-09-01T11:46:27.440Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>user 在登录豆瓣个人中心网址上面的那串数字title 突入你想填的就行quote 用来浏览器F12取消一小段爬取那部分的html</code></pre><h4 id="豆瓣插件爬取失败"><a href="#豆瓣插件爬取失败" class="headerlink" title="豆瓣插件爬取失败"></a>豆瓣插件爬取失败</h4><p>使用： hexo douban -updata<br>       hexo g<br>       hexo s<br>就可以看到爬取效果</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote><p>上传的时候不能用hexo d 只能用<code>hexo deploy</code></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>二级（Java语言程序设计）考试大纲</title>
    <link href="http://yoursite.com/2019/08/26/Java%E4%BA%8C%E7%BA%A7%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/"/>
    <id>http://yoursite.com/2019/08/26/Java二级考试大纲/</id>
    <published>2019-08-26T13:44:15.082Z</published>
    <updated>2019-08-26T13:47:13.483Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>公共基础知识</strong></p><p><strong>基本要求</strong> </p><p>\1. 掌握算法的基本概念。</p><p>\2. 掌握基本数据结构及其操作。</p><p>\3. 掌握基本排序和查找算法。</p><p>\4. 掌握逐步求精的结构化程序设计方法。</p><p>\5. 掌握软件工程的基本方法，具有初步应用相关技术进行软件开发的能力。</p><p>\6. 掌握数据库的基本知识，了解关系数据库的设计。 </p><p><strong>考试内容</strong></p><p><strong>一、基本数据结构与算法</strong></p><p>\1. 算法的基本概念；算法复杂度的概念和意义（时间复杂度与空间复杂度）。</p><p>\2. 数据结构的定义；数据的逻辑结构与存储结构；数据结构的图形表示；线性结构与非线性结构的概念。</p><p>\3. 线性表的定义；线性表的顺序存储结构及其插入与删除运算。</p><p>\4. 栈和队列的定义；栈和队列的顺序存储结构及其基本运算。</p><p>\5. 线性单链表、双向链表与循环链表的结构及其基本运算。</p><p>\6. 树的基本概念；二叉树的定义及其存储结构；二叉树的前序、中序和后序遍历。</p><p>\7. 顺序查找与二分法查找算法；基本排序算法（交换类排序，选择类排序，插入类排序）。</p><p><strong>二、程序设计基础</strong></p><p>\1. 程序设计方法与风格。</p><p>\2. 结构化程序设计。</p><p>\3. 面向对象的程序设计方法，对象，方法，属性及继承与多态性。</p><p><strong>三、软件工程基础</strong></p><p>\1. 软件工程基本概念，软件生命周期概念，软件工具与软件开发环境。</p><p>\2. 结构化分析方法，数据流图，数据字典，软件需求规格说明书。</p><p>\3. 结构化设计方法，总体设计与详细设计。</p><p>\4. 软件测试的方法，白盒测试与黑盒测试，测试用例设计，软件测试的实施，单元测试、集成测试和系统测试。</p><p>\5. 程序的调试，静态调试与动态调试。</p><p><strong>四、数据库设计基础</strong></p><p>\1. 数据库的基本概念：数据库，数据库管理系统，数据库系统。</p><p>\2. 数据模型，实体联系模型及E-R图，从E-R图导出关系数据模型。</p><p>\3. 关系代数运算，包括集合运算及选择、投影、连接运算，数据库规范化理论。</p><p>\4. 数据库设计方法和步骤：需求分析、概念设计、逻辑设计和物理设计的相关策略。</p><p><strong>考试方式</strong></p><p>\1. 公共基础知识不单独考试，与其他二级科目组合在一起，作为二级科目考核内容的一部分。</p><p>\2. 上机考试，10道单项选择题，占10分。</p><p><strong>JAVA**</strong>语言程序设计**</p><p><strong>基本要求</strong></p><p>\1.  掌握Java语言的特点，实现机制和体系结构。</p><p>\2.  掌握Java语言中面向对象的特性。</p><p>\3.  掌握Java语言提供的数据类型和结构。</p><p>\4.  掌握Java语言编程的基本技术。</p><p>\5.  会编写Java用户界面程序。</p><p>\6.  会编写Java简单应用程序。</p><p>\7.  会编写Java小应用程序（Applet）。</p><p>\8.  了解Java语言的广泛应用。</p><p><strong>考试内容</strong></p><p><strong>一、Java语言的特点和实现机制</strong></p><p><strong>二、Java体系结构</strong></p><p>\1.  Java程序结构。</p><p>\2.  Java类库结构。</p><p>\3.  Java程序开发环境结构。</p><p><strong>三、Java语言中面向对象的特性</strong></p><p>\1.  面向对象编程的基本概念和特征。</p><p>\2.  类的基本组成和使用。</p><p>\3.  对象的生成、使用和删除。</p><p>\4.  包与接口。</p><p>\5.  Java类库的常用类和接口。</p><p><strong>四、Java简单数据类型及运算</strong></p><p>\1.  变量和常量。</p><p>\2.  基本数据类型及转换。</p><p>\3.  Java类库中对基本数据类型的类包装。</p><p>\4.  运算符和表达式运算。</p><p>\5.  字符串和数组。</p><p><strong>五、Java语言的基本语句</strong></p><p>\1.  条件语句。</p><p>\2.  循环语句。</p><p>\3.  注释语句。</p><p>\4.  异常处理语句。</p><p>\5.  表达式语句。</p><p><strong>六、Java编程技术基础</strong></p><p>\1.  输入输出流及文件操作。</p><p>\2.  线程的概念和使用。</p><p>\3.  程序的同步与共享。</p><p>\4.  Java语言的继承、多态和高级特性。</p><p>\5.  异常处理和断言概念。</p><p>\6.  Java语言的集合（Collections）框架和泛型概念。</p><p><strong>七、编写用户界面程序基础</strong></p><p>\1.  用AWT编写图形用户界面的基本技术。</p><p>\2.  用Swing编写图形用户界面的特点。</p><p>\3.  Swing的事件处理机制。</p><p><strong>八、编写小应用程序（Applet）基础</strong></p><p>\1.  Applet类的API基本知识。</p><p>\2.  Applet编写步骤及特点。</p><p>\3.  基于AWT和Swing编写用户界面。</p><p>\4.  Applet的多媒体支持和通信。</p><p><strong>九、Java SDK 6.0的下载和安装</strong></p><p><strong>考试方式</strong></p><p>上机考试，考试时长120分钟，满分100分。</p><p>\1.  题型及分值</p><p>单项选择题40分（含公共基础知识部分10分）、操作题60分（包括基本操作题、简单应用题及综合应用题）。</p><p>\2. 考试环境</p><p>NetBeans。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java二级</title>
    <link href="http://yoursite.com/2019/08/26/java%E4%BA%8C%E7%BA%A7/"/>
    <id>http://yoursite.com/2019/08/26/java二级/</id>
    <published>2019-08-26T13:41:40.401Z</published>
    <updated>2019-08-26T13:38:59.530Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="一、Java的历史、现状"><a href="#一、Java的历史、现状" class="headerlink" title="一、Java的历史、现状"></a>一、Java的历史、现状</h1><h2 id="1-Java历史"><a href="#1-Java历史" class="headerlink" title="1.Java历史"></a>1.Java历史</h2><p>在上世纪90年代初，sun公司有一个叫做Green的项目，目的是为家用消费电子产品开发一个分布式代码系统，这样就可以对家用电器进行控制，和它们进行信息交流。詹姆斯·高斯林(JamesGosling)等人基于C++开发一种新的语言Oak(Java的前身)。Oak是一种用于网络的精巧而安全的语言。Sun公司曾依此投标一个交互式电视项目，但结果是被SGI打败，Sun打算抛弃Oak。随着互联网的发展，Sun看到了Oak在计算机网络上的广阔应用前景，于是改造Oak，在1995年5月以“Java”的名称正式发布，从此Java走上繁荣之路。</p><p>当然提到Java历史，不得不提的一个故事就是Java的命名。开始“Oak”的命名是以项目小组办公室外的树而得名，但是Oak商标被其他公司注册了，必须另外取一个名字，传说有一天，几位Java成员组的会员正在讨论给这个新的语言取什么名字，当时他们正在咖啡馆喝着Java(爪哇)咖啡，有一个人灵机一动说就叫Java怎样，得到了其他人的赞同，于是，Java这个名字就这样传开了。当然对于传说，了解一下就好了，不必过于认真。</p><h2 id="2-Java"><a href="#2-Java" class="headerlink" title="2.Java"></a>2.Java</h2><p>作为学习Java的人士，对Java历史上发生的大事件有一个了解是应该的。</p><p>JDK(JavaSoftwareDevelopKit))：Java软件开发工具包。JDK是Java的核心，包括了Java运行环境，一系列Java开发工具和Java基础的类库。目前主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了自己的JDK，例如IBM公司开发的JDK，BEA公司的Jrocket，还有GNU组织开发的JDK等等。</p><p>​                                                  </p><h2 id="3-Java特点"><a href="#3-Java特点" class="headerlink" title="3.Java特点"></a>3.Java特点</h2><p>简单地说，Java具有如下特点：简单的、面向对象、平台无关、多线程、分布式、安全、高性能、可靠的、解释型、自动垃圾回收等特点。</p><p>这里只解释一下平台无关和分布式，其余的在后面会逐步接触到。</p><h3 id="3-1平台无关"><a href="#3-1平台无关" class="headerlink" title="3.1平台无关"></a>3.1平台无关</h3><p>所谓平台无关指的是：用Java写的程序不用修改就可在不同的软硬件平台上运行。这样就能实现同样的程序既可以在Windows下运行，到了Unix或者Linux环境不用修改就直接可以运行了。Java主要靠Java虚拟机(JVM)实现平台无关性。</p><p>平台无关性就是一次编写，到处运行：Write Once, Run Anywhere</p><h3 id="3-2分布式"><a href="#3-2分布式" class="headerlink" title="3.2分布式"></a>3.2分布式</h3><p>分布式指的是：软件由很多个可以独立执行的模块组成，这些模块被分布在多台计算机上，可以同时运行，对外看起来还是一个整体。也就是说，分布式能够把多台计算机集合起来就像一台计算机一样，从而提供更好的性能。</p><h2 id="4-Java标准组织——JCP"><a href="#4-Java标准组织——JCP" class="headerlink" title="4.Java标准组织——JCP"></a>4.Java标准组织——JCP</h2><p>JCP(Java Community Process) 是一个开放的国际组织，成立于 1995 年，主要职能是发展和更新 Java 技术规范、参考实现(RI) 、技术兼容包(TCK) 。Java 技术和 JCP 两者的原创者都是 SUN 计算机公司。组织成员可以提交 JSR(Java Specification Requests) ，通过讨论、认可、审核以后，将进入到下一版本的规范里面。</p><p>也就是说 JCP 是目前 Java 技术发展事实上的控制者和领领导者。</p><h1 id="二、Java从代码到运行"><a href="#二、Java从代码到运行" class="headerlink" title="二、Java从代码到运行"></a>二、Java从代码到运行</h1><p><strong>用一个图来描述这个过程会比较容易理解：</strong></p><h2 id="1-编写代码"><a href="#1-编写代码" class="headerlink" title="1.编写代码"></a>1.编写代码</h2><p>首先把我们想要计算机做的事情，通过 Java 表达出来，写成 Java 文件，这个过程就是编写代码的过程。如上图所示的 Hello.java 文件。</p><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h2><p>写完 Java 代码后，机器并不认识我们写的 Java 代码，需要进行编译成为字节码，编译后的文件叫做 class 文件。如上图所示的 Hello.class 文件。</p><h2 id="3-类装载ClassLoader"><a href="#3-类装载ClassLoader" class="headerlink" title="3.类装载ClassLoader"></a>3.类装载ClassLoader</h2><p>类装载的功能是为执行程序寻找和装载所需要的类。</p><p>ClassLoader能够加强代码的安全性，主要方式是：把本机上的类和网络资源类相分离， 在调入类的时候进行检查，因而可以限制任何“特洛伊木马”的应用。</p><h2 id="4-字节码-byte-code-校验"><a href="#4-字节码-byte-code-校验" class="headerlink" title="4.字节码(byte-code)校验"></a>4.字节码(byte-code)校验</h2><p>功能是对 class 文件的代码进行校验，保证代码的安全性。</p><p>Java 软件代码在实际运行之前要经过几次测试。JVM 将代码输入一个字节码校验器以测试代码段格式并进行规则检查–检查伪造指针、 违反对象访问权限或试图改变对象类型的非法代码。</p><p>注意—-所有源于网络的类文件都要经过字节码校验器字节码校验器对程序代码进行四遍校验， 这可以保证代码符合JVM 规范并且不破坏系统的完整性。如果校验器在完成四遍校验后未返回出错信息，则下列各点可被保证：</p><p>- 类符合JVM规范的类文件格式</p><p>- 无访问限制异常</p><p>- 代码未引起操作数栈上溢或下溢</p><p>- 所有操作代码的参数类型将总是正确的</p><p>- 无非法数据转换发生，如将整数转换为对象引用</p><p>- 对象域访问是合法的</p><h2 id="5-解释-Interpreter"><a href="#5-解释-Interpreter" class="headerlink" title="5.解释(Interpreter)"></a>5.解释(Interpreter)</h2><p>可是机器也不能认识 class 文件，还需要被解释器进行解释，机器才能最终理解我们所要表达的东西。</p><h2 id="6-运行"><a href="#6-运行" class="headerlink" title="6.运行"></a>6.运行</h2><p>最后由运行环境中的 Runtime 对代码进行运行，真正实现我们想要机器完成的工作。</p><h2 id="7-说明"><a href="#7-说明" class="headerlink" title="7.说明"></a>7.说明</h2><p>由上面的讲述，大家看到，Java通过一个编译阶段和一个运行阶段，来让机器最终理解我们想要它完成的工作，并按照我们的要求进行运行。</p><p>在这两个阶段中，需要我们去完成的就是编译阶段的工作，也就是说：我们需要把我们想要机器完成的工作用 Java 语言表达出来，写成 Java 源文件，然后把源文件进行编译，形成 class 文件， 最后就可以在 Java 运行环境中运行了。 运行阶段的工作由 Java 平台自身提供，我们不需要做什么工作。</p><h1 id="三、Java程序设计基础"><a href="#三、Java程序设计基础" class="headerlink" title="三、Java程序设计基础"></a>三、Java程序设计基础</h1><h2 id="1-Java编程概况"><a href="#1-Java编程概况" class="headerlink" title="1**.Java编程概况**"></a><strong>1**</strong>.<strong><strong>Java</strong></strong>编程概况**</h2><p>现在你可以复习一下Java语言的背景材料，它的基本结构象C/C++，但任何用面向过程语言编写过程序的人都可以了解Java语言的大部分结构.</p><h3 id="1-1-程序结构"><a href="#1-1-程序结构" class="headerlink" title="1.1**程序结构**"></a><strong>1.1**</strong>程序结构**</h3><p>Java语言的源程序代码由一个或多个编译单元(compilationunit)组成，每个编译单元只能包含下列内容(空格和注释除外)：<em>一个程序包语句(packagestatement)</em>入口语句(importstatements)<em>类的声明(classdeclarations)</em>界面声明(interfacedeclarations)每个Java的编译单元可包含多个类或界面，但是每个编译单元最多只能有一个类或者界面是公共的。Java的源程序代码被编译后，便产生了Java字节代码。Java的运行系统工作起来如同一台虚拟机。在当前的Java实现中，每个编译单元就是一个以.java为后缀的文件。每个编译单元有若干个类，编译后，每个类生成一个.class文件。.class文件是Java虚拟机能够识别的代码。</p><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2**注释**"></a><strong>1.2**</strong>注释**</h3><p>三种类型如下://注释一行/<em>一行或多行注释</em>//<strong>文档注释</strong>/文档注释一般放在一个变量或函数定义前,指示在任何自动生成文档系统中调入。</p><h3 id="1-3标识符"><a href="#1-3标识符" class="headerlink" title="1.3标识符"></a>1.3标识符</h3><p>变量，函数，类和对象的名称都是标识符，程序员需要标识和使用的东西都需要标识符。在Java语言里,标识符以字符或_,$开头,后面可以包含数字，标识符是大小写有区别的,没有长度限制。</p><p>有效的标识符mynameict_networkHello_sys_path$bill</p><p>例子：inta_number;char_onechar;float$bill;</p><h3 id="1-4数据类型"><a href="#1-4数据类型" class="headerlink" title="1.4数据类型"></a>1.4数据类型</h3><p>Java使用五种基本类型:integer(整数),floating(浮点数),point(指针),Boolean(布尔变量),CharacterorString(字符或字符串)。</p><p>integer整数下边给出的数据表示都是整数的例子：4，15，089，0xAD00整数长度数据类型表示8bitsbyte16bitsshort32bitsint64bitslong</p><p>floating浮点数下边给出的数据表示都是浮点数的例子：6.37，3.7E15，3e8</p><p>浮点数长度数据类型表示32bitsfloat64bitsdouble</p><p>Boolean布尔变量下边是布尔变量的两种可能取值：</p><p>truefalseCharacter字符下边给出的都是字符的例子：a\t(tab)\u????(unicode)</p><p>String字符串下边给出的都是字符串的例子：</p><p>"Thisisastringliteral""中国科学院计算所"数组你可以定义任意类型的数组.chars[];这是字符型数组;int[]array;这是整型数组;你还可以定义数组的数组.intblock[][]=newint[2][3];数组边界在运行时被检测,避免堆栈溢出和内存崩溃.</p><p>在Java里,数组实际上是一个对象,数组有一个成员变量：</p><p>length。你可以用这个成员函数来查看任意数组的长度.inta[][]=newint[10][3]a.length/<em>10</em>/a[0].length/<em>3</em>/创建数组在Java里创建数组,你可使用两种基本方法：</p><p>创建一个空数组：intlist[]=newint[50];或你可以用初始数值填充数组.Stringnames[]={"Chenji","Yuan","Chun","Yang"};</p><p>相当于下面功能：Stringnames[];names=newString[4];names[0]=newString("Chenji");names[1]</p><p>=newString</p><p>("Yuan");names[2]=newString("Chun");names[3]=newString("Yang");在编译时你不能象下例那样创建静态数组。intname[50];//将产生一个编译错误你也不能用new操作去填充一个没定义大小的数组。intname[];for(inti=0;i</p><h3 id="1-5表达式"><a href="#1-5表达式" class="headerlink" title="1.5表达式"></a>1.5表达式</h3><p>Java语言的表达式和C语言非常类似。运算符运算符(operator)优先级从高到底排列如下：.<a href=""></a>++–!～instanceof<em>/%+-\==!=&amp;^&amp;&amp;||?:=op=,整数运算符在整数运算时，如果操作数是long类型，则运算结果是long类型，否则为int类型，绝不会是byte，short或char型。这样，如果变量i被声明为short或byte，i+1的结果会是int。如果结果超过该类型的取值范围，则按该类型的最大值取模。单目整数运算符是：运算符操作-单目非～位补码++加1–减1++运算符用于表示直接加1操作。增量操作也可以用加运算符和赋值操作间接完成。++lvalue(表示lvalue+=1,++lvalue也表示lvalue=lvalue+1(只要lvalue没有副作用)。–运算符用于表示减1操作。++和–运算符既可以作为前缀运算符，也可以做为后缀运算符。双目整数运算符是：运算符操作*</em>+加-减*乘/除%取模&amp;位与|位或^位异或=，==和!=产生boolean类型的数据。</p><p>布尔运算符布尔(boolean)变量或表达式的组合运算可以产生新的boolean值。单目运算符!是布尔非。双目运算符&amp;，|和^是逻辑AND，OR和XOR运算符，它们强制两个操作数求布尔值。为避免右侧操作数冗余求值，用户可以使用短路求值运算符&amp;&amp;和||。用户可以使用==和!=，赋值运算符也可以用&amp;=、|=、^=。三元条件操作符?:和C语言中的一样。</p><p>浮点运算符浮点运算符可以使用常规运算符的组合：如单目运算符++、–，双目运算符+、-、<em>和/，以及赋值运算符+=，-=，</em>=，和/=。此外，还有取模运算：%和%=也可以作用于浮点数，例如：a%b和a-((int)(a/b)*b)的语义相同。这表示a%b的结果是除完后剩下的浮点数部分。只有单精度操作数的浮点表达式按照单精度运算求值，产生单精度结果。如果浮点表达式中含有一个或一个以上的双精度操作数，则按双精度运算，结果是双精度浮点数。</p><p>数组运算符数组运算符形式如下：</p><p>[]可给出数组中某个元素的值。合法的取值范围是从0到数组的长度减1。取值范围的检查只在运行时刻实。运算符以String对象实现。运算符"+"完成并操作，如果必要则自动把操作数转换为String型。如果操作数是一个对象，它可定义一个方法toString()返回该对象的String方式，例如floata=1.0print("Thevalueofais"+a+"\n");+运算符用到例子Strings="a="+a;+=运算符也可以用于String。注意，左边(下例中的s1)仅求值一次。s1+=a;//s1=s1+a//若a非String型，自动转换为String型。对象运算符双目运算符instanceof测试某个对象是否是指定类或其子类的实例。例如：if(myObjectinstanceofMyClass){MyClassanothermyObject=(MyClass)myObject;…}是判定myObject是否是MyClass的实例或是其子类的实例。强制和转换Java语言和解释器限制使用强制和转换，以防止出错导致系统崩溃。整数和浮点数之间可以来回</p><p>强制转换，但整数不能强制转换成数组或对象。对象不能被强制为基本类型。</p><h3 id="1-6Java流控制"><a href="#1-6Java流控制" class="headerlink" title="1.6Java流控制"></a>1.6Java流控制</h3><p>下面几个控制结构是从C语言借鉴的。分支结构</p><p>if/else分支结构if(Boolean){statemanets;}else{statements;}</p><p>switch分支结构switch(expr1){caseexpr2:statements;break;caseexpr3:statements;break;default:statements;break;}</p><p>循环结构for循环结构for(initexpr1;testexpr2;incrementexpr3){statements;}</p><p>While循环结构While(Boolean){statements;}</p><p>Do循环结构do{statements;}while(Boolean);</p><p>一般顺序控制break[label]continue[label]reutrnexpr;label:statement;</p><p>for循环例子下面是一个程序例子，画几条线，分别用红,绿,蓝颜色，这段程序可能是Java函数的一部分：intcount;for(count=1;count</p><h2 id="2-Java变量和函数的实例"><a href="#2-Java变量和函数的实例" class="headerlink" title="2.Java变量和函数的实例"></a>2.Java变量和函数的实例</h2><p>Java的类包含变量和函数。数据变量可以是一些原始的类型,如int,char等。成员函数是一些可执行的过程。例如,下面程序里：publicclassClassOne{inti;publicClassOne(){i=10;}publicvoidAdd_i(intj){i=i+j;}}ClassOne包含一个变量i和两个成员函数,ClassOne(intfirst)和Add_i(intj)。</p><p>成员函数成员函数是一些可被其它类或自己类调用的处理子程序。一个特殊的成员函数叫构造函数,这个函数名称一般与本类名程相同。它没有返回值。构造函数和成员函数当你在Java里定义一个类时,你可定义一个或多个可选的构造函数,当创建本类的一个对象时用某一个构造函数来初始化本对象。用前面的程序例子来说明,当ClassOne类创建一个新实例时,所有成员函数和变量被创建(创建实例)。构造函数被调用。ClassOnemc:mc=newClassOne();</p><p>关键词new用来创建一个类的实例,一个类用new初始化前并不占用内存,它只是一个类型定义,当mc对象初始化后,mc对象里的i变量等于10。你可以通过对象名来引用变量i。(有时称为实例变量)mc.i++;//mc实例变量加1因为mc有ClassOne类的所有变量和成员函数，我们可以使用同样的语法来调用成员函数Add_i：Add_i(10);现在mc.i变量等于21.</p><p>结束函数Java并不支持析构函数(C++里的定义),因为java本身提供对象无用时自动清除的功能,同时它也提供了一个自动拉圾箱的成员函数，在清除对象时被调用：Protectedvoidfinalize(){close();}</p><h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h2><p>有效范围和废物自动回收对象有一定的生命期并在它的生命期间使用资源,当一个对象不再被使用时,它应释放内存,避免内存溢出。在Java里,收集和释放内存是一个叫自动废品回收站的线程的责任。这个线程监视对象有效范围并给一个走出有效范围的对象作上标识。</p><p>例如：Strings;//没有分配内存s=newString("oldstring");//分配内存s="newstring";//重新分配内存(创建新对象)我们将在以后访问String类时将更加明白它的工作过程,但它的快速工作过程是这样的：1.创建一个新的String类对象并填充以"oldstring"2.创建另一个String对象并填充以"newstring"注意我们创建了两个对象。Stirng对象"oldstring"Stirng对象"newstring"在第三条语句里,第一个包括"oldstring"的叫做s的对象已走出了有效范围,没有任何方法可以再访问他,我们现在有一个新的对象也叫s,包含"newstring"。在下一个废品回收线程,前一个对象将被标识并清除。</p><h2 id="4-子类"><a href="#4-子类" class="headerlink" title="4.子类"></a>4.子类</h2><p>子类是利用存在的对象创建一个新对象的机制,比如,如果你有一个Horse类,你可以创建一个Zebra子类,Zebra是Horse的一种。</p><p>classZebraextendsHorse{intnumber_OF_stripes:}关键词extends来定义对象有的子类.Zebra是Horse的子类。Horse类里的所有特征都将拷贝到Zebra类里,而Zebra类里可以定义自己的成员函数和实例变量。Zebra称为Horse的派生类或继承。另外,你也许还想覆盖基类的成员函数。用ClassOne说明,下面是一个派生类覆盖Add_i功能的例子.</p><p>importClassOne;publicclassNewClassextendsClassOne{publicvoid</p><p>Add_i(intj){i=i+(j/2);}}</p><p>当NewClass类的实例创建时,变量i初始化值为10,但调用Add_i产生不同的结果。NewClassmnc;mnc=newNewClass();mnc.Add_i(10);访问控制Java里当你创建一个新类时,你可以标明变量和成员函数的访问层次。</p><p>publicpublicvoidAnyOneCanAccess(){}public实例变量和成员函数可以任意其它类调用。</p><p>protectedprotectedvoidOnlySubClasses(){}protected实例变量和成员函数只能被其子类调用.</p><p>privateprivateStringCreditCardNumber;private实例变量和成员函数只能在本类里调用.</p><p>friendlyvoidMyPackageMethod(){}缺省的,如果没有定义任何防火控制,实例变量或函数缺省定义成friendly,意味着可以被本包里的任意对象访问,但其它包里的对象不可访问。所有这个类的对象都只有实例变量的同一个拷贝，这种方法的关键词是static，例如：classBlock{staticintnumber=50;}</p><p>所有从Block类创建的对象的number变量值都是相同的。无任在哪个对象里改变了number的值,所有对象的number都跟着改变。同样的,你可以定义static成员函数,但这个成员函数不能访问非static函数和变量。classBlock{staticintnumber=50;intlocalvalue;staticvoidadd_local(){localvalue++;//没有运行}staticvoidadd_static(){number++;//运行}}</p><h2 id="5-this和super"><a href="#5-this和super" class="headerlink" title="5.this和super"></a>5.this和super</h2><p>访问一个类的实例变量时,this关键词是指向这个类本身的指针,在前面ClassOne例子中,我们可以增加构造函数如下：</p><p>publicclassClassOne{inti;publicClassOne(){i=10;}</p><p>publicClassOne(intvalue)this.i=value;}</p><p>publicvoidAdd_i(intj){i=i+j;}}</p><p>这里,this指向ClassOne类的指针。如果在一个子类里覆盖了父类的某个成员函数,但又想调用父类的成员函数,你可以用super关键词指向父类的成员函数。</p><p>importClassOne;publicclassNewClassextendsClassOne{publicvoidAdd_i(intj){i=i+(j/2);super.Add_i(j);}}</p><p>下面程序里,i变量被构造函数设成10,然后15，最后被父类(ClassOne)设成25。NewClassmnc;mnc=newNewClass();mnc.Add_i(10);</p><h2 id="6-类的类型"><a href="#6-类的类型" class="headerlink" title="6.类的类型"></a>6.类的类型</h2><p>至今为止,我用在类前面只用了一个public关键词,其实它有下面4种选择：abstract一个abstract类必须至少有一个虚拟函数,一个abstract类不能直接创建对象,必须继承子类后才能。</p><p>final一个final类声明了子类链的结尾,用final声明的类不能再派生子类。publicpublic类能被其它的类访问。在其它包里,如果想使用这个类必须先import,则它只能在它定义的package里使用。</p><h2 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7.抽象类"></a>7.抽象类</h2><p>面向对象的一个最大优点就是能够定义怎样使用这个类而不必真正定义好成员函数。如果程序由不同的用户实现时是很有用的，这不需用户使用相同的成员函数名。</p><p>在java里Graphics类里一个abstract类的例子如下：publicabstractclassGraphics{publicabstractvoiddrawLine(intx1,inty1,intx2,inty2);</p><p>publicabstractvoiddrawOval(intx,inty,intwidth,intheight);publicabstractvoiddrawRect</p><p>(intx,inty,intwidth,intheight);…}</p><p>在Graphics类里声明了几个成员函数,但成员函数的实际代码是在另外一处地方实现的。</p><p>publicclassMyClassextendsGraphics{publicvoiddrawLine(intx1,inty1,intx2,inty2){}}</p><p>当一个类包含一个abstract成员函数,这个类必须定义为abstract类。然而并不是abstract类的所有的成员函数都是abstract的。Abstract类不能有私有成员函数(它们不能被实现),也不能有静态成员函数。</p><h2 id="8-包-Packages"><a href="#8-包-Packages" class="headerlink" title="8.包(Packages)"></a>8.包(Packages)</h2><p>包(Package)由一组类(class)和界面(interface)组成。它是管理大型名字空间，避免名字冲突的工具。每一个类和界面的名字都包含在某个包中。按照一般的习惯，它的名字是由"."号分隔的单词构成，第一个单词通常是开发这个包的组织的名称。</p><p>定义一个编译单元的包编译单元的包由package语句定义。如果使用package语句，编译单元的第一行必须无空格，也无注释。其格式如下：packagepackageName;若编译单元无package语句，则该单元被置于一个缺省的无名的包中。使用其它包中的类和界面在Java语言里提供;一个包可以使用另一个包中类和界面的定义和实现的机制。用import关键词来标明来自其它包中的类。一个编译单元可以自动把指定的类和界面输入到它自己的包中。在一个包中的代码可以有两种方式来定义来自其它包中的类和界面：<em>在每个引用的类和界面前面给出它们所在的包的名字;//前缀包名法acme.project.FooBarobj=newacme.project.FooBar();*使用import语句，引入一个类或一个界面，或包含它们的包。引入的类和界面的名字在当前的名字空间可用。引入一个包时，则该包所有的公有类和界面均可用。其形式如下：//从acme.project引入所有类importacme.project.</em>;这个语句表示acme.project中所有的公有类被引入当前包。以下语句从acme.project包中进入一个类Employec_List。//从acme.project而引入Employee_Listimportacme.project.Employee_list;Employee_Listobj=newEmployee</p><p>_List();在使用一个外部类或界面时，必须要声明该类或界面所在的包，否则会产生编译错误。import(引用)类包(classpackage)用import关键词调入,指定package名字如路径和类名,用*匹配符可以调入多于一个类名。</p><p>importjava.Date;importjava.awt.*;</p><p>如果java源文件不包含package,它放在缺省的无名package。这与源文件同目录，类可以这样引入:importMyClass。</p><p>Java系统包：Java语言提供了一个包含窗口工具箱，实用程序，一般I/O,工具和网络功能的包。</p><p>java.applet这个包包含量了设计applet的类,用一个类Applet和三个接口.AppletContext;AppletStub;和AudioClip.</p><p>java.awt另一个窗口工具箱包.awt,包含了产生装饰物和GUI成员的类。这个package包括：</p><p>Button,Checkbox,Choice,Component,Graphics,Menu,Pane1,TextArea和TextField。</p><p>java.ioI/Opackage包含文件输入/输出类，FileInputStream和FileOutputStream.</p><p>java.lang这个包包含Java语言类,包含:对象,线程,异常出口,系统,整数,原点,数学,字符等。</p><p>java.net这个类支持TCP/IP网络协议，并包含Socket类,URL和URL相联系的类。</p><p>java.util这个类包含程序的同步类,它包含Date,Dictionary类等。</p><h1 id="四、Java程序编写"><a href="#四、Java程序编写" class="headerlink" title="四、Java程序编写"></a>四、Java程序编写</h1><p>象其它编程语言一样，Java 编程语言也被用来创建应用程序。一个共同的应用程序范例是在屏幕上显示字串“Hello World!” 。下列代码给出了这个 Java 应用程序。</p><p>虽然很多你可能都不明白，没有关系，主要是来体会一下 Java 程序是什么样子，你可以先看看，有个印象，然后可以先模仿着做。</p><h2 id="1-HelloWorldApp"><a href="#1-HelloWorldApp" class="headerlink" title="1.HelloWorldApp"></a>1.HelloWorldApp</h2><p>1.//</p><p>2.// HelloWorld 应用示例</p><p>3.//</p><p>4.public class HelloWorldApp{</p><p>\5. public static void main (String args[]) {</p><p>\6. System.out.println (“Hello World!”);</p><p>\7. }</p><p>8.}</p><p>以上程序行是在你的屏幕上打印“Hello World!”所需的最少代码。</p><h2 id="2-描述HelloWorldApp"><a href="#2-描述HelloWorldApp" class="headerlink" title="2.描述HelloWorldApp"></a>2.描述HelloWorldApp</h2><p>第 1-3 行</p><p>程序中的 1-3 行是注释行</p><p>1 //</p><p>2 // HelloWorld 应用示例</p><p>3 //</p><p>第 4 行</p><p>第 4 行声明类名为 HelloWorldApp。类名(Classname)是在源文件中指明的，它可在与源代码相同的目录上创建一个 classname · class 文件。在本例题中，编译器创建了一个称为HelloWorldApp.class的文件, 它包含了公共类HelloWorldApp的编译代码。</p><p>4 public class HelloWorldApp{</p><p>第 5 行</p><p>第 5 行是程序执行的起始点。Java 解释器必须发现这一严格定义的点，否则将拒绝运行程序。</p><p>其它程序语言(特别是 C 和 C++)也采用 main ()声明作为程序执行的起始点。此声明的不同部分将在本课程的后几部分介绍。</p><p>如果在程序的命令行中给出了任何自变量(命令行参数) ，它们将被传递给 main()方法中被称作 args 的 String 数组。在本例题中，未使用自变量。</p><p>public static void main (String args[]) {</p><p>public-方法 main()可被任何程序访问，包括 Java 解释器。</p><p>static- 是一个告知编译器 main()是用于类 HelloWorldApp 中的方法的关键字。</p><p>为使 main()在程序做其它事之前就开始运行，这一关键字是必要的。</p><p>void- 表明 main()不返回任何信息。这一点是重要的，因为 Java 编程语言要进行谨慎的类型检查，包括检查调用的方法确实返回了这些方法所声明的类型。</p><p>String args[] - 是一个 String 数组的声明， 它将包含位于类名之后的命令行中的自变量。</p><p>java HelloWorldApp args[0] args[1]· · · ·</p><p>第 6 行</p><p>第 6 行声明如何使用类名、对象名和方法调用。它使用由 System 类的 out 成员引用的 PrintStream 对象的 println()方法，将字串“Hello World!”打印到标准输出上。</p><p>6 System.out.println(“Hello World!”);</p><p>在这个例子中，println()方法被输入了一个字串自变量并将其写在了标准输出流上。</p><p>第 7-8 行</p><p>本程序的 7-8 行分别是方法 main()和类 HelloWorldApp 的下括号。</p><p>7 ｝</p><p>8 ｝</p><h2 id="3-编译并运行HelloWorldApp"><a href="#3-编译并运行HelloWorldApp" class="headerlink" title="3.编译并运行HelloWorldApp"></a>3.编译并运行HelloWorldApp</h2><p>编译</p><p>当你创建了 HelloWorldApp.java 源文件后，用下列程序行进行编译：</p><p>javac HelloWorldApp.java</p><p>如果编译器未返回任何提示信息， 新文件 HelloWorldApp.class 则被存储在与源文件相同的目录中，除非另有指定。</p><p>如果在编译中遇到问题，请参阅本模块的查错提示信息部分。</p><p>运行</p><p>为运行你的 HelloWorldApp 应用程序，需使用 Java 解释器和位于 bin 目录下的 java程序:</p><p>java HelloWorldApp</p><p>Hello World!</p><h2 id="4-编译查错"><a href="#4-编译查错" class="headerlink" title="4.编译查错"></a>4.编译查错</h2><p>编译时的错误，以下是编译时的常见错误：</p><p>javac:Command not found</p><p>PATH 变量未正确设置以包括 javac 编译器。javac 编译器位于 JDK 目录下的 bin 目录。</p><p>HelloWorldApp.java:6: Method printl(java.lang.String)</p><p>not found in class java.io.PrintStream.System.</p><p>out.printl (“Hello World!”);</p><p>方法名 println 出现打印错误。</p><p>In class HelloWorldApp:main must be public or static</p><p>该错误的出现是因为词 static 或 public 被放在了包含 main 方法的行之外。</p><p>运行时的错误 can’t find class HelloWorldApp(这个错误是在打印 java HelloWorldApp时产生的) ， 通常, 它表示在命令行中所指定的类名的拼写与 filename.class 文件的拼写不同。Java 编程语言是一种大小写区别对待的语言。</p><p>例如： public class HelloWorldapp {</p><p>创建了一个 HellloWorldapp.class ，它不是编译器所预期的类名(HelloWorldApp.class)。</p><h3 id="4-1-命名"><a href="#4-1-命名" class="headerlink" title="4.1.命名"></a>4.1.命名</h3><p>如果 java 文件包括一个公共类，那么它必须使用与那个公共类相同的文件名。例如在前例中的类的定义是</p><p>public class HelloWorldapp</p><p>源文件名则必须是 HelloWorldapp.java</p><h3 id="4-2-类计数"><a href="#4-2-类计数" class="headerlink" title="4.2.类计数"></a>4.2.类计数</h3><p>在源文件中每次只能定义一个公共类。</p><h3 id="4-3-源文件布局"><a href="#4-3-源文件布局" class="headerlink" title="4.3.源文件布局"></a>4.3.源文件布局</h3><p>一个 Java 源文件可包含三个“顶级”要素：</p><p>(1)一个包(package)声明(可选)</p><p>(2)任意数量的导入(import)语句</p><p>(3)类(class)声明</p><p>该三要素必须以上述顺序出现。即，任何导入语句出现在所有类定义之前;如果使用包声明，则包声明必须出现在类和导入语句之前。</p><h1 id="五、关键字"><a href="#五、关键字" class="headerlink" title="五、关键字"></a>五、关键字</h1><h2 id="1-什么是关键字"><a href="#1-什么是关键字" class="headerlink" title="1.什么是关键字"></a>1.什么是关键字</h2><p>Java 语言保留的，Java 的开发和运行平台认识，并能正确处理的一些单词。</p><p>其实就是个约定，就好比我们约定好，我画个勾勾表示去吃饭。那好了，只要我画个勾勾，大家就知道是什么意思，并能够正确执行了。</p><p>关键字这个约定在 Java 语言和 Java 的开发和运行平台之间，我们只要按照这个约定使用了某个关键字，Java 的开发和运行平台就能够认识它，并正确地处理。</p><h2 id="2-Java中有哪些关键字"><a href="#2-Java中有哪些关键字" class="headerlink" title="2.Java中有哪些关键字"></a>2.Java中有哪些关键字</h2><p>abstract  do  implements  private  throw</p><p>boolean  double  import  protected  throws</p><p>break  else  instanceof  public  transient</p><p>byte  extends  int  return  true</p><p>case  false  interface  short  try</p><p>catch  final  long  static  void</p><p>char  finally  native  super  volatile</p><p>class  float  new  switch  while</p><p>continue  for  null  synchronized  enum</p><p>default  if  package  this  assert</p><h2 id="3-Java中关键字的基本含义"><a href="#3-Java中关键字的基本含义" class="headerlink" title="3.Java中关键字的基本含义"></a>3.Java中关键字的基本含义</h2><p>• abstract：表明类或类中的方法是抽象的;</p><p>• boolean：基本数据类型之一，布尔类型;</p><p>• break：提前跳出一个块;</p><p>• byte：基本数据类型之一，字节类型;</p><p>• case：在 switch 语句中，表明其中的一个分支;</p><p>• catch：用于处理例外情况，用来捕捉异常;</p><p>• char：基本数据类型之一，字符类型;</p><p>• class：类;</p><p>• continue：回到一个块的开始处;</p><p>• default：用在 switch 语句中，表明一个默认的分支;</p><p>• do：用在”do while”循环结构中;</p><p>• double：基本数据类型之一，双精度浮点数类型;</p><p>• else：在条件语句中，表明当条件不成立时的分支;</p><p>• extends：用来表明一个类是另一个类的子类;</p><p>• final：用来表明一个类不能派生出子类，或类中的方法不能被覆盖，或声明一个变量是常量;</p><p>• finally：用于处理异常情况，用来声明一个肯定会被执行到的块;</p><p>• float：基本数据类型之一，单精度浮点数类型;</p><p>• for：一种循环结构的引导词;</p><p>• if：条件语句的引导词;</p><p>• implements：表明一个类实现了给定的接口;</p><p>• import：表明要访问指定的类或包;</p><p>• instanceof：用来测试一个对象是否是一个指定类的实例;</p><p>• int：基本数据类型之一，整数类型;</p><p>• interface：接口;</p><p>• long：基本数据类型之一，长整数类型;</p><p>• native：用来声明一个方法是由与机器相关的语言(如 C/C++/FORTRAN 语言)实现的;</p><p>• new：用来申请新对象;</p><p>• package：包;</p><p>• private：一种访问方式：私有模式;</p><p>• protected：一种访问方式：保护模式;</p><p>• public：一种访问方式：公共模式;</p><p>• return：从方法中返回值;</p><p>• short：基本数据类型之一，短整数类型;</p><p>• static：表明域或方法是静态的，即该域或方法是属于类的;</p><p>• strictfp：用来声明 FP-strict(双精度或单精度浮点数)表达式，参见 IEEE 754 算术规范;</p><p>• super：当前对象的父类对象的引用;</p><p>• switch：分支结构的引导词;</p><p>• synchronized：表明一段代码的执行需要同步;</p><p>• this：当前对象的引用;</p><p>• throw：抛出一个异常;</p><p>• throws：声明方法中抛出的所有异常;</p><p>• transient：声明不用序列化的域;</p><p>• try：尝试一个可能抛出异常的程序块</p><p>• void：表明方法不返回值;</p><p>• volatile：表明两个或多个变量必须同步地发生变化;</p><p>• while：用在循环结构中;</p><p>• assert：声明断言;</p><p>• enum：声明枚举类型;</p><h2 id="4-解释几点"><a href="#4-解释几点" class="headerlink" title="4.解释几点"></a>4.解释几点</h2><p>(1)：这些关键字的具体含义和使用方法，会在后面用到的地方讲述</p><p>(2)：Java 的关键字也是随新的版本发布在不断变动中的，不是一成不变的</p><p>(3)：所有关键字都是小写的</p><p>(4)：goto 和 const 不是 Java 编程语言中使用的关键字，但是是 Java 的保留字，也就是说 Java 保留了它们，但是没有使用它们。true 和 false 不是关键字，而是 boolean 类型直接量</p><p>(5)：表示类的关键字是 class</p><h1 id="六、数据类型"><a href="#六、数据类型" class="headerlink" title="六、数据类型"></a>六、数据类型</h1><h2 id="1-什么叫数据类型"><a href="#1-什么叫数据类型" class="headerlink" title="1.什么叫数据类型"></a>1.什么叫数据类型</h2><p>数据类型简单的说就是对数据的分类， 对数据各自的特点进行类别的划分， 划分的每种数据类型都具有区别于其它类型的特征， 每一类数据都有相应的特点和操作功能。 例如数字类型的就能够进行加减乘除的操作。</p><p>在现实生活中， 我们通常会对信息进行分类， 从而使得我们能很容易的判断某个数据是表示一个百分数还是一个日期，我们通常是通过判断数字是否带”%”，或者是否是一个我们熟悉的”日期格式”。</p><p>类似的在程序中， 计算机也需要某种方式来判断某个数字是什么类型的。 这通常是需要程序员显示来声明某个数据是什么类型的，Java 就是这样的。Java 是一种强类型的语言，凡是使用到的变量，在编译之前一定要被显示的声明。</p><h2 id="2-Java数据类型的分类"><a href="#2-Java数据类型的分类" class="headerlink" title="2.Java数据类型的分类"></a>2.Java数据类型的分类</h2><p>Java 里面的数据类型从大的方面分为两类，一是基本数据类型，一是引用类型，基本 的 Java 数据类型层次图如下：</p><h2 id="3-Java中的基本数据类型"><a href="#3-Java中的基本数据类型" class="headerlink" title="3.Java中的基本数据类型"></a>3.Java中的基本数据类型</h2><p>Java 中的基本数据类型分为八个原始数据类型，原始类型可分为四种：</p><p>(1)整数型：byte、short、int、long</p><p>(2)浮点型：float、double</p><p>(3)字符型：char</p><p>(4)逻辑型：boolean</p><h3 id="3-1-整数型：byte、short、int、long"><a href="#3-1-整数型：byte、short、int、long" class="headerlink" title="3.1.整数型：byte、short、int、long"></a>3.1.整数型：byte、short、int、long</h3><p>byte：字节型</p><p>short：短整型</p><p>int： 整型</p><p>long：长整型</p><p>在 Java 中，整数型的值都是带符号的数字，可以用十进制、八进制和十六进制来表示。</p><p>所谓多少进制， 就是满多少就进位的意思， 如十进制表示逢十进位， 八进制就表示逢八进位。</p><p>示例：</p><p>15：十进制的 15</p><p>015：八进制的 15 ，相当于十进制的 13，计算公式：1*8 +5 = 13</p><p>0x15：十六进制的 15，相当于十进制的 21，计算公式：1*16+5=21</p><p>3.1.1.在Java中的定义示例</p><p>示例 1.byte abc = 5;</p><p>表示在 Java 中定义一个变量 abc，类型是 byte 类型，值是 5</p><p>同理可以定义其它的类型：</p><p>比如：</p><p>short abc1 = 5;</p><p>int abc2 = 5;</p><p>long abc3 = 5;</p><p>这些都是可以的，如果要明确表示是long型的值，可以在后面直接跟一个字母“L”。L表示一个long值。</p><p>也就是写成：long abc4 = 5L;</p><p>请注意，在 Java 编程语言中使用大写或小写 L 同样都是有效的，但由于小写 l 与数字 1 容易混淆，因而，尽量不要使用小写。</p><p>注意：整数型的值，如果没有特别指明，默认是是int型</p><p>3.1.2取值范围和默认值</p><p>取值范围的表示是按 Java 编程语言规范定义的且不依赖于平台</p><h3 id="3-2-浮点型：float、double"><a href="#3-2-浮点型：float、double" class="headerlink" title="3.2.浮点型：float、double"></a>3.2.浮点型：float、double</h3><p>Java 用浮点型来表示实数，简单地说就是带小数的数据。</p><p>用 float 或 double 来定义浮点类型，如果一个数字包括小数点或指数部分，或者在数字后带有字母 F 或 f(float) 、D 或 d(double) ，则该数字文字为浮点型的。</p><p>示例：</p><p>12.3 //简单的浮点型数据</p><p>12.3E10 //数据很大的一个浮点数据</p><p>3.2.1.在在Java中的定义示例</p><p>如下定义都是可以的：</p><p>float abc = 5.6F;</p><p>float abc = 5.6f;</p><p>double abc = 5.6;</p><p>double abc = 5.6D;</p><p>double abc = 5.6d;</p><p>3.2.2.提示</p><p>(1)浮点型的值，如果没有特别指明，默认是是double型的</p><p>(2)定义float型的时候，一定要指明是float型的，可以通过在数字后面添加”F”或者”f”来表示。</p><p>(3)定义double型的时候，可以不用指明，默认就是double型的，也可以通过在数字后面添加”D”或者”d”来表示。</p><p>3.2.3 取值范围 和 默认值</p><p>Java 技术规范的浮点数的格式是由电力电子工程师学会(IEEE)754 定义的，是独立于平台的。 可以通过 Float.MAX_VALUE 和 Float.MIN_VALUE 取得 Float 的最大最小值; 可以通过 Double.MAX_VALUE 和 Double.MIN_VALUE 来取得 Double 的最大最小值。</p><h3 id="3-3-字符型：char"><a href="#3-3-字符型：char" class="headerlink" title="3.3.字符型：char"></a>3.3.字符型：char</h3><p>char类型用来表示单个字符。一个char代表一个16-bit无符号的(不分正负的)</p><p>Unicode字符，一个char字符必须包含在单引号内。</p><p>示例：</p><p>‘a’//表示简单的字符</p><p>‘1’//用数字也可以表示字符</p><p>下面就错了，只能使用单个字符</p><p>‘ab’//错误</p><p>‘12’//错误</p><p>3.3.1.什么是Unicode编码</p><p>Unicode 编码又叫统一码、万国码或单一码，是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码， 以满足跨语言、 跨平台进行文本转换、 处理的要求。 1990 年开始研发， 1994 年正式公布。 随着计算机工作能力的增强， Unicode也在面世以来的十多年里得到普及。unicode 的表达如下：</p><p>‘\u????’ 一个 Unicode 字符。????应严格按照四个 16 进制数进行替换。</p><p>3.3.2.在在Java中的定义示例</p><p>char c = ‘a’;</p><p>char c = ‘1’;</p><p>3.3.3.取值范围和默认值</p><p>3.3.4.Java里面的转义字符</p><p>转义字符是指， 用一些普通字符的组合来代替一些特殊字符， 由于其组合改变了原来字符表示的含义，因此称为“转义”。 常见的转义字符：</p><p>\n 回车(\u000a)</p><p>\t 水平制表符(\u0009)</p><p>\b 空格(\u0008)</p><p>\r 换行(\u000d)</p><p>\f 换页(\u000c)</p><p>' 单引号(\u0027)</p><p>" 双引号(\u0022)</p><p>\ 反斜杠(\u005c)</p><h3 id="3-4-逻辑型：boolean"><a href="#3-4-逻辑型：boolean" class="headerlink" title="3.4.逻辑型：boolean"></a>3.4.逻辑型：boolean</h3><p>逻辑值有两种状态， 即人们经常使用的 “on” 和 “off” 或 “true” 和 “false” 或 “yes”</p><p>和“no” ，这样的值是用 boolean 类型来表示的。boolean 有两个文字值，即 true 和 false。</p><p>以下是一个有关 boolean 类型变量的声明和初始化：</p><p>boolean truth = true; //声明变量 truth</p><p>注意──在整数类型和 boolean 类型之间无转换计算。有些语言(特别值得强调的是 C和 C++)允许将数字值转换成逻辑值(所谓“非零即真” ),这在 Java 编程语言中是不允许的;boolean 类型只允许使用 boolean 值(true 或 false) 。</p><p>注意：Java中不可以直接将整数类型和逻辑类型转换.</p><h3 id="3-5-声明和赋值"><a href="#3-5-声明和赋值" class="headerlink" title="3.5.声明和赋值"></a>3.5.声明和赋值</h3><p>3.5.1.什么是声明</p><p>声明为 Java 程序实体引入标识符， 能够使用这些名字访问到这些实体， 声明实体包括：类名、属性名、方法名、变量名、参数名、接口名等等。其实简单点说就是定义某个东西并对外宣称它。</p><p>3.5.2.什么是赋值</p><p>赋值就是为一个声明的变量或者常量赋予具体的值， 也就是赋予值的意思。 使用一个等号”=”来表示。</p><p>示例：</p><p>int a = 5;</p><p>这句话的意思就是，声明一个类型为int的变量a，并将它赋值为5。</p><h3 id="3-6-特别介绍：字符串型String"><a href="#3-6-特别介绍：字符串型String" class="headerlink" title="3.6.特别介绍：字符串型String"></a>3.6.特别介绍：字符串型String</h3><p>字符型只能表示一个字符，那么多个字符怎么表示呢？</p><p>Java 中使用 String 这个类来表示多个字符， 表示方式是用双引号把要表示的字符串引起来，字符串里面的字符数量是任意多个。字符本身符合 Unicode 标准，且上述 char 类型的反斜线符号 (转义字符) 适用于 String。 与 C 和 C++不同， String 不能用 \0 作为结束。 String的文字应用双引号封闭，如下所示：</p><p>“The quick brown fox jumped over the lazy dog.”</p><p>char 和 String 类型变量的声明和初始化如下所示：</p><p>char ch = ‘A’; // 声明并初始化一个字符变量</p><p>char ch1,ch2 ; //声明两个字符变量</p><p>// 声明两个字符串变量并初始化它们</p><p>String greeting = “Good Morning !! \n” ;</p><p>String err_msg = “Record Not Found !” ;</p><p>String str1,str2 ; // 声明两个字符串变量</p><p>String s = “12abc”; //基本的字符串型</p><p>String s = “”; //表示空串</p><p>注意：</p><p>(1)：String不是原始的数据类型，而是一个类(class)</p><p>(2)：String包含的字符数量是任意多个，而字符类型只能是一个。</p><p>要特别注意：”a”表示的是字符串，而’a’表示的是字符类型，它们具有不同的功能。</p><p>(3)：String的默认值是null</p><h3 id="3-7-示例"><a href="#3-7-示例" class="headerlink" title="3.7.示例"></a>3.7.示例</h3><p>下列程序显示了如何为整数、浮点数、boolean、字符和 String 类型变量声明和赋值</p><p>\1. public class Assign {</p><p>\2. public static void main(String args []) {</p><p>\3. int x, y; // 声明 int 变量</p><p>4.float z = 3.414f; // 声明并赋值 float</p><p>5.double w = 3.1415; //声明并赋值 double</p><p>6.boolean truth = true; //声明并赋值 boolean</p><p>7.char c; // 声明字符变量</p><p>8.String str; // 声明 String 字符串</p><p>9.String str1 = “bye”; //声明并赋值 String 变量</p><p>10.c = ‘A’; // 给字符变量赋值</p><p>11.str = “Hi out there!”; // 给 String 变量赋值</p><p>12.x = 6;</p><p>13.y = 1000; // 给 int 变量赋值</p><p>14….</p><p>15.}</p><p>16.}</p><p>非法赋值举例</p><p>y = 3.1415926; // 3.1415926 不是一个 int.</p><p>// 需要类型转换并且小数位要截掉</p><p>w = 175,000; // 逗号( , ) 不能够出现</p><p>truth = 1; // 一个优秀的 C/C++程序员常犯的错误，在 Java 语言中 boolean 型变量只能为 true 或 false</p><p>z = 3.14156 ; // double 型的值不能赋给 float 变量，需要类型转换</p><h1 id="七、面向对象三大特征"><a href="#七、面向对象三大特征" class="headerlink" title="七、面向对象三大特征"></a>七、面向对象三大特征</h1><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><p>封装这个词听起来好象是将什么东西包裹起来不要别人看见一样，就好象是把东西装进箱子里面，这样别人就不知道箱子里面装的是什么东西了。其实 JAVA 中的封装这个概念也就和这个是差不多的意思。</p><p>封装是 JAVA 面向对象的特点的表现，封装是一种信息隐蔽技术。它有两个含义：即把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位; 以及尽可能隐藏对象的内部结构。也就是说，如果我们使用了封装技术的话，别人就只能用我们做出来的东西而看不见我们做的这个东西的内部结构了。</p><p>封装的功能</p><p>- 隐藏对象的实现细节</p><p>- 迫使用户去使用一个界面访问数据</p><p>- 使代码更好维护</p><p>封装迫使用户通过方法访问数据能保护对象的数据不被误修改，还能使对象的重用变得更简单。数据隐藏通常指的就是封装。它将对象的外部界面与对象的实现区分开来，隐藏实现细节。迫使用户去使用外部界面，即使实现细节改变，还可通过界面承担其功能而保留原样，确保调用它的代码还继续工作。封装使代码维护更简单。</p><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h2><p>is a 关系—— 子对象</p><p>在面向对象世界里面，常常要创建某对象(如：一个职员对象)，然后需要一个该基本对象的更专业化的版本，比如，可能需要一个经理的对象。显然经理实际上是一个职员，经理和职员具有 is a 的关系，经理只是一个带有附加特征的职员。因此，需要有一种办法从现有对象来创建一个新对象。这个方式就是继承。</p><p>“继承”是面向对象软件技术当中的一个概念。 如果一个 对象 A 继承自另一个 对象 B， 就把这个 A 称为”B 的子 对象 “，而把 B 称为”A 的父 对象 “。继承可以使得子 对象 具有父 对象 的各种属性和方法，而不需要再次编写相同的代码。在令子 对象 继承父 对象 的同时，可以重新定义某些属性，并重写某些方法，即覆盖父 对象 的原有属性和方法，使其获得与父对象不同的功能。</p><h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h2><p>同一行为的多种不同表达，或者同一行为的多种不同实现就叫做多态。</p><p>还是用刚才经理和职员这个例子来举例：人事部门需要对公司所有职员统一制作胸卡(一般也就是门禁卡，进出公司证明身份使用)，制作的师傅说，只要告诉我一个人员的信息，就可以制作出一份胸卡，简化一下就是：一位职员的信息对应一份胸卡。</p><p>这个时候，对胸卡制作的师傅而言，所有的人都是职员，无所谓是经理还是普通职员。</p><p>也就是说，对于传递职员信息这样一个行为，存在多种不同的实现，既可以传递经理的信息， 也可以传递普通职员的信息。这就是多态的表现。</p><p>再举一个例子：比如我们说“笔”这个对象，它就有很多不同的表达或实现，比如有钢笔、铅笔、圆珠笔等等。那么我说“请给我一支笔”，你给我钢笔、铅笔或者圆珠笔都可以，这里的“笔”这个对象就具备多态。</p><h1 id="八、Java类的基本构成"><a href="#八、Java类的基本构成" class="headerlink" title="八、Java类的基本构成"></a>八、Java类的基本构成</h1><h2 id="1-Java类的定义形式"><a href="#1-Java类的定义形式" class="headerlink" title="1.Java类的定义形式"></a>1.Java类的定义形式</h2><p>一个完整的 Java 类通常由下面六个部分组成：</p><p>包定义语句</p><p>import 语句</p><p>类定义{</p><p>成员变量</p><p>构造方法</p><p>成员方法</p><p>}</p><p>其中：只有类定义和“{}”是不可或缺的，其余部分都可以根据需要来定义。</p><p>下面分别来学习各个部分的基本规则，看看如何写 Java 的类。</p><h2 id="2-包"><a href="#2-包" class="headerlink" title="2.包"></a>2.包</h2><h3 id="2-1-包是什么"><a href="#2-1-包是什么" class="headerlink" title="2.1.包是什么"></a>2.1.包是什么</h3><p>在 Java 中，包是类、接口或其它包的集合，包主要用来将类组织起来成为组，从而对类进行管理。</p><h3 id="2-2-包能干什么"><a href="#2-2-包能干什么" class="headerlink" title="2.2.包能干什么"></a>2.2.包能干什么</h3><p>包对于下列工作非常有用：</p><p>(1)：包允许您将包含类代码的文件组织起来，易于查找和使用适当的类。</p><p>(2)：包不止是包含类和接口，还能够包含其它包。形成层次的包空间。</p><p>(3)：它有助于避免命名冲突。当您使用很多类时，确保类和方法名称的唯一性是非常困难的。包能够形成层次命名空间，缩小了名称冲突的范围，易于管理名称。</p><p>为便于管理数目众多的类，Java 语言中引入了“包”的概念，可以说是对定义的 Java类进行“分组” ，将多个功能相关的类定义到一个“包”中，以解决命名冲突、引用不方便、安全性等问题。</p><p>就好似当今的户籍制度，每个公民除有自己的名字“张三” 、 “李四”外还被规定了他的户籍地。假定有两个人都叫张三，只称呼名字就无法区分他们，但如果事先登记他们的户籍分别在北京和上海，就可以很容易的用“北京的张三” 、 “上海的张三”将他们区分开来。如果北京市仍有多个张三，还可以细分为“北京市.海淀区的张三” 、 “北京市.西城区.平安大街的张三”等等，直到能惟一标识每个“张三”为止。</p><p>JDK 中定义的类就采用了“包”机制进行层次式管理，下图显示了其组织结构的一部分：</p><p>从图中可以看出，一个名为 java 的包中又包含了两个子包：io 包和 lang 包。lang 包中包含了 System, String, Object 三个类的定义。事实上，Java 包中既可以包含类的定义，也可以包含子包，或同时包含两者。</p><p>简而言之：从逻辑上讲，包是一组相关类的集合;从物理上讲，同包即同目录。</p><h3 id="2-1-JDK中常用的包"><a href="#2-1-JDK中常用的包" class="headerlink" title="2.1.JDK中常用的包"></a>2.1.JDK中常用的包</h3><p>java.lang—-包含一些 Java 语言的核心类，包含构成 Java 语言设计基础的类。在此包中定义的最重要的一个类是“Object” ，代表类层次的根，Java 是一个单根系统，最终的根就是“Object” ，这个类会在后面讲到。</p><p>Java 并不具有“自由”的方法，例如，不属于任何类的方法，Java 中的所有方法必须始终属于某个类。经常需要使用数据类型转换方法。Java 在 Java.lang 包中定义了“包装对象”类，使我们能够实现数据类型转换。如 Boolean、Character、Integer、Long、Float 和Double，这些在后面会讲到。</p><p>此包中的其它类包括：</p><p>? Math——封装最常用的数学方法，如正弦、余弦和平方根。</p><p>? String，StringBuffer——封装最常用的字符串操作。</p><p>你不必显示导入该包，该 Java 包通常已经导入。</p><p>java.awt—-包含了构成抽象窗口工具集(abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。</p><p>javax.swing—-完全 Java 版的图形用户界面(GUI)解决方案，提供了很多完备的组件，可以应对复杂的桌面系统构建。</p><p>java.net—-包含执行与网络相关的操作的类，如 URL, Socket, ServerSocket 等。</p><p>java.io—-包含能提供多种输入/输出功能的类。</p><p>java.util—-包含一些实用工具类，如定义系统特性、使用与日期日历相关的方法。还有重要的集合框架。</p><h3 id="2-2-Java中如何表达包——package语句"><a href="#2-2-Java中如何表达包——package语句" class="headerlink" title="2.2.Java中如何表达包——package语句"></a>2.2.Java中如何表达包——package语句</h3><p>Java 语言使用 package 语句来实现包的定义。package 语句必须作为 Java 源文件的第一条语句， 指明该文件中定义的类所在的包。 若缺省该语句， 则指定为无名包， 其语法格式为：</p><p>package pkg1[.pkg2[.pkg3…]]; //“[]”表示可选Java 编译 器 把包对 应 于 文 件系 统 的目 录管 理，因此包也可以嵌套使用，即一个包中可以含有类的定义也可以含有子包，其嵌套层数没有限制。package 语句中，用‘.’来指明包的层次;</p><p>Java 语言要求包声明的层次和实际保存类的字节码文件的目录结构存在对应关系， 以便将来使用该类时能通过包名(也就是目录名)查找到所需要的类文件。简单地说就是包的层次结构需要和文件夹的层次对应。</p><p>注意：每个源文件只有一个包的声明，而且包名应该全部小写。</p><p>具体来说，程序员要做以下工作：</p><h3 id="2-3-编译和生成包"><a href="#2-3-编译和生成包" class="headerlink" title="2.3.编译和生成包"></a>2.3.编译和生成包</h3><p>如果在程序 Test.java 中已定义了包 p1，就必须将编译生成的字节码文件 Test.class 保存在与包名同名的子目录中，可以选用下述两种方式之一：</p><p>采用下述命令编译：</p><p>javac Test.java</p><p>则编译器会在当前目录下生成 Test.class 文件， 再在适合位置手动创建一个名为 p1 的子目录，将 Test.class 复制到该 p1 目录下。</p><p>采用简化的编译命令，就是可以带包编译</p><p>javac -d destpath Test.java</p><p>归入该包的类的字节代码文件应放在 java 的类库所在路径的 destpath 子目录下。 现在包的相对位置已经决定了，但 java 类库的路径还是不定的。事实上，java 可以有多个存放类库的目录，其中的缺省路径为 java 目录下的 lib 子目录，你可以通过使用-classpath 选项来确定你当前想选择的类库路径。 除此之外， 你还可以在 CLASSPATH 环境变量中设置类库路径。 destpath 为目标路径， 可以是本地的任何绝对或相对路径。 则编译器会自动在 destpath目录下建立一个子目录 p1，并将生成的.class 文件自动保存到 destpath/p1 下。例如：</p><p>javac -d .\ Test.java</p><p>javac -d C:\test\ Test.java</p><h3 id="2-4-带包运行"><a href="#2-4-带包运行" class="headerlink" title="2.4.带包运行"></a>2.4.带包运行</h3><p>运行带包的程序，需要使用类的全路径，也就是带包的路径，比如上面的那个程序，就使用如下的代码进行运行：</p><p>java p1.Test</p><h2 id="3-import"><a href="#3-import" class="headerlink" title="3.import"></a>3.import</h2><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用“import”语句可完成此功能。在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以有 0~多条，其语法格式为：</p><p>import package1[.package2…].(classname|*);</p><p>java 运行时环境将到 CLASSPATH + package1.[package2…]路径下寻找并载入相应的字节码文件 classname.class。 “*”号为通配符，代表所有的类。也就是说 import 语句为编译器指明了寻找类的途径。</p><p>例，使用 import 语句引入类程序：TestPackage.java</p><p>java 编译器默认为所有的 java 程序引入了 JDK 的 java.lang 包中所有的类(import java.lang.*;) ，其中定义了一些常用类：System、String、Object、Math 等。因此我们可以直接使用这些类而不必显式引入。但使用其它非无名包中的类则必须先引入、后使用。</p><h3 id="3-1-Java类搜寻方式"><a href="#3-1-Java类搜寻方式" class="headerlink" title="3.1.Java类搜寻方式"></a>3.1.Java类搜寻方式</h3><p>程序中的 import 语句标明要引入 p1 包中的 Test 类， 假定环境变量 CLASSPATH 的值为</p><p>“.;C:\jdk6\lib;D:\ex” ， java 运行环境将依次到下述可能的位置寻找并载入该字节码</p><p>文件 Test.class：</p><p>.\p1\Test.class</p><p>C:\jdk6\lib\p1\Test.class</p><p>D:\ex\p1\Test.class</p><p>其中， “.”代表当前路径，如果在第一个路径下就找到了所需的类文件，则停止搜索。</p><p>否则依次搜索后续路径，如果在所有的路径中都未找到所需的类文件，则编译或运行出错。</p><h2 id="4-访问修饰符"><a href="#4-访问修饰符" class="headerlink" title="4.访问修饰符"></a>4.访问修饰符</h2><p>Java 语言允许对类中定义的各种属性和方法进行访问控制， 即规定不同的保护等级来限制对它们的使用。为什么要这样做?Java 语言引入类似访问控制机制的 目的 在 于实 现 信息的 封 装 和 隐藏。 Java 语言为对类中的属性和方法进行有效地访问控制， 将它们分为四个等级：private, 无修饰符, protected, public，具体规则如下：</p><p>变量和方法可以处于四个访问级别中的一个：公共，受保护，无修饰符或私有。类可以在公共或无修饰级别。</p><p>变量、方法或类有缺省(无修饰符)访问性，如果它没有显式受保护修饰符作为它的声明的一部分的话。这种访问性意味着，访问可以来自任何方法，当然这些方法只能在作为对象的同一个包中的成员类当中。</p><p>以修饰符 protected 标记的变量或方法实际上比以缺省访问控制标记的更易访问。 一个protected 方法或变量可以从同一个包中的类当中的任何方法进行访问， 也可以是从任何子类中的任何方法进行访问。 当它适合于一个类的子类但不是不相关的类时， 就可以使用这种受保护访问来访问成员。</p><h2 id="5-类定义"><a href="#5-类定义" class="headerlink" title="5.类定义"></a>5.类定义</h2><p>Java 程序的基本单位是类，你建立类之后，就可用它来建立许多你需要的对象。Java把每一个可执行的成分都变成类。</p><p>类的定义形式如下：</p><p>这里，类名要是合法的标识符。在类定义的开始与结束处必须使用花括号。你也许想建立一个矩形类，那么可以用如下代码：</p><p>​    </p><h2 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6.构造方法"></a>6.构造方法</h2><h3 id="6-1-什么是构造方法"><a href="#6-1-什么是构造方法" class="headerlink" title="6.1.什么是构造方法"></a>6.1.什么是构造方法</h3><p>类有一个特殊的成员方法叫作构造方法， 它的作用是创建对象并初始化成员变量。 在创建对象时，会自动调用类的构造方法。</p><h3 id="6-2-构造方法定义规则"><a href="#6-2-构造方法定义规则" class="headerlink" title="6.2.构造方法定义规则"></a>6.2.构造方法定义规则</h3><p>Java 中的构造方法必须与该类具有相同的名字，并且没有方法的返回类型(包括没有void) 。另外，构造方法一般都应用 public 类型来说明，这样才能在程序任意的位置创建类的实例–对象。</p><h3 id="6-3-示例"><a href="#6-3-示例" class="headerlink" title="6.3.示例"></a>6.3.示例</h3><p>下面是一个 Rectangle 类的构造方法，它带有两个参数，分别表示矩形的长和宽：</p><h3 id="6-4-说明"><a href="#6-4-说明" class="headerlink" title="6.4.说明"></a>6.4.说明</h3><p>每个类至少有一个构造方法。 如果不写一个构造方法， Java 编程语言将提供一个默认的，该构造方法没有参数，而且方法体为空。</p><p>注意：如果一个类中已经定义了构造方法则系统不再提供默认的构造方</p><h2 id="7-析构方法"><a href="#7-析构方法" class="headerlink" title="7.析构方法"></a>7.析构方法</h2><p>析构方法 finalize 的功能是： 当对象被从内存中删除时， 该成员方法将会被 自动调用。通常，在析构方法内，你可以填写用来回收对象内部的动态空间的代码。</p><p>特别注意：当我们去调用析构方法的时候，并不会引起该对象实例从内存中删除，而是不会起到任何作用。</p><p>在 Java 编程里面，一般不需要我们去写析构方法，这里只是了解一下就可以了。</p><h2 id="8-属性"><a href="#8-属性" class="headerlink" title="8.属性"></a>8.属性</h2><h3 id="8-1-属性是什么"><a href="#8-1-属性是什么" class="headerlink" title="8.1.属性是什么"></a>8.1.属性是什么</h3><p>简单点说，属性就是对象所具有的静态属性。</p><h3 id="8-2-定义规则"><a href="#8-2-定义规则" class="headerlink" title="8.2.定义规则"></a>8.2.定义规则</h3><p>Java 类中属性的声明采用如下格式：</p><p>访问修饰符 修饰符 类型 属性名称=初始值;</p><p>访问修饰符：可以使用四种不同的访问修饰符中的一种，包括 public(公共的)、protected(受保护的) ，无修饰符和 private(私有的) 。public 访问修饰符表示属性可以从任何其它代码调用。private 表示属性只可以由该类中的其它方法来调用。protected 将在以后的课程中讨论。</p><p>修饰符：是对属性特性的描述，例如后面会学习到的：static、final 等等。</p><p>类型：属性的数据类型，可以是任意的类型。</p><p>属性名称：任何合法标识符</p><p>初始值：赋值给属性的初始值。如果不设置，那么会自动进行初始化，基本类型使用缺省值，对象类型自动初始化为 null。</p><h3 id="8-3-说明"><a href="#8-3-说明" class="headerlink" title="8.3.说明"></a>8.3.说明</h3><p>属性有时候也被称为成员变量、实例变量、域，它们经常被互换使用。</p><h2 id="9-方法"><a href="#9-方法" class="headerlink" title="9.方法"></a>9.方法</h2><h3 id="9-1-方法是什么"><a href="#9-1-方法是什么" class="headerlink" title="9.1.方法是什么"></a>9.1.方法是什么</h3><p>方法就是对象所具有的动态功能。</p><h3 id="9-2-定义规则"><a href="#9-2-定义规则" class="headerlink" title="9.2.定义规则"></a>9.2.定义规则</h3><p>Java 类中方法的声明采用以下格式：访问修饰符 修饰符 返回值类型 方法名称 (参数列表) throws 异常列表 {方法体}</p><p>访问修饰符：可以使用四种不同的访问修饰符中的一种，包括 public(公共的)、protected(受保护的) ，无修饰符和 private(私有的) 。public 访问修饰符表示方法可以从任何其它代码调用。private 表示方法只可以由该类中的其它方法来调用。protected 将在以后的课程中讨论。</p><p>修饰符：是对方法特性的描述，例如后面会学习到的：static、final、abstract、synchronized 等等。</p><p>返回值类型：：表示方法返回值的类型。 如果方法不返回任何值， 它必须声明为 void(空)。</p><p>Java 技术对返回值是很严格的，例如，如果声明某方法返回一个 int 值，那么方法必须从所有可能的返回路径中返回一个 int 值(只能在等待返回该 int 值的上下文中被调用。 )</p><p>方法名称：可以是任何合法标识符，并带有用已经使用的名称为基础的某些限制条件。</p><p>参数列表：允许将参数值传递到方法中。列举的元素由逗号分开，而每一个元素包含一个类型和一个标识符。在下面的方法中只有一个形式参数，用 int 类型和标识符 days 来声明：public void test(int days){}</p><p>throws 异常列表：子句导致一个运行时错误(异常)被报告到调用的方法中，以便以合适的方式处理它。异常在后面的课程中介绍。</p><p>花括号内是方法体，即方法的具体语句序列。</p><h3 id="9-3-示例"><a href="#9-3-示例" class="headerlink" title="9.3.示例"></a>9.3.示例</h3><p>比如现在有一个“车”的类——Car， “车”具有一些基本的属性，比如四个轮子，一个方向盘，车的品牌等等。当然，车也具有自己的功能，也就是方法，比如车能够“开动”——run。要想车子能够开动，需要给车子添加汽油，也就是说，需要为 run 方法传递一些参数“油”进去。车子跑起来过后，我们需要知道当前车辆运行的速度，就需要 run 方法具有返回值“当前的速度” 。</p><h3 id="9-4-形参和实参"><a href="#9-4-形参和实参" class="headerlink" title="9.4.形参和实参"></a>9.4.形参和实参</h3><p>形参：就是形式参数的意思。是在定义方法名的时候使用的参数，用来标识方法接收的参数类型，在调用该方法时传入。</p><p>实参：就是实际参数的意思。是在调用方法时传递给该方法的实际参数。</p><p>比如：上面的例子中“int oil”就是个形式参数，这里只是表示需要加入汽油，这个方法才能正常运行，但具体加入多少，要到真正使用的时候，也就是调用这个方法的时候才具体确定，加入调用的时候传入“80” ，这就是个实际参数。</p><p>形参和实参有如下基本规则：</p><p>(1)：形参和实参的类型必须要一致，或者要符合隐含转换规则</p><p>(2)：形参类型不是引用类型时，在调用该方法时，是按值传递的。在该方法运行时，形参和实参是不同的变量，它们在内存中位于不同的位置，形参将实参的值复制一份，在该方法运行结束的时候形参被释放，而实参内容不会改变。</p><p>(3)：形参类型是引用类型时，在调用该方法时，是按引用传递的。运行时，传给方法的是实参的地址， 在方法体内部使用的也是实参的地址， 即使用的就是实参本身对应的内存空间。所以在函数体内部可以改变实参的值。</p><h3 id="9-5-参数可变的方法"><a href="#9-5-参数可变的方法" class="headerlink" title="9.5.参数可变的方法"></a>9.5.参数可变的方法</h3><p>从 JDK5.0 开始，提供了参数可变的方法。</p><p>当不能确定一个方法的入口参数的个数时，5.0 以前版本的 Java 中，通常的做法是将多个参数放在一个数组或者对象集合中作为参数来传递，5.0 版本以前的写法是：</p><p>int sum(Integer[] numbers){…}</p><p>//在别处调用该方法</p><p>sum(new Integer[] {12,13,20});</p><p>而在 5.0 版本中可以写为：</p><p>int sum(Integer… numbers){//方法内的操作}</p><p>注意：方法定义中是三个点</p><p>//在别处调用该方法</p><p>sum(12,13,20);//正确</p><p>sum(10,11); //正确</p><p>也就是说，传入参数的个数并不确定。但请注意：传入参数的类型必须是一致的，究其本质，就是一个数组。</p><p>显然，JDK5.0 版本的写法更为简易，也更为直观，尤其是方法的调用语句，不仅简化很多，而且更符合通常的思维方式，更易于理解。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java二级公共基础知识资料</title>
    <link href="http://yoursite.com/2019/08/26/Java%E4%BA%8C%E7%BA%A7%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%B5%84%E6%96%99/"/>
    <id>http://yoursite.com/2019/08/26/Java二级公共基础知识资料/</id>
    <published>2019-08-26T13:40:57.514Z</published>
    <updated>2019-08-26T13:42:28.416Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>第一章</strong>  <strong>数据结构与算法</strong></p><p><strong>【考点1**</strong>】算法的基本概念**</p><p>1、算法：是指一组有穷的指令集，是解题方案的准确而完整的描述。算法不等于程序，也不等于计算方法。</p><p>2、算法的基本特征：</p><p>1）确定性，算法中每一步骤都必须有明确定义，不允许有多义性；</p><p>2）有穷性，算法必须能在有限的时间内做完，即能在执行有限个步骤后终止；</p><p>3）可行性，算法原则上能够精确地执行；</p><p>4）拥有足够的情报。</p><p>3、算法的组成要素：一个算法由数据对象的运算和操作以及其控制结构这两部分组成。</p><p>4、算法的基本运算和操作：算术运算，逻辑运算，关系运算，数据传输。</p><p>5、算法的基本控制结构：顺序，选择，循环。</p><p>6、算法基本设计方法：列举法、归纳法、递推、递归、减半递推技术。</p><p><strong>【考点2**</strong>】算法的复杂度**</p><p>1、算法效率的度量——算法的复杂度：时间复杂度和空间复杂度。</p><p>1）算法时间复杂度：指执行算法所需要的计算工作量。通常，一个算法所用的时间包括编译时间和运行时间。</p><p>2）算法空间复杂度：指执行这个算法所需要的内存空间。包括算法程序所占的空间，输入的初始数据所占的空间，算法执行过程中所需的额外空间。</p><p>空间复杂度和时间复杂度并不相关。</p><p><strong>【考点3**</strong>】数据结构的基本概念**</p><p>数据：数据是客观事物的符号表示，是能输入到计算机中并被计算程序识别和处理的符号的总称，如文档，声音，视频等。</p><p>数据元素：数据元素是数据的基本单位。</p><p>数据对象：数据对象是性质相同的数据元素的集合。</p><p>数据结构：是指由某一数据对象中所有数据成员之间的关系组成的集合。</p><p><strong>【考点4**</strong>】逻辑结构和存储结构**</p><p>1、数据结构可分为数据的逻辑结构和存储结构。</p><p>1）数据的逻辑结构是对数据元素之间的逻辑关系的描述，与数据的存储无关，是面向问题的，是独立于计算机的。它包括数据对象和数据对象之间的关系。</p><p>2）数据的存储结构也称为数据的物理结构，是数据在计算机中的存放的方式，是面向计算机的，它包括数据元素的存储方式和关系的存储方式。</p><p>2、存储结构和逻辑结构的关系：一种数据的逻辑结构可以表示成多种存储结构即数据的逻辑结构和存储结构不一定一一对应。</p><p>3、常见的存储结构有：顺序，链接，索引等。采用不同的存储结构其数据处理的效率是不同的。</p><p><strong>【考点5**</strong>】线性结构和非线性结构**</p><p>1、线性结构的条件（一个非空数据结构)：（1）有且只有一个根结点；（2）每一个结点最多有一个前件，也最多有一个后件。</p><p>2、非线性结构：不满足线性结构条件的数据结构。</p><p>栈、队列、双向链表是线性结构，树、二叉树为非线性结构。</p><p><strong>【考点6**</strong>】线性表及其顺序存储结构**</p><p>1、线性表是由一组数据元素构成，数据元素的位置只取决于自己的序号，元素之间的相对位置是线性的。</p><p>2、在复杂线性表中，由若干项数据元素组成的数据元素称为记录；由多个记录构成的线性表称为文件。</p><p>3、非空线性表的结构特征：</p><p>（1）有且只有一个根结点a1，它无前件；</p><p>（2）有且只有一个终端结点an，它无后件；</p><p>（3）除根结点与终端结点外，其他所有结点有且只有一个前件，也有且只有一个后件。</p><p>结点个数n称为线性表的长度，当n=0时，称为空表。</p><p>4、线性表的顺序存储结构具有以下两个基本特点：</p><p>（1）线性表中所有元素所占的存储空间是连续的；</p><p>（2）线性表中各数据元素在存储空间中是按逻辑顺序依次存放的。</p><p>元素ai的存储地址为：ADR(ai)=ADR(a1)+(i-1)*k，ADR(a1)为第一个元素的地址，k代表每个元素占的字节数。</p><p>5、顺序表的运算：查找、插入、删除。</p><p><strong>【考点7**</strong>】线性链表**</p><p>线性链表是线性表的链式存储结构，数据结构中的每一个结点对应于一个存储单元，这种存储单元称为存储结点，简称结点。结点由两部分组成：(1) 用于存储数据元素值，称为数据域；(2) 用于存放指针，称为指针域，用于指向前一个或后一个结点。</p><p>在链式存储结构中，存储数据结构的存储空间可以不连续，各数据结点的存储顺序与数据元素之间的逻辑关系可以不一致，而数据元素之间的逻辑关系是由指针域来确定的。</p><p>链式存储方式既可用于表示线性结构，也可用于表示非线性结构。</p><p>线性单链表中，HEAD称为头指针，HEAD=NULL（或0）称为空表。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p><p>双向链表有两个指针：左指针（Llink）指向前件结点，右指针（Rlink）指向后件结点。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img"></p><p>循环链表：循环链表与单链表的不同的是它的最后一个结点的指针域存放的事指向第一个结点的指针而单链表存放的是空指针。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png" alt="img"></p><p>线性链表的基本运算：查找、插入、删除。</p><p><strong>【考点8**</strong>】栈**</p><p>1、栈的基本概念</p><p>栈是一种特殊的线性表，只允许在表的一端进行插入和删除的线性表；插入，删除的一端为栈顶，另一端为栈底；当表中没有元素时为空栈。</p><p>栈是一种后进先出（或先进后出Last In First Out）的线性表。栈具有记忆功能。栈的实例：火车调度，子弹夹。</p><p>2、栈的存储结构</p><p>顺序存储结构：用一组地址连续的存储单元即一维数组来存储；</p><p>链式存储：用线性链表来存储；</p><p>3、栈的基本运算</p><p>(1) 入栈运算，在栈顶位置插入元素；</p><p>(2) 退栈运算，删除元素(取出栈顶元素并赋给一个指定的变量)；</p><p>(3) 读栈顶元素，将栈顶元素赋给一个指定的变量，此时指针无变化。</p><p><strong>【考点9**</strong>】队列**</p><p>1.队列的基本概念</p><p>队列是一种特殊的线性表，只允许在表的一端插入，在另一端删除，允许插入的一端是队尾（rear），允许删除的一端为队头（front）；当表中没有元素是空队列；队列是一种先进先出的线性表。(FIFO)</p><p>2、队列的存储结构</p><p>顺序存储：一维数组。</p><p>链式存储：线性链表。</p><p>3、队列的运算: </p><p>(1) 入队运算：从队尾插入一个元素；  (2) 退队运算：从队头删除一个元素。</p><p>4、队列的顺序存储结构一般采用循环队列的形式。循环队列s=0表示队列为空；s=1且front=rear表示队满。</p><p>5、计算循环队列的元素个数：“尾指针减头指针”，若为负数，再加其容量即可。</p><p><strong>【考点10**</strong>】树的基本概念**</p><p>树是一种非线性结构，是n个结点的有限集。当n=0 时为空树，n&gt;0时为非空树。结点的度：结点所拥有的子树的个数。</p><p>叶子结点：度为0的结点。</p><p>分支结点：除叶子结点以外的结点。</p><p>结点的层次：根结点在第一层，同一层上左右结点的子结点在下一层。</p><p>树的深度：所处层次最大的那个结点的层次。</p><p>树的度：树中所有结点的度的最大值。</p><p><strong>【考点11**</strong>】二叉树及其基本性质**</p><p>1、二叉树的概念</p><p>二叉树是一种特殊的树形结构，每个结点最多只有两棵子树，且有左右之分不能互换，因此，二叉树有五种不同的形态。</p><p>2、二叉树的性质</p><p>性质1 在二叉树的第k层上，最多有2k-1(k≥1）个结点。</p><p>性质2 深度为m的二叉树最多有2m-1个结点。</p><p>性质3 在任意一棵二叉树中，度为0的结点（叶子结点）总是比度为2的结点多一个。</p><p>性质4 具有n个结点的二叉树，其深度不小于[log2n]+1,其中[log2n]表示为log2n的整数部分。</p><p><strong>【考点12**</strong>】满二叉树与完全二叉树**</p><p>满二叉树：除最后一层外，每一层上的所有结点都有两个子结点。在满二叉树中，每一层上的结点数都达到最大值，即在满二叉树的第k层上有2k-1个结点，且深度为m的满二叉树有2m－1个结点。</p><p>完全二叉树是指这样的二叉树：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</p><p>满二叉树是完全二叉树，而完全二叉树一般不是满二叉树。</p><p><strong>【考点13**</strong>】完全二叉树的性质**</p><p>性质1 具有n个结点的完全二叉树的深度为[log2n]+1。</p><p>性质2 完全二叉树中度为1的结点数为0或1。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img"><strong>【考点14**</strong>】二叉树的遍历**</p><p>1、前序遍历：先访问根结点、然后遍历左子树，最后遍历右子树；并且，在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>前序遍历图5可得：ABCDFHEG。</p><p>2、中序遍历：先遍历左子树、然后访问根结点，最后遍历右子树；并且，在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树。</p><p>中序遍历图5可得：BAFHDCGE。</p><p>3、后序遍历：先遍历左子树、然后遍历右子树，最后访问根结点；并且，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后访问根结点。</p><p>后序遍历图5可得：BHFDGECA。</p><p><strong>【考点15**</strong>】顺序查找**</p><p>顺序查找是从表的一端开始，依次扫描表中的各个元素，并与所要查找的数进行比较。</p><p>在下列两种情况下也只能采用顺序查找： </p><p>（1）如果线性表为无序表，则不管是顺序存储结构还是链式存储结构，只能用顺序查找。 </p><p>（2）即使是有序线性表，如果采用链式存储结构，也只能用顺序查找。</p><p><strong>【考点16**</strong>】二分查找**</p><p>二分查找的条件：（1）用顺序存储结构   (2)线性表是有序表。</p><p>对于长度为n的有序线性表，在最坏情况下，二分法查找只需比较log2n次，而顺序查找需要比较n次。</p><p><strong>【考点17**</strong>】排序**</p><p>1、交换排序</p><p>（1）冒泡排序法，在最坏的情况下，冒泡排序需要比较次数为n(n－1)/2。 </p><p>（2）快速排序法 ，在最坏的情况下，快速排序需要比较次数为n(n－1)/2。</p><p>2、插入类排序法：</p><p>（1）简单插入排序法，最坏情况需要n(n-1)/2次比较；</p><p>（2）希尔排序法，最坏情况需要O(n1.5)次比较。（大写O是算法复杂度的表示方法）</p><p>3、选择类排序法：</p><p>（1）简单选择排序法，最坏情况需要n(n-1)/2次比较；</p><p>（2）堆排序法，最坏情况需要O(nlog2n)次比较。</p><p>相比以上几种(除希尔排序法外)，堆排序法的时间复杂度最小。</p><p><strong>第二章</strong>  <strong>程序设计基础</strong></p><p><strong>【考点1**</strong>】程序设计方法与风格**</p><p>形成良好的程序设计风格需注意： </p><p>1、源程序文档化； 2、数据说明的方法； 3、语句的结构；  4、输入和输出。</p><p><strong>【考点2**</strong>】结构化程序设计方法的四条原则**</p><p>1、自顶向下； 2、逐步求精； 3、模块化； 4、限制使用goto语句。</p><p><strong>【考点3**</strong>】结构化程序的基本结构**</p><p>顺序结构：是最基本、最普通的结构形式，按照程序中的语句行的先后顺序逐条执行。</p><p>选择结构：又称为分支结构，它包括简单选择和多分支选择结构。</p><p>循环结构：根据给定的条件，判断是否要重复执行某一相同的或类似的程序段。循环结构对应两类循环语句：先判断后执行的循环体称为当型循环结构；先执行循环体后判断的称为直到型循环结构。</p><p><strong>【考点4**</strong>】面向对象的程序设计及面向对象方法的优点**</p><p>面向对象的程序设计以对象为核心，强调对象的抽象性，封装性，继承性和多态性。</p><p>面向对象方法的优点</p><p>（1）人类习惯的思维方法一致； （2）稳定性好； （3）可重用性好；</p><p>（4）易于开发大型软件产品；   （5）可维护性好。</p><p><strong>【考点5**</strong>】对象及其特点**</p><p>对象（object）：面向对象方法中最基本的概念，可以用来表示客观世界中的任何实体，对象是实体的抽象。</p><p>对象的基本特点：</p><p>（1）标识惟一性； （2）分类性； （3）多态性； （4）封装性； （5）模块独立性好。</p><p><strong>【考点6**</strong>】属性，类和实例**</p><p>属性：即对象所包含的信息，它在设计对象时确定，一般只能通过执行对象的操作来改变。</p><p>类：是具有相似属性与操作的一组对象。类是关于对象性质的描述。类是对象的抽象，对象是其对应类的一个实例。</p><p><strong>【考点7**</strong>】消息及其组成**</p><p>消息：是一个实例与另一个实例之间传递的信息。对象间的通信靠消息传递。它请求对象执行某一处理或回答某一要求的信息，它统一了数据流和控制流。</p><p>消息的组成包括：</p><p>(1)接收消息的对象的名称； （2）消息标识符，也称消息名； （3）零个或多个参数。</p><p><strong>【考点8**</strong>】继承和多态**</p><p>1、继承：是使用已有的类定义作为基础建立新类的定义技术，广义指能够直接获得已有的性质和特征，而不必重复定义他们。</p><p>2、继承具有传递性，一个类实际上继承了它上层的全部基类的特性。</p><p>3、继承分单继承和多重继承。单继承指一个类只允许有一个父类，即类等级为树形结构；多重继承指一个类允许有多个父类。</p><p>4、多态性：是指同样的消息被不同的对象接受时可导致完全不同的行动的现象。</p><p><strong>第三章</strong>  <strong>软件工程基础</strong></p><p><strong>【考点1**</strong>】软件定义与软件特点**</p><p>软件指的是计算机系统中与硬件相互依存的另一部分，包括程序、数据和相关文档的完整集合。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>程序</td><td>软件开发人员根据用户需求开发的、用程序设计语言描述的、适合计算机执行的指令序列</td></tr><tr><td>数据</td><td>使程序能正常操纵信息的数据结构</td></tr><tr><td>文档</td><td>与程序的开发、维护和使用有关的图文资料</td></tr></tbody></table><p>1、软件的特点：</p><p>1）软件是一种逻辑实体，具有抽象性；</p><p>2）软件的生产与硬件不同，它没有明显的制作过程；</p><p>3）软件在运行、使用期间不存在磨损、老化问题；</p><p>4）软件的开发、运行对计算机系统具有依赖性，受计算机系统的限制，这导致了软件移植的问题；</p><p>5）软件复杂性高，成本昂贵；</p><p>6）软件开发涉及诸多的社会因素。</p><p>2、根据应用目标的不同，软件可分应用软件、系统软件和支撑软件（或工具软件）。 </p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>应用软件</td><td>为解决特定领域的应用而开发的软件，如办公自动化软件</td></tr><tr><td>系统软件</td><td>计算机管理自身资源，提高计算机使用效率并为计算机用户提供各种服务的软件，如操作系统</td></tr><tr><td>支撑软件（或工具软件）</td><td>支撑软件是介于两者之间，协助用户开发软件的工具性软件。</td></tr></tbody></table><p><strong>【考点2**</strong>】软件的生命周期**</p><p>软件生命周期是指软件产品从提出、实现、使用维护到停止使用退役的整个过程。可分为软件定义，软件开发及软件维护3个阶段。软件生命周期中，能够准确确定软件系统必须做什么和必须具备哪些功能的阶段是：需求分析。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png" alt="img">                  </p><p>定义阶段                    开发阶段                       维护阶段</p><p><strong>【考点3**</strong>】软件危机和软件工程的概念**</p><p>软件危机泛指在计算机软件的开发和维护过程中遇到的一系列严重的问题，集中表现在成本，质量。生产效率等几个方面。</p><p>所谓软件工程是指采用工程的概念、原理、技术和方法指导软件的开发与维护。是建立并使用完善的工程化原则，以较经济的手段获得，能在实际机器上有效运行的可靠软件的一系列方法；软件工程的主要思想强调在软件开发过程中需要应用工程化原则。软件工程的核心思想是把软件当作一个工程产品来处理。</p><p>软件工程包括3个要素：方法，工具和过程</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>方法</td><td>方法是完成软件工程项目的技术手段</td></tr><tr><td>工具</td><td>工具支持软件的开发、管理、文档生成</td></tr><tr><td>过程</td><td>过程支持软件开发的各个环节的控制、管理</td></tr></tbody></table><p><strong>【考点4**</strong>】软件工程过程**</p><p>软件工程过程是把软件转化为输出的一组彼此相关的资源活动，包含4种基本活动：</p><p>（1）P(plan)——软件规格说明；   （2）D(do)——软件开发；</p><p>（3）C(check)——软件确认；      （4）A(action)——软件演进。</p><p><strong>【考点5**</strong>】软件开发技术和软件工程管理**</p><p>1、软件工程的理论和技术性研究的内容主要包括软件开发技术和软件工程管理。</p><p>2、软件开发技术包括软件开发方法学、开发过程、开发工具和软件工程环境，其主体内容是软件开发方法学。</p><p>3、软件开发方法包括分析方法，设计方法和程序设计方法。</p><p>4、软件工程管理包括软件管理学，软件工程经济学，软件心理学等。</p><p>5、软件管理学包括人员组织，进度安排，质量保证，配置管理，项目计划等。</p><p>6、软件工程经济学是研究软件开发中成本的估算，成本效益的方法和技术。</p><p><strong>【考点6**</strong>】软件工程的原则**</p><p>软件工程的原则：抽象，信息隐蔽，模块化，局部化，确定性，一致性，完备性，可验证性。</p><p><strong>【考点7**</strong>】需求分析概述**</p><p>需求分析阶段的工作：需求获取，需求分析，编写需求规格说明书，需求评审。</p><p>需求分析方法有：</p><p>（1）结构化需求分析方法； </p><p>①面向数据结构的Jackson方法（ISD）；</p><p>②面向数据流的结构化分析方法（SA）；</p><p>③面向数据结构的结构化数据系统开发方法（DSSD）；</p><p>（2）面向对象的分析的方法（OOA）。</p><p>从需求分析建立的模型的特性来分：静态分析和动态分析。</p><p><strong>【考点8**</strong>】结构化方法和结构化分析方法**</p><p>1、结构化方法包括结构化分析方法，结构化设计方法，结构化编程方法。</p><p>结构化方法中，软件功能分解属于总体设计阶段。</p><p>2、结构化分析方法的概念</p><p>结构化分析方法是面向数据流自顶而下逐步求精进行需求分析的方法。</p><p>结构化分析方法在软件需求分析阶段的应用。</p><p>3、结构化分析的常用工具</p><p>（1）数据流图（DFD-Data Flow Diagram）：是结构化分析方法中用于系统逻辑模型的一种工具。它以图形的方式描绘在系统中流动和处理的过程。</p><p>数据流图中四种基本的符号。</p><p>1）箭头：表示数据流，数据流是数据在系统中传播的路径。</p><p>2）圆或椭圆：表示加工，加工又称为数据处理，是对数据流进行某些操作或变换。</p><p>3）双横：表示数据存储（数据源）。数据存储又称为文件，指暂时保存的数据，它可以是数据库文件或任何形式的数据组织。</p><p>4）方框：数据的源点或终点。它是软件系统外部环境中的实体，统称外部实体</p><p>（2）数据字典（DD）：它是结构分析方法的核心，是用来描述系统中所用到的全部数据和文件的文档,作用是对DFD中出现的被命名的图形元素进行确切解释。</p><p>​    数据字典由以下4类元素组成</p><p>1）数据流  2）数据流分量 3）数据存储 4）处理 </p><p>（3）判定树（决策树）：是一种描述加工的图形工具，适合描述时候处理中具有多个判断，而且每个决策与若干条件有关。</p><p>（4）判定表：与判定树类似，也是一种描述加工的图形工具。如果一个加工逻辑有多个条件、多个操作，并且在不同的条件组合下执行不同的操作，那么可以使用判定表来描述。</p><p><strong>【考点9**</strong>】软件需求规格说明书**</p><p>软件需求规格说明书（SRS，Software Requirement Specification）是需求分析阶段得出的最主要的文档。软件需求规格说明书的特点：有正确性、无歧义性、完整性、可验证性、一致性、可理解性、可修改性和可追踪性。其中最重要的是无歧义性。</p><p><strong>【考点10**</strong>】软件设计的基本概念**</p><p>软件设计是确定系统的物理模型。</p><p>软件设计是开发阶段最重要的步骤，是将需求准确地转化为完整的软件产品或系统的唯一途径。</p><p>从技术观点上看，软件设计包括软件结构设计、数据设计、接口设计、过程设计。</p><p>（1）结构设计定义软件系统各主要部件之间的关系； </p><p>（2）数据设计将分析时创建的模型转化为数据结构的定义； </p><p>（3）接口设计是描述软件内部、软件和协作系统之间以及软件与人之间如何通信； </p><p>（4）过程设计则是把系统结构部件转换为软件的过程性描述。</p><p>从工程管理角度来看，软件设计分两步完成：概要设计和详细设计。</p><p>（1）概要设计将软件需求转化为软件体系结构、确定系统级接口、全局数据结构或数据库模式； </p><p>（2）详细设计确立每个模块的实现算法和局部数据结构，用适当方法表示算法和数据结构的细节。</p><p><strong>【考点11**</strong>】软件设计的基本原理**</p><p>1、软件设计中应该遵循的基本原理和与软件设计有关的概念：</p><p>模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能。</p><p>抽象化：抽出事物的本质特性而暂时不考虑它们的细节。</p><p>信息隐藏和局部化：信息隐蔽是指在一个模块内包含的信息（过程或数据），对于不需要这些信息的其他模块来说是不能访问的，实现信息隐蔽依靠对象的封装。</p><p>模块独立性：模块独立性是指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少且接口简单。模块的独立程度是评价设计好坏的重要度量标准。</p><p><strong>【考点12**</strong>】耦合性和内聚性**</p><p>衡量软件的模块独立性是用耦合性和内聚性两个定性的度量标准。</p><p>耦合性：是对一个软件结构内不同模块之间互联程度的度量。耦合性的强弱取决于模块间接口的复杂程度。</p><p>内聚性：是一个模块内部各个元素间彼此结合的紧密程度的度量。</p><p>一个模块的内聚性越强则该模块的模块独立性越强。一个模块与其他模块的耦合性越强则该模块的模块独立性越弱。</p><p>在结构程序设计中，模块划分的原则是模块内具有高内聚度，模块间具有低耦合度。</p><p>耦合和内聚的种类。</p><p>耦合度由低到高：非直接耦合，数据耦合，标记耦合，控制耦合，外部耦合，公共耦合，内容耦合。</p><p>内聚性由强到弱：功能内聚，顺序内聚，通信内聚，过程内聚，时间内聚，逻辑内聚，偶然内聚。</p><p><strong>【考点13**</strong>】结构化设计方法**</p><p>结构化分析方法是面向数据流自顶而下，逐步求精进行需求分析的方法，基本思想将软件设计成由相对独立，单一功能的模块组成的结构，与结构分析方法衔接使用，以数据流图为基础得到软件的模块结构，适用于变换型结构和事物型结构的目标系统。</p><p>1、概要设计的任务：（1）划分出组成系统的物理元素  （2）设计软件的结构</p><p>2、概要设计的工具：</p><p>结构图（SC-Structure Chart）也称程序结构图，在结构图中，模块用一个矩形表示，箭头表示模块间的调用关系。可以用带注释的箭头表示模块调用过程中来回传递的信息。还可用带实心圆的箭头表示传递的是控制信息，空心圆箭心表示传递的是数据。</p><p>结构图的基本形式：基本形式、顺序形式、重复形式、选择形式。</p><p>结构图有四种模块类型：传入模块、传出模块、变换模块和协调模块。</p><p>程序结构图中的专业术语：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>深度</td><td>表示控制的层数</td></tr><tr><td>上级模块，从属模块</td><td>上，下两层模块a和b，且有a调用b，则a是上级模块，b是从属模块</td></tr><tr><td>宽度</td><td>整体控制跨度（最大模块的层）的表示</td></tr><tr><td>扇入</td><td>调用该模块的模块个数</td></tr><tr><td>扇出</td><td>一个模块直接调用的其他模块数</td></tr><tr><td>原子模块</td><td>树中位于叶子节点的模块</td></tr></tbody></table><p>3、面向数据流的设计方法</p><p>任何软件系统都可以用数据流图表示，典型的数据流类型有两种：变换型和事务型。</p><p>变换型系统结构图由输入、中心变换、输出三部分组成。</p><p>4、设计的准则</p><p>（1）提高模块独立性。</p><p>（2）模块规模适中。</p><p>（3）深度，宽度，扇出和扇入适当。如果深度过大，则说明有的控制模块可能简单了，如果宽度过大，则说明系统的控制过于集中，扇出过大说明模块过分复杂，需要控制和协调过多的下级模块，应适当加中间层次，扇出过小可以把模块进一步分解成若干小模块，或合并到上级模块中，扇入越大则共享该模块的上级数目越多。好的软件设计结构通常顶层高扇出，中间扇出较少，底层高扇入。</p><p>（4）使模块的作用域在该模块的控制域内。</p><p>（5）减少模块的接口和界面的复杂性。</p><p>（6）设计成单入口，单出口的模块。</p><p>（7）设计功能可预测的模块。</p><p>详细设计常用的设计工具（工程设计工具）：图形工具，表格工具和语言工具。</p><p>图形工具：</p><p>程序流程图：箭头表示控制流，方框表示加工步骤，菱形表示逻辑条件。</p><p>N-S图：有五种基本图形。</p><p>PAD图：问题分析图，有五种基本图型。</p><p>表格工具：判定表。</p><p>语言工具：PDL——过程设计语言（结构化的英语和伪码）。</p><p><strong>【考点14**</strong>】软件测试的目标和准则**</p><p>软件测试的目标：发现程序中的错误。</p><p>软件测试的准则：</p><p>（1）所有测试都是应追溯到需求。</p><p>（2）严格执行测试计划，排除测试的随意性。</p><p>（3）充分注意测试中的群集表现。程序中存在错误的概率与该程序中已发现的错误数成正比。</p><p>（4）程序员应避免检查自己的程序。</p><p>（5）穷举测试不可能。穷举测试是把程序所有可能的执行路径都进行检查，即使小规模的程序的执行路径数也相当大，不可能穷尽，说明测试只能证明程序有错，不能证明程序中无错。</p><p>（6）妥善保存测试计划，测试用例出错统计和最终分析报告。</p><p><strong>【考点15**</strong>】软件测试方法**</p><p>从是否需要执行被测软件的角度分为静态测试和动态测试;按功能分为白盒测试和黑盒测试</p><p>1、静态测试和动态测试</p><p>静态测试包括代码检查、静态结构分析、代码质量度量。不实际运行软件，主要通过人工进行。</p><p>动态测试是通过运行软件来检验软件中的动态行为和运行结果的正确性。动态测试的关键是使用设计高效、合理的测试用例。测试用例就是为测试设计的数据，由测试输入数据（输入值集）和预期的输出结果（输出值集）两部份组成。测试用例的设计方法一般分为两类：黑盒测试方法和白盒测试方法。</p><p>2、白盒测试和黑盒测试</p><p>（1）白盒测试 </p><p>白盒测试也称为结构测试或逻辑测试，是把程序看成装在一只透明的白盒子里，测试者完全了解程序的结构和处理过程。它根据程序的内部逻辑来设计测试用例，检查程序中的逻辑通路是否都按预定的要求正确地工作。</p><p>白盒测试的基本原则：</p><p>（1）保证所测模块中每一独立路径至少执行一次。</p><p>（2）保证所测模块所有判断的每一分支至少执行一次。</p><p>（3）保证所测模块每一循环都在边界条件和一般条件下至少各执行一次。</p><p>（4）验证所有内部数据结构的有效性。</p><p>（5）按照白盒测试的基本原则，“白盒”法是穷举路径测试。</p><p>白盒测试的方法：逻辑覆盖，基本路经测试。</p><p>（2）黑盒测试 </p><p>黑盒测试也称功能测试或数据驱动测试，是把程序看成一只黑盒子，测试者完全不了解，或不考虑程序的结构和处理过程。它根据规格说明书的功能来设计测试用例，检查程序的功能是否符合规格说明的要求。</p><p>黑盒测试的方法：等价划分法，边界值分析法，错误推测法。</p><p><strong>【考点16**</strong>】软件测试的实施**</p><p>软件测试过程分4个步骤，即单元测试、集成测试、验收测试和系统测试。</p><p>单元测试是对软件设计的最小单位——模块进行正确性检验的测试，单元测试的根据是源程序和详细设计说明书，单元测试的技术可以采用静态分析和动态测试。</p><p>单元测试期间对模块进行的测试：模块接口，局部数据结构，重要的执行通路，出错处理通路，边界条件。</p><p>驱动模块相当于被测模块的主程序，它接收测试数据，并传给所测模块，输出实际测试结果</p><p>桩模块通常用于代替被测模块调用的其他模块，其作用仅做少量的数据操作，是一个模拟子程序。</p><p>集成测试是测试和组装软件的系统化技术，主要目的是发现与接口有关的错误，集成测试的依据是概要设计说明书。</p><p>集成测试的方法：非增量方式组装和增量方法组装。</p><p>增量方式包括自顶而下的增量方式，自底而上的增量方式和混合增量方式。</p><p>确认测试的任务是验证软件的功能和性能，确认测试的实施首先运用黑盒测试方法，对软件进行有效性测试，即验证被测软件是否满足需求规格说明确认的标准。 </p><p>检查软件产品是否符合需求定义的过程是：确认测试。</p><p>系统测试是通过测试确认的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、支撑软件、数据和人员等其他系统元素组合在一起，在实际运行（使用）环境下对计算机系统进行一系列的集成测试和确认测试。</p><p>系统测试的具体实施一般包括：功能测试、性能测试、操作测试、配置测试、外部接口测试、安全性测试等。 </p><p><strong>【考点17**</strong>】程序调试**</p><p>在对程序进行了成功的测试之后将进入程序调试（通常称Debug，即排错）。</p><p>程序的调试任务是诊断和改正程序中的错误。</p><p>程序调试和软件测试的区别：</p><p>（1）软件测试是尽可能多地发现软件中的错误，而程序调试先要发现软件的错误，然后借助于一定的调试工具去执行找出软件错误的具体位置。</p><p>（2）软件测试贯穿整个软件生命期，调试主要在开发阶段。</p><p>程序调试的基本步骤：</p><p>（1）错误定位。从错误的外部表现形式入手，研究有关部分的程序，确定程序中出错位置，找出错误的内在原因；</p><p>（2）修改设计和代码，以排除错误； </p><p>（3）进行回归测试，防止引进新的错误。</p><p>软件调试可分为静态调试和动态调试。静态调试主要是指通过人的思维来分析源程序代码和排错，是主要的设计手段，而动态调试是辅助静态调试的。</p><p>主要的调试方法有：</p><p>（1）强行排错法； （2）回溯法； （3）原因排除法，包括演绎法，归纳法和二分法。</p><p><strong>第四章</strong>  <strong>数据库设计基础</strong></p><p><strong>【考点1**</strong>】数据库的基本概念**</p><p>数据（Data）是数据库存储的基本对象，是描述事物的符号记录。</p><p>数据库（DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合，它具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享，所以数据库技术的根本目标是解决数据共享问题。</p><p>数据库管理系统（DBMS）是数据库的管理机构，负责数据库中的数据组织、数据操纵、数据维护、控制及保护和数据服务等。数据库管理系统是数据库系统的核心。数据库系统包含数据库和数据库管理系统。</p><p>数据库管理系统的功能：</p><p>（1）数据模式定义：即为数据库构建其数据框架；</p><p>（2）数据存取的物理构建：为数据模式的物理存取与构建提供有效的存取方法与手段；</p><p>（3）数据操纵：为用户使用数据库的数据提供方便，如查询、插入、修改、删除等以及简单的算术运算及统计；</p><p>（4）数据的完整性、安全性定义与检查；</p><p>（5）数据库的并发控制与故障恢复；</p><p>（6）数据的服务：如拷贝、转存、重组、性能监测、分析等。</p><p>为完成数据库管理系统的功能，数据库管理系统提供相应的数据语言：</p><p>数据定义语言（DDL）：负责数据模式定义和数据物理存取构建。</p><p>数据操纵语言（DML）：负责数据的操纵。</p><p>数据控制语言（DCL）：负责数据完整性，安全性的定义与检查以及并发控制，故障恢复等功能。</p><p>数据语言按使用方式具有两个结构形式：交互式命令语言（自含型和自主型语言）和宿主型语言。</p><p>数据库管理员（DBA）的工作：数据库设计，数据库维护，改善系统性能，提高系统效率。</p><p>数据库系统（DBS）是指在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员和用户构成。</p><p>数据库应用系统（DBAS）是数据库系统再加上应用软件及应用界面这三者所组成，具体包括：数据库、数据库管理系统、数据库管理员、硬件平台、软件平台、应用软件、应用界面。</p><p><strong>【考点2**</strong>】数据管理的发展和基本特点**</p><p>数据管理技术的发展经历了三个阶段：人工管理阶段、文件系统阶段和数据库系统阶段，数据独立性最高的阶段是数据库系统阶段。</p><p>人工管理阶段特点：（1）计算机系统不提供对用户数据的管理功能（2）数据不能共享（3）不单独保存数据。</p><p>文件系统阶段的缺陷：（1）数据冗余（2）不一致性（3）数据联系弱。</p><p>数据库系统的发展阶段：第一代的网状、层次数据库系统；第二代的关系数据库系统；第三代的以面向对象模型为主要特征的数据库系统。</p><p>数据库系统的基本特点：</p><p>（1）数据的高集成性 （2）数据的高共享性和低冗余性 （3）数据高独立性 （4）数据统一管理与控制。</p><p>数据独立性是数据与程序间的互不依赖性，即数据库中的数据独立于应用程序而不依赖于应用程序。 </p><p>数据的独立性一般分为物理独立性与逻辑独立性两种。 </p><p>（1）物理独立性：当数据的物理结构（包括存储结构、存取方式等）改变时，其逻辑结构，应用程序都不用改变。 </p><p>（2）逻辑独立性：数据的逻辑结构改变了，如修改数据模式、增加新的数据类型、改变数据间联系等，用户的应用程序可以不变。</p><p><strong>【考点3**</strong>】数据系统的内部结构体系**</p><p>1、数据统系统的三级模式：</p><p>（1）概念模式，也称逻辑模式，是对数据库系统中全局数据逻辑结构的描述，是全体用户公共数据视图。一个数据库只有一个概念模式。 </p><p>（2）外模式，外模式也称子模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，一个概念模式可以有若干个外模式。 </p><p>（3）内模式，内模式又称物理模式，它给出了数据库物理存储结构与物理存取方法。一个数据库只有一个内模式。 </p><p>内模式处于最底层，它反映了数据在计算机物理结构中的实际存储形式，概念模式处于中间层，它反映了设计者的数据全局逻辑要求，而外模式处于最外层，它反映了用户对数据的要求。</p><p>2、数据库系统的两级映射 （详见教材第55页）</p><p>两级映射保证了数据库系统中数据的独立性。 </p><p>（1）概念模式到内模式的映射。该映射给出了概念模式中数据的全局逻辑结构到数据的物理存储结构间的对应关系；</p><p>（2）外模式到概念模式的映射。概念模式是一个全局模式而外模式是用户的局部模式。一个概念模式中可以定义多个外模式，而每个外模式是概念模式的一个基本视图。</p><p><strong>【考点4**</strong>】数据模型的基本概念**</p><p>数据模型按不同的应用层次分为：</p><p>概念数据模型：简称概念模型，是一种面向客观世界，面向用户的模型，不涉及具体的硬件环境和平台也与具体的软件环境无关的模式，它是整个数据模型的基础。</p><p>逻辑数据模型：又称数据模型，它是一种面向数据库的模型。分为层次模型，网状模型，关系模型和面向对象模型，其中层次模型和网状模型统称为非关系模型。层次模型用树型结构表示实体之间联系的模型。</p><p>物理数据模型：又称物理模型，它是一种面向计算机物理表示的模型。</p><p><strong>【考点5**</strong>】E<strong><strong>—R</strong></strong>模型**</p><p>1、E-R模型的基本概念 </p><p>（1）实体：现实世界中的事物可以抽象成为实体，实体是概念世界中的基本单位，它们是客观存在的且又能相互区别的事物。</p><p>（2）属性：现实世界中事物均有一些特性，这些特性可以用属性来表示。</p><p>（3）码：唯一标识实体的属性集称为码。</p><p>（4）域：属性的取值范围称为该属性的域。</p><p>（5）联系：在现实世界中事物间的关联称为联系。</p><p>两个实体集间的联系实际上是实体集间的函数关系，这种函数关系可以有下面几种：一对一的联系、一对多或多对一联系、多对多。</p><p>2、E-R模型的的图示法</p><p>E-R模型用E-R图来表示，E-R图包含了表示实体集、属性和联系的方法。</p><p>（1）实体的表示：用矩形表示实体集，在矩形内写上该实体集的名字。</p><p>（2）属性的表示：用椭圆形表示属性，在椭圆形内写上该属性的名称。</p><p>（3）联系的表示：用菱形表示联系，菱形内写上联系名。</p><p><strong>【考点6**</strong>】层次模型和网状模型**</p><p>层次模型是有根的定向有序树，是数据库系统中最早出现的数据模型。网状模型对应的是有向图。</p><p>层次模型和网状模型各自应满足的条件</p><table><thead><tr><th>模型名称</th><th>满足的条件</th></tr></thead><tbody><tr><td>层次模型</td><td>（1）有且只有一个结点没有双亲结点，这个结点称为根结点   （2）根以外的其他结点有且只有一个双亲结点</td></tr><tr><td>网状模型</td><td>（1）允许一个以上的结点无双亲   （2）一个结点可以有多于一个的双亲</td></tr></tbody></table><p><strong>【考点7**</strong>】关系模型及相关概念**</p><p>关系模式采用二维表来表示，由关系数据结构，关系操纵和关系完整性约束3部分组成，在关系数据库中，用来表示实体间联系的是关系。</p><p>关系：一个关系对应一张二维表。一个关系就是一个二维表，但是一个二维表不一定是一个关系。</p><p>元组：表中的一行即为一个元组。</p><p>属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名。</p><p>分量：元组中的一个属性值，是不可分割的基本数据项。</p><p>域：属性的取值范围。</p><p>在二维表中惟一标识元组的最小属性值称为该表的键或码。二维表中可能有若干个健，它们称为表的候选码或候选健。从二维表的所有候选键选取一个作为用户使用的键称为主键或主码。表A中的某属性集是某表B的键，则称该属性值为A的外键或外码。</p><p>关系操纵：数据查询、数据的删除、数据插入、数据修改。 </p><p>关系模型允许定义三类数据约束，它们是实体完整性约束、参照完整性约束以及用户定义的完整性约束。其中实体完整性约束、参照完整性约束必须满足的完整性约束条件。参照完整性约束不允许关系应用不存在的元组。实体完整性约束要求关系的主键中属性值不能为空，这是数据库完整性的最基本要求。</p><p><strong>【考点8**</strong>】关系代数**</p><p>关系代数是一种抽象的查询语言，关系代数的运算对象是关系，运算结果也是关系。运算对象，运算符和运算结果是运算的三大要素。集合运算符，专门的运算符，算术比较符和逻辑运算符。</p><p>关系模型的基本运算：（1）插入  （2）删除   (3)修改  （4）查询（包括投影、选择、笛卡尔积运算）还有扩充运算交、除、连接及自然连接运算。</p><p>关系代数的5个基本操作中并，差，交，笛卡尔积是二目运算。</p><p>设关系R和S具有相同的关系模式</p><p>1、并：R和S的并是由属于R或属于S的所有元组构成的集合。</p><p>2、差：R和S的差是由属于R但是不属于S的元组构成的集合</p><p>3、笛卡尔积：设R和S的元数分别为r和s，R和S的笛卡尔积是一个（r+s）元的元组集合，每个元组的前r个分量来自R的一个元组，后s个分量来自S的一个元组。运算后得到的新表的元组数是R*S，属性是r+s。</p><p>4、交：属于R又属于S的元组构成的集合。</p><p>5、投影：一元运算，对一个关系进行垂直切割，消去某些列，并重新按排列的顺序。</p><p>6、选择：一元运算，根据某些条件对关系进行水平分割。即选择符合条件的元组。</p><p>7、除：给定关系R（X，Y）和S（Y，Z），其中X，Y，Z是属性组，R中的Y和S中Y可以有不同的属性名，但必须出自相同的域集。</p><p>8、连接：也称θ连接运算，是一种二元运算，它的操作是从两个关系的笛卡尔积中选取属性间满足一定条件的元组，以合并成一个大关系。连接运算包括等值连接和不等值连接。连接运算后得到的新表的属性是运算前表中属性相加。即多于原来关系中属性的个数。</p><p>9、自然连接：自然连接满足的条件是（1）两关系间有公共域（2）通过公共域的相等值进行连接。</p><p><strong>【考点9**</strong>】数据库设计和管理**</p><p>数据库设计中有两种方法，面向数据的方法和面向过程的方法。</p><p>面向数据的方法是以信息需求为主，兼顾处理需求；面向过程的方法是以处理需求为主，兼顾信息需求。由于数据在系统中稳定性高，数据已成为系统的核心，因此面向数据的设计方法已成为主流。</p><p>数据库设计目前一般采用生命周期法，即将整个数据库应用系统的开发分解成目标独立的若干阶段。它们是：需求分析阶段、概念设计阶段、逻辑设计阶段、物理设计阶段。</p><p>一个低一级范式的关系模式，通过模式分解可以转化为若干个高一级范式的关系模式的集合，这种过程就叫规范化。</p><p>概念结构设计是将需求分析阶段得到的用户需求抽象为信息结构即概念模型的过程，它是整个数据库设计的关键。</p><p>逻辑结构设计的任务是将E—R图转换成关系数据模型的过程。</p><p>数据库的物理结构是指数据库在物理设备上的存储结构和存取方法。它依赖于给定的计算机系统。</p><p>常用的存取方法：索引方法，聚簇方法和HASH方法。</p><p>数据库管理的内容：</p><p>（1）数据库的建立，它是数据库管理的核心，包括数据模式的建立和数据加载。 </p><p>（2）数据库的重组。</p><p>（3）数据库安全性控制。</p><p>（4）数据库的完整性控制，数据库的完整性是指数据的正确性和相容性。</p><p>（5）数据库的故障恢复。</p><p>（6）数据库监控。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>人物模型</title>
    <link href="http://yoursite.com/2019/08/24/live2d%E4%BA%BA%E7%89%A9%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/08/24/live2d人物模型/</id>
    <published>2019-08-24T02:07:17.168Z</published>
    <updated>2019-09-01T11:37:37.871Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>1.站点配置文件下Git运行:npm install –save hexo-helper-live2d<br>2.站点配置文件写下（主题配置文件下不生效）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 添加萌妹子效果</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local  </span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko    //模型名字</span><br><span class="line">  display:    </span><br><span class="line">    position: right   //位置</span><br><span class="line">    width: 150    //妹子宽度</span><br><span class="line">    height: 300    //妹子高度</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></tbody></table></figure><p>更多模型：<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a><br>更换模型 npm install 模型名称</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>java文件输入输出流</title>
    <link href="http://yoursite.com/2019/08/23/%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/"/>
    <id>http://yoursite.com/2019/08/23/文件的读写/</id>
    <published>2019-08-23T05:37:52.750Z</published>
    <updated>2019-08-23T06:13:32.498Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><p>输入：<code>InputStream</code><br>read()方法：-1表示无</p></li><li><p>输出: <code>OutputStream</code><br>write()方法</p></li></ul><hr><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li>输入: <code>Reader</code></li><li>输出: <code>Writer</code></li></ul><hr><h3 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h3><ul><li>输入<code>FileInputStream</code></li><li>输出:<code>FileOutputStream</code></li></ul><hr><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>  输入：<code>BufferdReader</code><br>  输出：<code>BufferdWriter</code></p><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>  序列化：ObjectInputStream<br>  反序列化：ObjectOutputStream<br>  <span style="color: red">要求对象实现Serializable接口</span></p><hr><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p><img src="http://pwmvr65mz.bkt.clouddn.com/201908231353_863.png" alt="常用的操作"><br><img src="http://pwmvr65mz.bkt.clouddn.com/201908231355_407.png" alt="常用的处理流"></p><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>文件的操作要进行错误处理</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>实用推荐</title>
    <link href="http://yoursite.com/2019/08/23/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <id>http://yoursite.com/2019/08/23/网站推荐/</id>
    <published>2019-08-23T03:34:07.080Z</published>
    <updated>2019-09-07T05:17:58.959Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><ul><li>1.在线平面设计 <a href="https://www.fotor.com.cn" target="_blank" rel="noopener">https://www.fotor.com.cn</a></li><li>2.<a href="https://pixabay.com/zh/" target="_blank" rel="noopener">https://pixabay.com/zh/</a></li><li>3.<a href="https://www.pexels.com/zh-cn/" target="_blank" rel="noopener">https://www.pexels.com/zh-cn/</a><h3 id="小图标"><a href="#小图标" class="headerlink" title="小图标"></a>小图标</h3> <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">https://fontawesome.com/v4.7.0/icons/</a><h3 id="截图推荐"><a href="#截图推荐" class="headerlink" title="截图推荐"></a>截图推荐</h3> snipaste:能将图片贴在屏幕，很好地观察，快捷键：快速截屏F1,快速贴图F3,退出贴图shift+Esc。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows安装MySQL</title>
    <link href="http://yoursite.com/2019/08/23/Windows%20%E4%B8%8A%E5%AE%89%E8%A3%85%20MySQL/"/>
    <id>http://yoursite.com/2019/08/23/Windows 上安装 MySQL/</id>
    <published>2019-08-23T01:54:15.699Z</published>
    <updated>2019-08-23T02:38:58.899Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>1.下载<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">最新版本</a><br>2.<img src="http://pwmvr65mz.bkt.clouddn.com/201908231000_464.png" alt="如图"><br>3.<img src="http://pwmvr65mz.bkt.clouddn.com/201908231002_844.png" alt="如图"><br>4.安装MySQL<br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231020_317.png" alt="安装模式"><br> 更改地址<img src="http://pwmvr65mz.bkt.clouddn.com/201908231023_822.png" alt="更改地址"><br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231024_793.png" alt=""><br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231032_70.png" alt=""><br> 然后一点击下一步就可以<br>5.运行MySQL<img src="http://pwmvr65mz.bkt.clouddn.com/201908231035_680.png" alt="运行MySQL"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>七牛云截屏上传返回图片地址</title>
    <link href="http://yoursite.com/2019/08/22/%E4%B8%83%E7%89%9B%E4%BA%91%E6%88%AA%E5%B1%8F%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2019/08/22/七牛云截屏上传/</id>
    <published>2019-08-22T14:09:08.556Z</published>
    <updated>2019-08-22T14:24:49.691Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.到<a href="https://github.com/jiwenxing/qimage-win/releases" target="_blank" rel="noopener">github</a>下载release版本</p></li><li><p>2.打开release中的 <code>settings.ini</code> 文件</p></li><li><p>3.去七牛云找到密匙填写<img src="http://pwmvr65mz.bkt.clouddn.com/201908222218_401.png" alt="密匙"> </p></li><li><p>4.BUCKET_NAME：储存空间的名称</p></li><li><p>5BUCKET_DOMAIN：你自己的域名</p></li><li><p>6.UP_HOST = <a href="http://up-z2.qiniup.com" target="_blank" rel="noopener">http://up-z2.qiniup.com</a></p></li><li><p>7.DEBUG_MODE：调试开关，截屏上传失败可以把false改为true</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="markdown" scheme="http://yoursite.com/categories/markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>鼠标点击特效</title>
    <link href="http://yoursite.com/2019/08/21/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%86%E7%82%B8%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2019/08/21/鼠标点击爆炸效果/</id>
    <published>2019-08-21T08:53:07.782Z</published>
    <updated>2019-08-21T09:18:16.453Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.主题配置文件找 <code>layout</code> 文件夹中的 <code>_layout.swig</code>在body中加入</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{% if theme.fireworks %}</span><br><span class="line">   &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; </span><br><span class="line">   &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; </span><br><span class="line">   &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;</span><br><span class="line">  {% endif %}</span><br></pre></td></tr></tbody></table></figure></li><li><p>2.主题配置文件找<code>source</code> 文件夹中的 <code>js</code>新建src文件夹，在src新建fireworks.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)}"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)};</span><br></pre></td></tr></tbody></table></figure></li><li><p>3.主题配置文件末尾加入：</p><pre><code># Fireworksfireworks: true</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA面向对象（2)</title>
    <link href="http://yoursite.com/2019/08/21/java2/"/>
    <id>http://yoursite.com/2019/08/21/java2/</id>
    <published>2019-08-21T08:46:43.225Z</published>
    <updated>2019-08-23T06:15:47.820Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>类的组成：变量，方法，构造方法</li><li>构造方法：与类同名，不返回数字类型</li><li>方法<ul><li>实例方法</li><li>静态方法 </li><li>方法重载：该方法有多个名字但参数的个数和类型不同，可以用来实现<span style="color: red">多态</span></li></ul></li><li>变量：<ul><li>实例变量</li><li>静态变量</li></ul></li><li>类的对象：可以访问类中的方法</li><li>继承：<ul><li>声明 子类 extends 父类</li><li>继承父类的变量和方法</li><li>可以修改父类的变量和方法，还可以添加自己的变量和方法，名字相同就会进行覆盖和修改</li><li>关键字：this表示该类的对象</li><li>super：<span style="color: red">必须放在第一句</span>用于访问父类的变量和方法（一般用于同名），可用来调用父类的构造方法</li><li>父类对象和子类对象的转换（好像是上转型对象）</li></ul></li></ul><hr><h3 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h3><ul><li>import用于导入其他类，放在文件的首位</li><li>同包类可以相互访问,反之不得</li></ul><hr><h3 id="控制符"><a href="#控制符" class="headerlink" title="控制符"></a>控制符</h3><ul><li>static</li><li>final</li><li>abstract</li><li></li><li></li></ul><hr><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>  定义接口：interface<br>  实现接口：implements<br>  调用接口则接口中的所有方法必须重写<br>  可以实现多继承<br>  接口定义的常量具有final，static，public属性</p><hr><p><img src="http://pwmvr65mz.bkt.clouddn.com/201908231331_490.png" alt="完整的类定义"><br><img src="http://pwmvr65mz.bkt.clouddn.com/201908231333_501.png" alt="完整的接口定义"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA面向对象（1)</title>
    <link href="http://yoursite.com/2019/08/21/java1/"/>
    <id>http://yoursite.com/2019/08/21/java1/</id>
    <published>2019-08-21T07:34:17.216Z</published>
    <updated>2019-08-23T06:14:45.112Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>整数型<ul><li>进制的表示</li></ul></li><li>浮点数型<ul><li>注意单精度的书写要加f</li></ul></li><li>逻辑型—boolean</li><li>字符型—char</li><li>数据类型的转换</li></ul><hr><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>可以由数字，字母，下划线_,美元符号$组成</li><li>不能以数字开头</li><li>通常类名开头要大写（java大小写敏感）</li><li>其余的小写字母开头</li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组的创建<ul><li>数组的声明 <code>int []a;</code>(不能声明数组的长度)</li><li>为数组分配内存空间 <code>a=new[5]</code></li><li>数组的定义</li></ul></li><li>数组的引用类型<br><code>int []a=new int[5]</code><br>这里的a就是引用</li><li>数组默认初始化为0或者null</li><li>数组的遍历：</li><li>简单的循环语句</li><li>也可以用for(int age;age){}只读遍历</li><li>数组长度：数组名.length 可以获取</li><li>数组的复制：Array.Copy<br></li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>视频嵌入</title>
    <link href="http://yoursite.com/2019/08/20/%E8%A7%86%E9%A2%91/"/>
    <id>http://yoursite.com/2019/08/20/视频/</id>
    <published>2019-08-20T04:48:57.358Z</published>
    <updated>2019-08-20T07:00:02.285Z</updated>
    
    <content type="html"><![CDATA[<iframe width="100%" height="350" src="//player.bilibili.com/player.html?aid=62244859&amp;cid=108194807&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><a id="more"></a><hr><iframe width="100%" height="350" frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=k0029f52ciy" allowfullscreen="true"></iframe><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;iframe width=&quot;100%&quot; height=&quot;350&quot; src=&quot;//player.bilibili.com/player.html?aid=62244859&amp;amp;cid=108194807&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
    
    </summary>
    
      <category term="外接嵌入" scheme="http://yoursite.com/categories/%E5%A4%96%E6%8E%A5%E5%B5%8C%E5%85%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>pr</title>
    <link href="http://yoursite.com/2019/08/20/Pr/"/>
    <id>http://yoursite.com/2019/08/20/Pr/</id>
    <published>2019-08-20T02:50:43.636Z</published>
    <updated>2019-08-21T01:25:00.156Z</updated>
    
    <content type="html"><![CDATA[<hr><p>教程推荐 :<a href="https://www.bilibili.com/video/av5540953/?p=9" target="_blank" rel="noopener">https://www.bilibili.com/video/av5540953/?p=9</a></p><a id="more"></a><ul><li>画面放大缩小： 双击预览视频区</li><li>弹幕制作： 使用默认静态字幕<pre><code>弹幕效果：使用关键帧 -- 运动 设置关键帧的开始和结束位置（&lt;span style="color: red"&gt;记得打点&lt;/span&gt;）</code></pre></li><li>视频速度：右键更改速度比例(鬼畜)</li><li>视频的衔接：左侧工具栏找到 <span style="color: red">- 视频过度</span></li><li>视频结尾：使用关键帧 – 运动 设置关键帧的开始和结束位置（记得打点）</li><li>导出：<span style="color: red">h.264</span></li></ul><hr><ul><li>视频转场：<br>  1.全选素材<br>  2.Ctrl+d<br>  3.转场素材可去设置默认</li><li>批量缩放素材：<br>  找到首选项中的默认媒体缩放设置为<span style="color: red"> 帧大小</span></li><li>批量调色：<br>  1.效果控件将颜色复制在删掉<br>  2.找到只要进行粘贴</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;教程推荐 :&lt;a href=&quot;https://www.bilibili.com/video/av5540953/?p=9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av5540953/?p=9&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剪辑软件" scheme="http://yoursite.com/categories/%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>音乐载入</title>
    <link href="http://yoursite.com/2019/08/19/%E9%9F%B3%E4%B9%90/"/>
    <id>http://yoursite.com/2019/08/19/音乐/</id>
    <published>2019-08-19T13:56:09.136Z</published>
    <updated>2019-08-20T06:56:30.289Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&amp;id=2946604834&amp;auto=0&amp;height=430"></iframe><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="外接嵌入" scheme="http://yoursite.com/categories/%E5%A4%96%E6%8E%A5%E5%B5%8C%E5%85%A5/"/>
    
    
  </entry>
  
</feed>
