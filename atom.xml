<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陆陆陆啊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lufeifan.github.io/"/>
  <updated>2019-09-07T15:40:08.311Z</updated>
  <id>https://lufeifan.github.io/</id>
  
  <author>
    <name>陆陆陆啊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言指针</title>
    <link href="https://lufeifan.github.io/2019/09/07/%E6%8C%87%E9%92%88/"/>
    <id>https://lufeifan.github.io/2019/09/07/指针/</id>
    <published>2019-09-07T15:12:45.269Z</published>
    <updated>2019-09-07T15:40:08.311Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>本文转载自：<a href="https://blog.csdn.net/u012531536/article/details/80170893" target="_blank" rel="noopener">https://blog.csdn.net/u012531536/article/details/80170893</a></p><div class="post">            <h1 class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/tongye/p/9650573.html" target="_blank" rel="noopener">C语言--指针详解</a><div id="cnblogs_post_body" class="blogpost-body ">    <p>　　这段时间在看 Linux 内核，深觉 C 语言功底不扎实，很多代码都看不太懂，深入学习巩固 C 语言的知识很有必要。先从指针开始。</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>一、什么是指针</strong></span></p><p>　　C语言里，变量存放在内存中，而<strong>内存其实就是一组有序字节组成的数组</strong>，每个字节有唯一的内存地址。CPU 通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。也就是说：<strong>指针是一种保存变量地址的变量</strong>。</p><p>　　前面已经提到内存其实就是一组有序字节组成的数组，数组中，每个字节大大小固定，都是 8bit。对这些连续的字节从 0 开始进行编号，每个字节都有唯一的一个编号，这个编号就是内存地址。示意如下图：</p><p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918115659254-712651853.png" alt=""></p><p style="text-align: left;">　　这是一个 4GB 的内存，可以存放 2^32 个字节的数据。左侧的连续的十六进制编号就是内存地址，每个内存地址对应一个字节的内存空间。而指针变量保存的就是这个编号，也即内存地址。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>二、为什么要使用指针</strong></span></p><p>　　在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p><p>1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p><p>2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p><p>3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>三、如何声明一个指针</strong></span></p><p><span style="font-size: 18px; background-color: #ffffff;"><strong>3.1 声明并初始化一个指针</strong></span></p><p>　　指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p;        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 int 类型的指针 p</span><span style="color: #0000ff;">char</span> *p        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 char 类型的指针 p</span><span style="color: #0000ff;">int</span> *arr[<span style="color: #800080;">10</span>]   <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span><span style="color: #0000ff;">int</span> (*arr)[<span style="color: #800080;">10</span>] <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个数组指针，该指针指向一个 int 类型的一维数组</span><span style="color: #0000ff;">int</span> **p;       <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针 p ，该指针指向一个 int 类型的指针</span></pre></div><p>　　指针的声明比普通变量的声明多了一个一元运算符 “*”。运算符 “*” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。</p><p>　　声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre><span style="color: #008000;">/*</span><span style="color: #008000;"> 方法1：使指针指向现有的内存 </span><span style="color: #008000;">*/</span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span><span style="color: #000000;">;</span><span style="color: #0000ff;">int</span> *p = &amp;x;　　<span style="color: #008000;">//</span><span style="color: #008000;"> 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span>/ 方法2：动态分配内存给指针 <span style="color: #008000;">/int *p;p = (int *)malloc(sizeof(int) * 10);　　　　// malloc 函数用于动态分配内存free(p);　　　　// free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</p><p>&nbsp;</p><p><span style="background-color: #ffffff;"><span style="font-size: 18px;"><strong>3.2 未初始化和非法的指针</strong></span>&nbsp;</span></p><p>　　 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在 Linux 上，错误类型是 Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> *<span style="color: #000000;">p;<br>    </span><em>p = <span style="color: #800080;">1</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);</span></p><pre><code>&lt;/span&gt;&lt;span style="color: #0000ff;"&gt;return&lt;/span&gt; &lt;span style="color: #800080;"&gt;0&lt;/span&gt;&lt;span style="color: #000000;"&gt;;  </code></pre><p>}</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这个程序可以编译通过，但是运行的话会报错，报错信息如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917175256031-967973584.png" alt=""></p><p>　　要想使这个程序运行起来，需要先对指针 p 进行初始化：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span><span style="color: #000000;">;<br>    </span><span style="color: #0000ff;">int</span> <em>p = &amp;<span style="color: #000000;">x;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);<br>　  </span><em>p = <span style="color: #800080;">2</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这段代码的输出结果如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917212250007-280056505.png" alt="">&nbsp;</p><p>　　可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。&nbsp;</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>3.3 NULL指针</strong></span></p><p>　　<strong>NULL 指针是一个特殊的指针变量，表示不指向任何东西</strong>。可以通过给一个指针赋一个零值来生成一个 NULL 指针。&nbsp;</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> *p =<span style="color: #000000;"> NULL;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">p的地址为%d\n</span><span style="color: #800000;">“</span><span style="color: #000000;">,p);<br>}</span></p><p><span style="color: #008000;">/*</span><span style="color: #008000;"><strong><strong><strong>**</strong></strong></strong></span></p><ul><li>程序输出：</li><li>p的地址为0<br><strong><strong><strong>**</strong></strong></strong><span style="color: #008000;">*/</span></li></ul></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明改指针不指向一个可访问的内存位置。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>四、指针的运算</strong></span></p><p>　　C 指针的算术运算只限于两种形式：</p><p>1） 指针 +/- 整数 ：</p><p>　　 可以对指针变量 p 进行 p++、p--、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下：</p><p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180921154218407-1813012241.png" alt=""></p><p>　　在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。举个例子：</p><p>&nbsp;</p><p>2）指针 - 指针</p><p>　　只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">10</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">7</span>,<span style="color: #800080;">8</span>,<span style="color: #800080;">9</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> sub;<br>    </span><span style="color: #0000ff;">int</span> *p1 = &amp;a[<span style="color: #800080;">2</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span> *p2 = &amp;a[<span style="color: #800080;">8</span><span style="color: #000000;">];<br>    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>五、指针与数组</strong></span></p><p>　　在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。</p><p><span style="font-size: 18px;"><strong>5.1 指针与数组的关系</strong></span></p><p>　　我们先声明一个数组：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">10</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个int类型的数组，这个数组有10个元素</span></pre></div><p>　　我们可以用 a[0]、a[1]、...、a[9] 来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。</p><p>　　接下来，我们再声明一个指针：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p;           <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个int类型的指针变量</span></pre></div><p>　　 p 是一个指针变量，指向内存中的一个区域。如果我们对指针 p 做如下的初始化：</p><div class="cnblogs_code"><pre>p = &amp;a[<span style="color: #800080;">0</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0]</span></pre></div><p>　　我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即 *(p + 1) 将指向 a[1] ；同样的， *(p + i) 将指向 a[i] 。因此，我们可以使用该指针来遍历数组 a[10] 的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，<strong>数组类型的变量或表达式的值是该数组第 1 个元素的地址</strong>，且数组名所代表的的就是该数组第 1 个元素的地址，故，上述赋值语句可以直接写成：</p><div class="cnblogs_code"><pre>p = a;        <span style="color: #008000;">//</span><span style="color: #008000;"> a 为数组名，代表该数组最开始的一个元素的地址</span>&nbsp;</pre></div><p>　　很显然，<strong>一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，<em>指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址</em>，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span>                                                                          <p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> x[<span style="color: #800080;">10</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">7</span>,<span style="color: #800080;">8</span>,<span style="color: #800080;">9</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};<br>    </span><span style="color: #0000ff;">int</span> <em>p =<span style="color: #000000;"> x;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">x的地址为：%p\n</span><span style="color: #800000;">“</span><span style="color: #000000;">,x);<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">x[0]的地址为：%p\n</span><span style="color: #800000;">“</span>,&amp;x[<span style="color: #800080;">0</span><span style="color: #000000;">]);<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">p的地址为：%p\n</span><span style="color: #800000;">“</span>,&amp;p);　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 打印指针 p 的地址，并不是指针所指向的地方的地址</span><br><span style="color: #000000;"><br>    p </span>+= <span style="color: #800080;">2</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;"></span></em>(p+2)的值为：%d\n<span style="color: #800000;">“</span>,<em>p);　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为 3，</span></em>(p+2)指向了 x[2]<br>}</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　结果如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918160417548-189120951.png" alt=""></p><p>　　可以看到，&nbsp;x 的值与 x[0] 的地址是一样的，也就是说数组名即为数组中第 1 个元素的地址。实际上，打印 &amp;x 后发现，x 的地址也是这个值。而 x 的地址与指针变量 p 的地址是不一样的。故而数组和指针并不能完全等价。</p><p>（笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015 编译运行的话，则输出结果是一个 8位的十六进制数，也就是32位二进制，寻址空间为 4GB）&nbsp;</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>5.2 指针数组</strong></span></p><p>　　指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 <strong>指针数组是一个数组，数组中的每一个元素都是指针</strong>。声明一个指针数组的方法如下：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p[<span style="color: #800080;">10</span>];    <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针</span></pre></div><p>　　在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 *p[i]，而 <strong>p[i] 是一个指针</strong>。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>5.3 数组指针</strong></span></p><p>　　<strong>数组指针是一个指针，它指向一个数组</strong>。声明一个数组指针的方法如下：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> (*p)[<span style="color: #800080;">10</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个数组指针 p ，该指针指向一个数组</span></pre></div><p>　　由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre> #include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>     </span><span style="color: #0000ff;">int</span> arr[<span style="color: #800080;">2</span>][<span style="color: #800080;">3</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>};               <span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个二维数组并初始化</span><br>     <span style="color: #0000ff;">int</span> (<em>p)[<span style="color: #800080;">3</span>];                                 <span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个数组指针，指针指向一个含有3个元素的一维数组</span><br><span style="color: #000000;"><br>     p </span>= arr;                                     <span style="color: #008000;">//</span><span style="color: #008000;"> 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0]</span><br>     printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,(</em>p)[<span style="color: #800080;">0</span>]);　　　　　　　　　　　　  <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为 1</span><br>     p++;　　　　　　　　　　　　　　　　　　　　　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0]</span><br>     printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,(*p)[<span style="color: #800080;">1</span>]);                      <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为5</span><br> }&nbsp;</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>六、指针与结构</strong></span></p><p><span style="font-size: 18px;"><strong>6.1 简单介绍一下结构</strong></span></p><p>　　结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre><span style="color: #0000ff;">struct</span> message{　　　　　　      <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个结构 message</span>    <span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span>];             <span style="color: #008000;">//</span><span style="color: #008000;"> 成员</span>    <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;  };<p>typedef </p></span><span style="color: #0000ff;">struct</span> message s_message;　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 类型定义符 typedef</span><br><span style="color: #000000;"><br>s_message mess </span>= {<span style="color: #800000;">“</span><span style="color: #800000;">tongye</span><span style="color: #800000;">“</span>,<span style="color: #800080;">23</span>,<span style="color: #800080;">83</span>};　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 struct message 类型的变量 mess,并对其进行初始化　</span><br><br>————————————————————————————————————–<br><span style="color: #008000;">/*</span><span style="color: #008000;"> 另一种更简便的声明方法 </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br>typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span><span style="color: #000000;">];<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> age;<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;<br>}message;</span></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　可以使用 <strong>结构名.成员</strong> 的方式来访问结构中的成员，如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>　　printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">“</span>,mess.name);　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果：tongye</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,mess.age);　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果：23</span></p><p>　　<span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>6.2 结构指针</strong></span>　</p><p>　　结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：</p><div class="cnblogs_code"><pre>s_message *p;        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构</span>*p = &amp;mess;　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp;</span></pre></div><p>　　C语言中使用 -&gt; 操作符来访问结构指针的成员，举个例子：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><span style="color: #000000;"><p>typedef </p></span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{<br>    </span><span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> age;<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;<br>}message;<p></p><p></p></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    message mess </span>= {<span style="color: #800000;">“</span><span style="color: #800000;">tongye</span><span style="color: #800000;">“</span>,<span style="color: #800080;">23</span>,<span style="color: #800080;">83</span><span style="color: #000000;">};<br>    message </span>*p = &amp;<span style="color: #000000;">mess;<br>}</span>&nbsp;</pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>七、指针与函数</strong></span></p><p>　　<strong>C语言的所有参数均是以“传值调用”的方式进行传递的</strong>，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。&nbsp;</p><p><span style="font-size: 18px;"><strong>7.1 指针作为函数的参数</strong></span></p><p>　　传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值。</strong>用一个例子来说明：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">void</span> swap1(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b)　　　　　　  <span style="color: #008000;">//</span><span style="color: #008000;"> 参数为普通的 int 变量</span><br><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> temp;<br>　　temp </span>=<span style="color: #000000;"> a;<br>　　a </span>=<span style="color: #000000;"> b;<br>　　b </span>=<span style="color: #000000;"> temp;<br>}</span></p><p><span style="color: #0000ff;">void</span> swap2(<span style="color: #0000ff;">int</span> <em>a,<span style="color: #0000ff;">int</span> *b)　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作</span><br><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">int</span> temp;　　　　                <span style="color: #008000;">//</span><span style="color: #008000;"> 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化</span><br>　　temp = *<span style="color: #000000;">a;<br>　　</span></em>a = *<span style="color: #000000;">b;<br>　　</span>*b =<span style="color: #000000;"> temp;<br>}</span></p><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br>{<br>　　</span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span>,y = <span style="color: #800080;">2</span><span style="color: #000000;">;<br>　　swap1(x,y);                     </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x,y 的值本身作为参数传递给了被调函数</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d %5d\n</span><span style="color: #800000;">“</span>,x,y);         <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为：1     2</span><br><span style="color: #000000;"><br>　　swap(</span>&amp;x,&amp;y);                    <span style="color: #008000;">//</span><span style="color: #008000;"> 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d %5d\n</span><span style="color: #800000;">“</span>,x,y);         <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为：2     1</span><br>　　<span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>7.2 指向函数的指针</strong></span></p><p>　　在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。&nbsp;声明一个函数指针的方法如下：</p><div class="cnblogs_code"><pre>返回值类型 （*<span style="color: #000000;"> 指针变量名）（[形参列表]）;<p></p></span><span style="color: #0000ff;">int</span> (*pointer)(<span style="color: #0000ff;">int</span> *,<span style="color: #0000ff;">int</span> *);        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数指针</span></pre><p></p></div><p>　　上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><span style="color: #000000;">#include </span><span style="color: #800000;">"</span><span style="color: #800000;">string.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span> str_comp(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> <em>m,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> <em>n);                             <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型</span><br><span style="color: #0000ff;">void</span> comp(<span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *b,<span style="color: #0000ff;">int</span> (</em>prr)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span></em>));       <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针</span></p><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br>{<br>    </span><span style="color: #0000ff;">char</span> str1[<span style="color: #800080;">20</span>];      <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个字符数组</span><br>    <span style="color: #0000ff;">char</span> str2[<span style="color: #800080;">20</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span> (*p)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *) = str_comp;　　　　　　　　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型</span><br>    gets(str1);         <span style="color: #008000;">//</span><span style="color: #008000;"> 使用 gets() 函数从 I/O 读取一行字符串</span><br><span style="color: #000000;">    gets(str2);<br>    comp(str1,str2,p);  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 函数指针 p 作为参数传给 comp 函数</span><br>}</p><p><span style="color: #0000ff;">int</span> str_comp(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *m,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">n)<br>{<br>　　 </span><span style="color: #008000;">//</span><span style="color: #008000;"> 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2);</span><br>    <span style="color: #0000ff;">if</span>(strcmp(m,n) == <span style="color: #800080;">0</span><span style="color: #000000;">)<br>        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>    </span><span style="color: #0000ff;">else</span><br>        <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;<br>}</span></p><p><span style="color: #008000;">/*</span><span style="color: #008000;"> 函数 comp 接受一个函数指针作为它的第三个参数 </span><span style="color: #008000;"><em>/</em></span><br><span style="color: #0000ff;">void</span> comp(<span style="color: #0000ff;">char</span> <em>a,<span style="color: #0000ff;">char</span> *b,<span style="color: #0000ff;">int</span> (</em>prr)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span><span style="color: #000000;">))<br>{<br>    </span><span style="color: #0000ff;">if</span>((*prr)(a,b) == <span style="color: #800080;">0</span><span style="color: #000000;">)<br>        printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">str1 = str2\n</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br>        printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">str1 != str2\n</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>} </span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。</p><p>　　注意，声明一个函数指针时，() 不能漏掉，否则：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p(<span style="color: #0000ff;">void</span> *,<span style="color: #0000ff;">void</span>*);</pre></div><p>　　这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。</p><p>&nbsp;</p><p>参考文献：</p><p>1）C程序设计语言（第2版）</p><p>2）C和指针</p><p>&nbsp;</p><p>参考：</p><p><a href="https://blog.csdn.net/soonfly/article/details/51131141" target="_blank">https://blog.csdn.net/soonfly/article/details/51131141</a></p><p><a href="https://www.cnblogs.com/lulipro/p/7460206.html" target="_blank">https://www.cnblogs.com/lulipro/p/7460206.html</a></p></div></h1></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://lufeifan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序学习第二天</title>
    <link href="https://lufeifan.github.io/2019/09/07/wxml2/"/>
    <id>https://lufeifan.github.io/2019/09/07/wxml2/</id>
    <published>2019-09-07T05:09:24.590Z</published>
    <updated>2019-09-07T12:07:10.324Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h6 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h6><pre><code>添加 scroll-x就可看到滑动</code></pre><h2 id="理解display"><a href="#理解display" class="headerlink" title="理解display"></a>理解display</h2><pre><code>display: flex;display: inline-block;</code></pre><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><pre><code>属性：flex-direction:row/column 行或列</code></pre><p>问题：<br>white-space: nowrap;<br> justify-content: center;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://lufeifan.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序学习第一天</title>
    <link href="https://lufeifan.github.io/2019/09/06/wxml1/"/>
    <id>https://lufeifan.github.io/2019/09/06/wxml1/</id>
    <published>2019-09-06T12:36:17.421Z</published>
    <updated>2019-09-07T12:14:49.653Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><pre><code>pages    index        index.js    Pages({})        index.json  可以设置顶部文字和颜色        index.wxml  相当于html        index.wxss  相当于cssapp.jsapp.json    导入页面的文件app.wxss    设置全局样式</code></pre><h4 id="设置顶部"><a href="#设置顶部" class="headerlink" title="设置顶部"></a>设置顶部</h4><pre><code>"navigationBarTitleText": "String" 顶部文字"navigationBarBackgroundColor": "color", 顶部颜色"navigationBarTextStyle": "black" 仅支持白色和黑色"enablePullDownRefresh": false, //是否开启下拉刷新</code></pre><h4 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h4><pre><code>在swiper标签加swiper-item，swiper-item就是每一页的内容幻灯片小圆点:indicator-dots="true"current,记录当前页面的index</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://lufeifan.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>windows安装虚拟机</title>
    <link href="https://lufeifan.github.io/2019/09/01/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://lufeifan.github.io/2019/09/01/虚拟机/</id>
    <published>2019-09-01T11:48:14.695Z</published>
    <updated>2019-09-01T11:55:21.248Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>下载VMware Workstation，CentOS<br>在VMware Workstation中安装CentOS镜像<br>配置跟着里面安装就行</p><blockquote><p>在CentOS中还可以安装图形化界面</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>行列式</title>
    <link href="https://lufeifan.github.io/2019/09/01/%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>https://lufeifan.github.io/2019/09/01/行列式/</id>
    <published>2019-09-01T11:18:04.350Z</published>
    <updated>2019-09-01T11:59:45.145Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h5 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h5><pre><code>n个数就是n阶排列</code></pre><h5 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h5><pre><code>前面的数比后面的小</code></pre><h5 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h5><pre><code>前面的数比后面的大</code></pre><h5 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h5><pre><code>两种判断方法：    1.一个排列中前面的数比他大的有几个，总和    2.一个排列中前面的数比他小的有几个，总和</code></pre><blockquote><p>总和为奇数就是奇排列，为偶数就是偶排列</p></blockquote><blockquote><p>行列式的计算：其实可以观察矩阵用连线来记住，多少阶就一次连多少个数字，都具有一定的规律，<code>\</code>这样连线数据是想加，<code>/</code>再减去这样连线的数据就得到结果。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="线性代数" scheme="https://lufeifan.github.io/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>豆瓣插件</title>
    <link href="https://lufeifan.github.io/2019/09/01/%E8%B1%86%E7%93%A3%20%E6%8F%92%E4%BB%B6%E7%88%AC%E5%8F%96%E5%A4%B1%E8%B4%A5/"/>
    <id>https://lufeifan.github.io/2019/09/01/豆瓣 插件爬取失败/</id>
    <published>2019-09-01T05:56:24.776Z</published>
    <updated>2019-09-01T11:46:27.440Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>user 在登录豆瓣个人中心网址上面的那串数字title 突入你想填的就行quote 用来浏览器F12取消一小段爬取那部分的html</code></pre><h4 id="豆瓣插件爬取失败"><a href="#豆瓣插件爬取失败" class="headerlink" title="豆瓣插件爬取失败"></a>豆瓣插件爬取失败</h4><p>使用： hexo douban -updata<br>       hexo g<br>       hexo s<br>就可以看到爬取效果</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote><p>上传的时候不能用hexo d 只能用<code>hexo deploy</code></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lufeifan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>人物模型</title>
    <link href="https://lufeifan.github.io/2019/08/24/live2d%E4%BA%BA%E7%89%A9%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lufeifan.github.io/2019/08/24/live2d人物模型/</id>
    <published>2019-08-24T02:07:17.168Z</published>
    <updated>2019-09-01T11:37:37.871Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>1.站点配置文件下Git运行:npm install –save hexo-helper-live2d<br>2.站点配置文件写下（主题配置文件下不生效）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 添加萌妹子效果</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local  </span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko    //模型名字</span><br><span class="line">  display:    </span><br><span class="line">    position: right   //位置</span><br><span class="line">    width: 150    //妹子宽度</span><br><span class="line">    height: 300    //妹子高度</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></tbody></table></figure><p>更多模型：<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a><br>更换模型 npm install 模型名称</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lufeifan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>java文件输入输出流</title>
    <link href="https://lufeifan.github.io/2019/08/23/%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/"/>
    <id>https://lufeifan.github.io/2019/08/23/文件的读写/</id>
    <published>2019-08-23T05:37:52.750Z</published>
    <updated>2019-08-23T06:13:32.498Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><p>输入：<code>InputStream</code><br>read()方法：-1表示无</p></li><li><p>输出: <code>OutputStream</code><br>write()方法</p></li></ul><hr><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li>输入: <code>Reader</code></li><li>输出: <code>Writer</code></li></ul><hr><h3 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h3><ul><li>输入<code>FileInputStream</code></li><li>输出:<code>FileOutputStream</code></li></ul><hr><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>  输入：<code>BufferdReader</code><br>  输出：<code>BufferdWriter</code></p><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>  序列化：ObjectInputStream<br>  反序列化：ObjectOutputStream<br>  <span style="color: red">要求对象实现Serializable接口</span></p><hr><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p><img src="http://pwmvr65mz.bkt.clouddn.com/201908231353_863.png" alt="常用的操作"><br><img src="http://pwmvr65mz.bkt.clouddn.com/201908231355_407.png" alt="常用的处理流"></p><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>文件的操作要进行错误处理</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lufeifan.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>实用推荐</title>
    <link href="https://lufeifan.github.io/2019/08/23/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <id>https://lufeifan.github.io/2019/08/23/网站推荐/</id>
    <published>2019-08-23T03:34:07.080Z</published>
    <updated>2019-09-07T05:17:58.959Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><ul><li>1.在线平面设计 <a href="https://www.fotor.com.cn" target="_blank" rel="noopener">https://www.fotor.com.cn</a></li><li>2.<a href="https://pixabay.com/zh/" target="_blank" rel="noopener">https://pixabay.com/zh/</a></li><li>3.<a href="https://www.pexels.com/zh-cn/" target="_blank" rel="noopener">https://www.pexels.com/zh-cn/</a><h3 id="小图标"><a href="#小图标" class="headerlink" title="小图标"></a>小图标</h3> <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">https://fontawesome.com/v4.7.0/icons/</a><h3 id="截图推荐"><a href="#截图推荐" class="headerlink" title="截图推荐"></a>截图推荐</h3> snipaste:能将图片贴在屏幕，很好地观察，快捷键：快速截屏F1,快速贴图F3,退出贴图shift+Esc。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows安装MySQL</title>
    <link href="https://lufeifan.github.io/2019/08/23/Windows%20%E4%B8%8A%E5%AE%89%E8%A3%85%20MySQL/"/>
    <id>https://lufeifan.github.io/2019/08/23/Windows 上安装 MySQL/</id>
    <published>2019-08-23T01:54:15.699Z</published>
    <updated>2019-08-23T02:38:58.899Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>1.下载<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">最新版本</a><br>2.<img src="http://pwmvr65mz.bkt.clouddn.com/201908231000_464.png" alt="如图"><br>3.<img src="http://pwmvr65mz.bkt.clouddn.com/201908231002_844.png" alt="如图"><br>4.安装MySQL<br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231020_317.png" alt="安装模式"><br> 更改地址<img src="http://pwmvr65mz.bkt.clouddn.com/201908231023_822.png" alt="更改地址"><br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231024_793.png" alt=""><br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231032_70.png" alt=""><br> 然后一点击下一步就可以<br>5.运行MySQL<img src="http://pwmvr65mz.bkt.clouddn.com/201908231035_680.png" alt="运行MySQL"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://lufeifan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>七牛云截屏上传返回图片地址</title>
    <link href="https://lufeifan.github.io/2019/08/22/%E4%B8%83%E7%89%9B%E4%BA%91%E6%88%AA%E5%B1%8F%E4%B8%8A%E4%BC%A0/"/>
    <id>https://lufeifan.github.io/2019/08/22/七牛云截屏上传/</id>
    <published>2019-08-22T14:09:08.556Z</published>
    <updated>2019-08-22T14:24:49.691Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.到<a href="https://github.com/jiwenxing/qimage-win/releases" target="_blank" rel="noopener">github</a>下载release版本</p></li><li><p>2.打开release中的 <code>settings.ini</code> 文件</p></li><li><p>3.去七牛云找到密匙填写<img src="http://pwmvr65mz.bkt.clouddn.com/201908222218_401.png" alt="密匙"> </p></li><li><p>4.BUCKET_NAME：储存空间的名称</p></li><li><p>5BUCKET_DOMAIN：你自己的域名</p></li><li><p>6.UP_HOST = <a href="http://up-z2.qiniup.com" target="_blank" rel="noopener">http://up-z2.qiniup.com</a></p></li><li><p>7.DEBUG_MODE：调试开关，截屏上传失败可以把false改为true</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="markdown" scheme="https://lufeifan.github.io/categories/markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>鼠标点击特效</title>
    <link href="https://lufeifan.github.io/2019/08/21/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%86%E7%82%B8%E6%95%88%E6%9E%9C/"/>
    <id>https://lufeifan.github.io/2019/08/21/鼠标点击爆炸效果/</id>
    <published>2019-08-21T08:53:07.782Z</published>
    <updated>2019-08-21T09:18:16.453Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.主题配置文件找 <code>layout</code> 文件夹中的 <code>_layout.swig</code>在body中加入</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{% if theme.fireworks %}</span><br><span class="line">   &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; </span><br><span class="line">   &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; </span><br><span class="line">   &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;</span><br><span class="line">  {% endif %}</span><br></pre></td></tr></tbody></table></figure></li><li><p>2.主题配置文件找<code>source</code> 文件夹中的 <code>js</code>新建src文件夹，在src新建fireworks.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)}"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)};</span><br></pre></td></tr></tbody></table></figure></li><li><p>3.主题配置文件末尾加入：</p><pre><code># Fireworksfireworks: true</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lufeifan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA面向对象（2)</title>
    <link href="https://lufeifan.github.io/2019/08/21/java2/"/>
    <id>https://lufeifan.github.io/2019/08/21/java2/</id>
    <published>2019-08-21T08:46:43.225Z</published>
    <updated>2019-08-23T06:15:47.820Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>类的组成：变量，方法，构造方法</li><li>构造方法：与类同名，不返回数字类型</li><li>方法<ul><li>实例方法</li><li>静态方法 </li><li>方法重载：该方法有多个名字但参数的个数和类型不同，可以用来实现<span style="color: red">多态</span></li></ul></li><li>变量：<ul><li>实例变量</li><li>静态变量</li></ul></li><li>类的对象：可以访问类中的方法</li><li>继承：<ul><li>声明 子类 extends 父类</li><li>继承父类的变量和方法</li><li>可以修改父类的变量和方法，还可以添加自己的变量和方法，名字相同就会进行覆盖和修改</li><li>关键字：this表示该类的对象</li><li>super：<span style="color: red">必须放在第一句</span>用于访问父类的变量和方法（一般用于同名），可用来调用父类的构造方法</li><li>父类对象和子类对象的转换（好像是上转型对象）</li></ul></li></ul><hr><h3 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h3><ul><li>import用于导入其他类，放在文件的首位</li><li>同包类可以相互访问,反之不得</li></ul><hr><h3 id="控制符"><a href="#控制符" class="headerlink" title="控制符"></a>控制符</h3><ul><li>static</li><li>final</li><li>abstract</li><li></li><li></li></ul><hr><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>  定义接口：interface<br>  实现接口：implements<br>  调用接口则接口中的所有方法必须重写<br>  可以实现多继承<br>  接口定义的常量具有final，static，public属性</p><hr><p><img src="http://pwmvr65mz.bkt.clouddn.com/201908231331_490.png" alt="完整的类定义"><br><img src="http://pwmvr65mz.bkt.clouddn.com/201908231333_501.png" alt="完整的接口定义"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lufeifan.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA面向对象（1)</title>
    <link href="https://lufeifan.github.io/2019/08/21/java1/"/>
    <id>https://lufeifan.github.io/2019/08/21/java1/</id>
    <published>2019-08-21T07:34:17.216Z</published>
    <updated>2019-08-23T06:14:45.112Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>整数型<ul><li>进制的表示</li></ul></li><li>浮点数型<ul><li>注意单精度的书写要加f</li></ul></li><li>逻辑型—boolean</li><li>字符型—char</li><li>数据类型的转换</li></ul><hr><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>可以由数字，字母，下划线_,美元符号$组成</li><li>不能以数字开头</li><li>通常类名开头要大写（java大小写敏感）</li><li>其余的小写字母开头</li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组的创建<ul><li>数组的声明 <code>int []a;</code>(不能声明数组的长度)</li><li>为数组分配内存空间 <code>a=new[5]</code></li><li>数组的定义</li></ul></li><li>数组的引用类型<br><code>int []a=new int[5]</code><br>这里的a就是引用</li><li>数组默认初始化为0或者null</li><li>数组的遍历：</li><li>简单的循环语句</li><li>也可以用for(int age;age){}只读遍历</li><li>数组长度：数组名.length 可以获取</li><li>数组的复制：Array.Copy<br></li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lufeifan.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>视频嵌入</title>
    <link href="https://lufeifan.github.io/2019/08/20/%E8%A7%86%E9%A2%91/"/>
    <id>https://lufeifan.github.io/2019/08/20/视频/</id>
    <published>2019-08-20T04:48:57.358Z</published>
    <updated>2019-08-20T07:00:02.285Z</updated>
    
    <content type="html"><![CDATA[<iframe width="100%" height="350" src="//player.bilibili.com/player.html?aid=62244859&amp;cid=108194807&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><a id="more"></a><hr><iframe width="100%" height="350" frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=k0029f52ciy" allowfullscreen="true"></iframe><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;iframe width=&quot;100%&quot; height=&quot;350&quot; src=&quot;//player.bilibili.com/player.html?aid=62244859&amp;amp;cid=108194807&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
    
    </summary>
    
      <category term="外接嵌入" scheme="https://lufeifan.github.io/categories/%E5%A4%96%E6%8E%A5%E5%B5%8C%E5%85%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>pr</title>
    <link href="https://lufeifan.github.io/2019/08/20/Pr/"/>
    <id>https://lufeifan.github.io/2019/08/20/Pr/</id>
    <published>2019-08-20T02:50:43.636Z</published>
    <updated>2019-08-21T01:25:00.156Z</updated>
    
    <content type="html"><![CDATA[<hr><p>教程推荐 :<a href="https://www.bilibili.com/video/av5540953/?p=9" target="_blank" rel="noopener">https://www.bilibili.com/video/av5540953/?p=9</a></p><a id="more"></a><ul><li>画面放大缩小： 双击预览视频区</li><li>弹幕制作： 使用默认静态字幕<pre><code>弹幕效果：使用关键帧 -- 运动 设置关键帧的开始和结束位置（&lt;span style="color: red"&gt;记得打点&lt;/span&gt;）</code></pre></li><li>视频速度：右键更改速度比例(鬼畜)</li><li>视频的衔接：左侧工具栏找到 <span style="color: red">- 视频过度</span></li><li>视频结尾：使用关键帧 – 运动 设置关键帧的开始和结束位置（记得打点）</li><li>导出：<span style="color: red">h.264</span></li></ul><hr><ul><li>视频转场：<br>  1.全选素材<br>  2.Ctrl+d<br>  3.转场素材可去设置默认</li><li>批量缩放素材：<br>  找到首选项中的默认媒体缩放设置为<span style="color: red"> 帧大小</span></li><li>批量调色：<br>  1.效果控件将颜色复制在删掉<br>  2.找到只要进行粘贴</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;教程推荐 :&lt;a href=&quot;https://www.bilibili.com/video/av5540953/?p=9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av5540953/?p=9&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剪辑软件" scheme="https://lufeifan.github.io/categories/%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>音乐载入</title>
    <link href="https://lufeifan.github.io/2019/08/19/%E9%9F%B3%E4%B9%90/"/>
    <id>https://lufeifan.github.io/2019/08/19/音乐/</id>
    <published>2019-08-19T13:56:09.136Z</published>
    <updated>2019-08-20T06:56:30.289Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&amp;id=2946604834&amp;auto=0&amp;height=430"></iframe><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="外接嵌入" scheme="https://lufeifan.github.io/categories/%E5%A4%96%E6%8E%A5%E5%B5%8C%E5%85%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="https://lufeifan.github.io/2019/08/19/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://lufeifan.github.io/2019/08/19/hexo搭建博客/</id>
    <published>2019-08-19T11:48:47.484Z</published>
    <updated>2019-09-02T13:05:35.489Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.下载node.js<br> <a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a></p></li><li><p>2.下载Git<br> <a href="https://git-scm.com/" target="_blank" rel="noopener">下载地址</a></p></li><li><p>3.安装Hexo</p><ul><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官方Api</a></li><li>在新的文件夹右键  Git Bash Here</li><li>在Git中输入 npm install -g hexo-cli</li><li>hexo init</li><li>npm install</li></ul></li><li><p>4.更换主题(本人使用NexT主题,<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT</a>)</p><ul><li><a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题下载</a></li><li>更换主题：到根目录 _config.yml 找到 theme </li></ul></li><li><p>5.更改语言</p><ul><li>到根目录 _config.yml 将 language: 改为 zh-CN</li></ul></li><li><p>6.增加标签和分类页<br> 在主题配置文件找到 Menu Settings 将要打开的功能去掉#</p></li><li><p>7.更换头像<br> 在主题配置文件找到 avatar 将url更改</p></li><li><p>8.更改标题和作者<br> 站点配置文件Ctrl+F 搜索title，author将其更改</p></li><li><p>9.启用社交链接<br> 在主题配置文件找到 social 将需要的功能打开，也可以自行添加</p></li><li><p>10.打开打赏功能<br> 在主题配置文件找到 reward_settings 将false 改为true<br> 找到 reward 更改图片地址</p></li><li><p>11.打开订阅公众号<br> 在主题配置文件找到 wechat_subscriber 将false 改为true</p></li><li><p>12.添加动态背景<br> 在主题配置文件找到 canvas_nest 将 enable: false更改为 true<br> 可能需要下载库<a href="https://github.com/theme-next/theme-next-canvas-ribbon" target="_blank" rel="noopener">链接</a></p></li><li><p>13.设置阅读全文</p><ul><li>1.打开source 在文章中加入&lt; !–more–&gt;(无空格)</li><li>2.在主题配置文件找到 auto_excerpt 将false 改为true ，length自行调节</li></ul></li><li><p>14.添加评论,搜索，统计，分享，字数统计，阅读市场功能(可参照NexT使用文档)<br> <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT使用文档</a></p></li><li><p>15.部署到Github(可参照NexT使用文档)</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lufeifan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>页面框架</title>
    <link href="https://lufeifan.github.io/2019/08/18/%E6%A1%86%E6%9E%B6/"/>
    <id>https://lufeifan.github.io/2019/08/18/框架/</id>
    <published>2019-08-18T14:24:18.018Z</published>
    <updated>2019-08-20T04:01:19.355Z</updated>
    
    <content type="html"><![CDATA[<p>链接</p><a id="more"></a><hr><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a><br> 图片<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1566191281845&amp;di=ee60fafd53208630597b75c2707954fa&amp;imgtype=0&amp;src=http%3A%2F%2Fww1.sinaimg.cn%2Fwap720%2F005T8ELAgw1f9u8wqhesnj310x0kuwhc.jpg" alt="欧阳娜娜"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;link rel="stylesheet" href="index.css"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="top"&gt;        &lt;div class="container"&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div id="vlog"&gt;        &lt;div class="container"&gt;            &lt;div class="vlog-left"&gt;            &lt;/div&gt;            &lt;div class="vlog-right"&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;*{    padding: 0;    margin: 0;}#top{    width: 100%;    height: 100px;    border: 1px solid red;}.container{    width: 70%;    height: 100%;;    margin: 0px auto;    border: 1px solid red;}#vlog{    width: 100%;    height: 400px;    border: 1px solid red;}.container .vlog-left{    width: 18%;    height: 100%;    border: 1px solid red;    float: left;}.container .vlog-right{    width: 80%;    height: 100%;    float: right;    border: 1px solid red;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接&lt;/p&gt;
    
    </summary>
    
      <category term="页面框架" scheme="https://lufeifan.github.io/categories/%E9%A1%B5%E9%9D%A2%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello</title>
    <link href="https://lufeifan.github.io/2019/08/18/hello/"/>
    <id>https://lufeifan.github.io/2019/08/18/hello/</id>
    <published>2019-08-18T12:53:40.520Z</published>
    <updated>2019-08-20T04:46:46.919Z</updated>
    
    <content type="html"><![CDATA[<p>(一)C语言的结构</p><a id="more"></a><p>１。程序的构成，main函数和其他函数。<br>２。头文件、数据说明、函数的开始和结束标志。<br>３。源程序的书写格式。<br>４。C语言的风格。<br>(二)数据类型及其运算<br>１。C的数据类型（基本类型、构造类型、指针类型、空类型）及其定义方法。<br>２。C运算符的种类、运算优先级和结合性。<br>３。不同类型数据间的转换与运算。<br>４。C表达式类型（赋值表达、算术表达式、关系表达式、逻辑表达式、条件表达式、逗号表达式）和求值规则。<br>(三)基本语句<br>１。表达式语句，空语句，复合语句。<br>２。数据的输入与输出，输入输出函数的调用。<br>３。复合语句。<br>４。goto语句和语句标号的使用。<br>(四)选择结构程序设计<br>１。用if语句实现选择结构。<br>２。用switch语句实现多分支选择结构。<br>３。选择结构的嵌套<br>(五)循环结构程序设计<br>１。for循环结构。<br>２。while和dowhile循环结构。<br>３。continue语句和break语句。<br>４。循环的嵌套。<br>(六)数组定义和引用<br>１。一维数组和多维数组的定义、初始化和引用。<br>２。字符串与字符数组。<br>(七)函数<br>１。库函数的正确调用。<br>２。函数的定义方法。<br>３。函数的类型和返回值。<br>４。形式参数与实在参数，参数值的传递。<br>５。函数的正确调用，嵌套调用，递归调用。<br>６。局部变量和全局变量。<br>７。变量的存储类别（自动、静态、寄存器、外部），变量的作用域和生存期。<br>８。内部函数与外部函数。<br>(八)编译预处理<br>１。宏定义：不带参数的宏定义；带参数的宏定义。<br>２。“文件包含”处理<br>(九)指针<br>１。指针与指针变量的概念，指针与地址运算符。<br>２。变量、数组、字符串、函数、结构体的指针以及指向变量、数组、字符串、函数、结构体的指针变量。通过指针引用以上各类型数据。<br>３。用指针作函数参数。<br>４。返回指针值的指针函数。<br>５。指针数组，指向指针的指针，main函数的命令行参数。<br>(十)结构体（即“结构”）与共用体（即“联合”）<br>１。结构体和共用体类型数据的定义方法和引用方法。<br>２。用指针和结构体构成链表，单向链表的建立、输出、删除与插入。<br>(十一)位运算<br>１。位运算符的含义及使用。<br>２。简单的位运算。<br>(十二)文件操作<br>只要求缓冲文件系统（即高级磁盘I/O系统），对非标准缓冲文–件系统（即低级磁盘I/O系统）不要求。<br>１。文件类型指针（FILE类型指针）。<br>２。文件的打开与关闭（fopen,fclose）。<br>３。文件的读写（fputc，fgetc，fputs，fread，fwrite，fprintf，fscanf函数），文件的定位（rewind,fseek函数）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(一)C语言的结构&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://lufeifan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
</feed>
