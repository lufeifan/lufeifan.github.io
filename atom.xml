<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陆陆陆啊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lufeifan.github.io/"/>
  <updated>2019-09-08T04:08:06.633Z</updated>
  <id>https://lufeifan.github.io/</id>
  
  <author>
    <name>陆陆陆啊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo</title>
    <link href="https://lufeifan.github.io/2019/09/08/Hexo%E9%83%A8%E7%BD%B2/"/>
    <id>https://lufeifan.github.io/2019/09/08/Hexo部署/</id>
    <published>2019-09-08T04:07:18.089Z</published>
    <updated>2019-09-08T04:08:06.633Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>转载自：<a href="https://juejin.im/post/5b70d68ae51d45665d383281#heading-8" target="_blank" rel="noopener">https://juejin.im/post/5b70d68ae51d45665d383281#heading-8</a></p><div data-v-3300248a="" data-v-81eba26a="" class="main-area article-area shadow"><article data-v-3300248a="" itemscope="itemscope" itemtype="http://schema.org/Article" class="article" data-v-81eba26a=""><meta itemprop="url" content="https://juejin.im/post/5b70d68ae51d45665d383281"><meta itemprop="headline" content="带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器"><meta itemprop="keywords" content="Git,前端,Hexo,服务器"><meta itemprop="datePublished" content="2018-08-14T03:56:47.138Z"><meta itemprop="image" content="https://b-gold-cdn.xitu.io/icon/icon-128.png"><div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="lawler61"><meta itemprop="url" content="https://juejin.im/user/585001e12f301e00573d9d0c"></div><div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"><div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://b-gold-cdn.xitu.io/icon/icon-white-180.png"><meta itemprop="width" content="180"><meta itemprop="height" content="180"></div></div><div data-v-3300248a="" class="author-info-block"><a data-v-3300248a="" href="/user/585001e12f301e00573d9d0c" target="_blank" rel="" class="avatar-link"><div data-v-a444215c="" data-v-30f85d34="" data-v-3300248a="" data-src="https://user-gold-cdn.xitu.io/2018/8/13/165327b43b6809be?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1" class="lazy avatar avatar loaded" style="background-image: url(&quot;https://user-gold-cdn.xitu.io/2018/8/13/165327b43b6809be?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1&quot;);"></div></a><div data-v-3300248a="" class="author-info-box"><a data-v-1fbe08ff="" data-v-3300248a="" href="/user/585001e12f301e00573d9d0c" target="_blank" rel="" class="username username ellipsis">lawler61</a><a data-v-7bfacf50="" data-v-1fbe08ff="" href="/book/5c90640c5188252d7941f5bb/section/5c9065385188252da6320022" target="_blank" rel="" class="rank"><img data-v-7bfacf50="" src="https://b-gold-cdn.xitu.io/v3/static/img/lv-2.f597b88.svg" alt="lv-2"></a><div data-v-3300248a="" class="meta-box"><time data-v-3300248a="" datetime="2018-08-14T03:56:47.138Z" title="Tue Aug 14 2018 11:56:47 GMT+0800 (中国标准时间)" class="time">2018年08月14日</time><span data-v-3300248a="" class="views-count">阅读 3134</span><!----></div></div><button data-v-81b0e688="" data-v-3300248a="" class="follow-button follow">关注</button></div><!----><h1 data-v-3300248a="" class="article-title">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器</h1><div data-v-3300248a="" data-id="5b70d6f3f265da283038243d" itemprop="articleBody" class="article-content"><h1 class="heading" data-id="heading-0">hexo-to-your-server</h1><h2 class="heading" data-id="heading-1">一、完成效果</h2><p><a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fwww.freeze61.me%2F" rel="nofollow noopener noreferrer">点击查看个人网站</a></p><h2 class="heading" data-id="heading-2">二、准备</h2><p>基本上每一步都会给出链接，可以多多参考</p><h3 class="heading" data-id="heading-3">本地配置<code>node</code>环境</h3><ol><li><code>node</code>下载 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fnodejs.org%2Fzh-cn%2Fdownload%2F" rel="nofollow noopener noreferrer">官网下载</a></li></ol><p>参考链接：</p><ul><li><p><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fxuanwo.org%2F2015%2F03%2F26%2Fhexo-intor%2F" rel="nofollow noopener noreferrer">史上最详细的Hexo博客搭建图文教程</a></p></li><li><p><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fe03e363713f9" rel="nofollow noopener noreferrer">通过Git将Hexo博客部署到服务器</a></p></li></ul><p>可以使用官方的<code>node</code>安装包或者<code>nvm</code>管理 node 版本，但千万<strong>不要混用</strong>，不然会环境和管理上的麻烦</p><ol start="2"><li>安装：基本都是下一步，但记得把目录改到其他盘，这里我具体是在 <code>D:\programming\nodejs</code></li></ol><p></p><figure><img alt="node更换路径" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530c867d69e01d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="499" data-height="389" src="data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;499&quot; height=&quot;389&quot;></svg>"><figcaption></figcaption></figure><p></p><p>打开<code>cmd</code>查看<code>node</code>安装情况，执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">node -vnpm -v<span class="copy-code-btn">复制代码</span></code></pre><ol start="3"><li>配置全局环境</li></ol><p>参考链接：</p><ul><li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fjizhuanfan0742%2Farticle%2Fdetails%2F80910187" rel="nofollow noopener noreferrer">windows npm -g 全局安装的命令找不到</a></li></ul><p>进入安装目录，创建文件夹<code>node_global</code>和<code>node_cache</code>，执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">"D:\programming\nodejs\node_global"</span>npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">"D:\programming\nodejs\node_cache"</span><span class="copy-code-btn">复制代码</span></code></pre><p>环境配置：新增环境变量<code>NODE_PATH</code>和添加<code>Path</code>，两个值都为 <code>D:\programming\nodejs\node_global</code></p><p></p><figure><img alt="node更换路径" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530c8da7d907ab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="658" data-height="187" src="data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;658&quot; height=&quot;187&quot;></svg>"><figcaption></figcaption></figure><p></p><p></p><figure><img alt="path更换路" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530caf6d91929d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="634" data-height="576" src="data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;634&quot; height=&quot;576&quot;></svg>"><figcaption></figcaption></figure><p></p><ol start="4"><li>测试全局环境</li></ol><p>打开<code>cmd</code>安装<code>hexo-cli</code>，分别执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">npm install hexo-cli -ghexo<span class="copy-code-btn">复制代码</span></code></pre><p>如果出现下面情况，恭喜你成功<code>全局模块调用</code></p><p></p><figure><img alt="node更换路径" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530cc1c29a6fcb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="651" data-height="429" src="https://user-gold-cdn.xitu.io/2018/8/13/16530cc1c29a6fcb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p><ol start="5"><li><p>如果出现<code>命令未找到，或不是可执行程序</code>，别着急！<strong>先仔细重复 3-4 步</strong>，一般是能够给解决的</p></li><li><p>如果实在是不能解决，往后看，如果没错，<strong>直接跳过该步</strong></p></li></ol><p>随便找个地方初始化文件，执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">mkdir hexo-blog<span class="hljs-built_in">cd</span> hexo-blog &amp;&amp; npm init然后回车键一阵乱敲！<span class="copy-code-btn">复制代码</span></code></pre><p>现在有 3 种解决方法，<strong>任选其一</strong></p><ul><li>法 1：检查<code>D:\programming\nodejs\node_global</code>目录是否有<code>hexo</code>模块，执行如下命令</li></ul><pre><code class="hljs bash copyable" lang="bash">D:\programming\nodejs\node_global\hexo // 每次使用全局模块带上前缀即可<span class="copy-code-btn">复制代码</span></code></pre><p>如果成功显示步骤 4 的情况，则调用成功。如果觉得每次加前缀麻烦，往后看</p><ul><li>法 2：使用<code>link</code>命令链接，执行如下命令</li></ul><pre><code class="hljs bash copyable" lang="bash">npm link hexo<span class="copy-code-btn">复制代码</span></code></pre><p>package.json 中新建脚本如下，执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">npm run hexo<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img alt="新建npm脚本" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530cb782b701df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="624" data-height="304" src="https://user-gold-cdn.xitu.io/2018/8/13/16530cb782b701df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p><ul><li>法 3：你还可以直接在<code>hexo-blog</code>中下载，执行如下命令</li></ul><pre><code class="hljs bash copyable" lang="bash">npm install hexo-cli -Snpm run hexo （还是要在package.json中新建脚本）<span class="copy-code-btn">复制代码</span></code></pre><h3 class="heading" data-id="heading-4">初始化<code>hexo</code>项目</h3><ol><li>如果是按照上一节步骤 6 过来的，则在<code>hexo-blog</code>文件下初始化，执行如下命令</li></ol><pre><code class="hljs bash copyable" lang="bash">hexo init myblog &amp;&amp; <span class="hljs-built_in">cd</span> myblognpm install<span class="copy-code-btn">复制代码</span></code></pre><ol start="2"><li>下载主题，执行如下命令</li></ol><p>参考链接：</p><ul><li><p><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fb20fc983005f" rel="nofollow noopener noreferrer">Hexo设置主题以及Next主题个性设置</a></p></li><li><p><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fhexo.io%2Fthemes%2F" rel="nofollow noopener noreferrer">官网全部主题</a></p></li></ul><pre><code class="hljs bash copyable" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<span class="copy-code-btn">复制代码</span></code></pre><p>在<strong>本地配置文件</strong>中设置<code>theme</code>属性</p><p></p><figure><img alt="添加next主题" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530cea2acf6c3b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="573" data-height="590" src="data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;573&quot; height=&quot;590&quot;></svg>"><figcaption></figcaption></figure><p></p><ol start="3"><li>本地执行<code>hexo</code>项目</li></ol><p>统一添加<code>start</code>脚本，并执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">npm start<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img alt="新" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530ce6b15475e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="754" data-height="341" src="https://user-gold-cdn.xitu.io/2018/8/13/16530ce6b15475e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p><p>快可以打开 <a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Flocalhost%3A4000%2F" rel="nofollow noopener noreferrer">http://localhost:4000/</a> 验证效果吧</p><h3 class="heading" data-id="heading-5"><code>git</code>环境搭建</h3><ol><li><code>git</code>安装</li></ol><p>参考资料：</p><ul><li><p><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.liaoxuefeng.com%2Fwiki%2F0013739516305929606dd18361248578c67b8067c8c017b000" rel="nofollow noopener noreferrer">廖雪峰老师的 git 教程</a></p></li><li><p><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgitforwindows.org%2F" rel="nofollow noopener noreferrer">git 官网下载</a></p></li></ul><ol start="2"><li>生成<code>ssh</code>认证，执行如下命令</li></ol><p>参考资料：</p><ul><li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2FYan_Less%2Farticle%2Fdetails%2F72866395" rel="nofollow noopener noreferrer">Git 提交时报错warning: LF will be replaced by CRLF in</a></li></ul><pre><code class="hljs bash copyable" lang="bash">git config --global user.name <span class="hljs-string">"yourname"</span>git config --global user.email youremail@example.comssh-keygen -t rsa -C <span class="hljs-string">"youremail@example.com"</span>git config --global core.autocrlf <span class="hljs-literal">false</span>  // 禁用自动转换，这个不设置后面上传时会出现警告，如下<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img alt="git警告" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530cc8c66263e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="848" data-height="258" src="https://user-gold-cdn.xitu.io/2018/8/13/16530cc8c66263e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p><p>最后获取到的<code>ssh</code>认证在<code>C:\Users\yourname\.ssh</code>中</p><hr><h2 class="heading" data-id="heading-6">三、服务器配置</h2><h3 class="heading" data-id="heading-7">搭建远程<code>Git</code>私库</h3><ol><li><p>登录到远程服务器，建议使用<code>Xshell 5</code></p></li><li><p>安装 git，执行如下命令</p></li></ol><pre><code class="hljs bash copyable" lang="bash">git --version // 如无，则安装yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y git<span class="copy-code-btn">复制代码</span></code></pre><ol start="3"><li>创建用户并配置其仓库，执行如下命令</li></ol><p>参考资料：</p><ul><li><a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fwww.swiftyper.com%2F2016%2F04%2F17%2Fdeploy-hexo-with-git-hook%2F" rel="nofollow noopener noreferrer">使用 Git Hook 自动部署 Hexo 到个人 VPS</a></li></ul><pre><code class="hljs bash copyable" lang="bash">useradd gitpasswd git // 设置密码su git // 这步很重要，不切换用户后面会很麻烦<span class="hljs-built_in">cd</span> /home/git/mkdir -p projects/blog // 项目存在的真实目录mkdir repos &amp;&amp; <span class="hljs-built_in">cd</span> reposgit init --bare blog.git // 创建一个裸露的仓库<span class="hljs-built_in">cd</span> blog.git/hooksvi post-receive // 创建hook钩子函数，输入了内容如下（原理可以参考上面的链接）<span class="copy-code-btn">复制代码</span></code></pre><pre><code class="hljs bash copyable" lang="bash"><span class="hljs-meta">#!/bin/sh</span>git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout <span class="hljs-_">-f</span><span class="copy-code-btn">复制代码</span></code></pre><p>添加完毕后修改权限，执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">chmod +x post-receive<span class="hljs-built_in">exit</span> // 退出到 root 登录chown -R git:git /home/git/repos/blog.git // 添加权限<span class="copy-code-btn">复制代码</span></code></pre><ol start="4"><li>测试<code>git仓库</code>是否可用，另找空白文件夹，执行如下命令</li></ol><pre><code class="hljs bash copyable" lang="bash">git <span class="hljs-built_in">clone</span> git@server_ip:/home/git/repos/blog.git<span class="copy-code-btn">复制代码</span></code></pre><p>如果能把空仓库拉下来，就说明 git 仓库搭建成功了</p><p></p><figure><img alt="git仓库测试" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530ccdf7933823?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="676" data-height="253" src="https://user-gold-cdn.xitu.io/2018/8/13/16530ccdf7933823?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p><ol start="5"><li>建立<code>ssh</code>信任关系，在<strong>本地电脑</strong>，执行如下命令</li></ol><p>参考资料：</p><ul><li><a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Froclinux.cn%2F%3Fp%3D2551" rel="nofollow noopener noreferrer">ssh-copy-id 帮你建立信任</a></li></ul><pre><code class="hljs bash copyable" lang="bash">ssh-copy-id -i C:/Users/yourname/.ssh/id_rsa.pub git@server_ipssh git@server_ip // 测试能否登录<span class="copy-code-btn">复制代码</span></code></pre><p><strong>注</strong>：此时的 ssh 登录 git 用户不需要密码！否则就<strong>有错</strong>，请仔细重复步骤 3-4</p><ol start="6"><li>如果第 5 步能成功，为了安全起见禁用<code>git用户</code>的 shell 登录权限，从而只能用<code>git clone</code>,<code>git push</code>等登录，执行如下命令</li></ol><p>参考资料：</p><ul><li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Flgyaxx%2Farticle%2Fdetails%2F72954121" rel="nofollow noopener noreferrer">Git Server - 限制 Git 用户使用 SSH 登陆操作</a></li></ul><pre><code class="hljs bash copyable" lang="bash">cat /etc/shells // 查看`git-shell`是否在登录方式里面，有则跳过<span class="hljs-built_in">which</span> git-shell // 查看是否安装vi /etc/shells添加上2步显示出来的路劲，通常在 /usr/bin/git-shell<span class="copy-code-btn">复制代码</span></code></pre><p>修改<code>/etc/passwd</code>中的权限，将原来的</p><pre><code class="hljs bash copyable" lang="bash">git:x:1000:1000::/home/git:/bin/bash<span class="copy-code-btn">复制代码</span></code></pre><p>修改为</p><pre><code class="hljs bash copyable" lang="bash">git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell<span class="copy-code-btn">复制代码</span></code></pre><h3 class="heading" data-id="heading-8">搭建<code>nginx</code>服务器</h3><ol><li>下载并安装<code>nginx</code>，执行如下命令</li></ol><p>参考资料：</p><ul><li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4134a44a09c2" rel="nofollow noopener noreferrer">Nginx 源码安装和简单的配置</a></li><li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Faotu.io%2Fnotes%2F2016%2F08%2F16%2Fnginx-https%2Findex.html" rel="nofollow noopener noreferrer">Nginx 配置 HTTPS 服务器</a></li></ul><pre><code class="hljs bash copyable" lang="bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/srcwget http://nginx.org/download/nginx-1.15.2.tar.gztar xzvf nginx-1.15.2.tar.gz<span class="hljs-built_in">cd</span> nginx-1.15.2./configure // 如果后面还想要配置 SSL 协议，就执行后面一句！./configure --prefix=/usr/<span class="hljs-built_in">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_modulemake &amp;&amp; make install<span class="hljs-built_in">alias</span> nginx=<span class="hljs-string">'/usr/local/nginx/sbin/nginx'</span> // 为nginx取别名，后面可直接用<span class="copy-code-btn">复制代码</span></code></pre><ol start="2"><li>配置<code>nginx</code>文件</li></ol><p>参考资料：</p><ul><li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fyang_xu_1987%2Farticle%2Fdetails%2F77929658" rel="nofollow noopener noreferrer">Linux 中 nginx 基本操作命令</a></li></ul><p>先启动是否安装成功，执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">nginx // 直接来！浏览器查看 server_ip，默认是80端口<span class="copy-code-btn">复制代码</span></code></pre><p>配置文件，执行如下命令</p><pre><code class="hljs bash copyable" lang="bash">nginx <span class="hljs-_">-s</span> stop // 先停止nginx<span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/nginx/confvi nginx.conf修改 root 解析路径，如下图同时将 user 改为 root 如下图，不然nginx无法访问 /home/git/project/blognginx <span class="hljs-_">-s</span> reload<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img alt="修改nginx配置" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530cd39d2779df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="565" data-height="481" src="https://user-gold-cdn.xitu.io/2018/8/13/16530cd39d2779df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p><p></p><figure><img alt="修改nginx user" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530cd8e227988a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="541" data-height="306" src="https://user-gold-cdn.xitu.io/2018/8/13/16530cd8e227988a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p><hr><h2 class="heading" data-id="heading-9">四、链接</h2><p>至此我们就把本地和服务器的环境全部搭建完成，现在利用 hexo 配置文件进行链接</p><h3 class="heading" data-id="heading-10">配置<code>_config.yml</code>文件</h3><ol><li>编辑<code>_config.yml</code>的<code>deploy</code>属性</li></ol><p></p><figure><img alt="编辑本地deploy" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/8/13/16530cdd97741ca6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="696" data-height="398" src="https://user-gold-cdn.xitu.io/2018/8/13/16530cdd97741ca6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p><ol start="2"><li>在<code>package.json</code>中添加 npm 脚本</li></ol><pre><code class="hljs json copyable" lang="json">"scripts": {  "deploy": "hexo clean &amp;&amp; hexo g -d",  "start": "hexo clean &amp;&amp; hexo g &amp;&amp; hexo s"},<span class="copy-code-btn">复制代码</span></code></pre><ol start="3"><li>链接！这下在本地调试就用<code>npm start</code>，调试好了就上传到服务器，美滋滋~快通过你的服务器ip访问吧</li></ol><pre><code class="hljs bash copyable" lang="bash">npm run deploy<span class="copy-code-btn">复制代码</span></code></pre><hr><h2 class="heading" data-id="heading-11">五、总结</h2><p>本次教程介绍<code>node</code>环境配置，主要强调了全局模块的调用，然后是初始化 hexo 项目，建议多参考官方的配置。然后搭建本地和服务器的<code>git</code>环境，通过<code>ssh通行证</code>交互。接下来是通过<code>nginx.conf</code>文件来配置<code>nginx</code>。最后<code>_config.yml</code>的<code>deploy</code>参数来连接本地和服务器</p><hr><h2 class="heading" data-id="heading-12">六、最后说句</h2><p>本人前端新手一枚，有错误的话欢迎指正</p><p>贴上 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.freeze61.me%2F" rel="nofollow noopener noreferrer">个人网站</a>，建站初期，欢迎您的光临~</p><p>喜欢的话麻烦 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Flawler61%2Fhexo-to-your-server" rel="nofollow noopener noreferrer">Github</a> 给个 ★ 哦</p></div></article><div data-v-3300248a="" data-v-81eba26a="" class="tag-list-box"><div data-v-3300248a="" data-v-81eba26a="" class="tag-list-title">关注下面的标签，发现更多相似文章</div><div data-v-3300248a="" data-v-81eba26a="" st:block="tagList" class="tag-list"><a data-v-3300248a="" href="/tag/Git" target="_blank" rel="" st:name="tag" class="item" data-v-81eba26a=""><div data-v-a444215c="" data-v-41441f3f="" data-v-3300248a="" data-src="https://lc-gold-cdn.xitu.io/3cf1219be35e6fa28229.png?imageView2/2/w/42/h/42/q/85/format/webp/interlace/1" class="lazy thumb tag-icon" style="background-image: none; background-size: contain;"></div><div data-v-3300248a="" class="tag-title">Git</div></a><a data-v-3300248a="" href="/tag/%E5%89%8D%E7%AB%AF" target="_blank" rel="" st:name="tag" class="item" data-v-81eba26a=""><div data-v-a444215c="" data-v-41441f3f="" data-v-3300248a="" data-src="https://lc-gold-cdn.xitu.io/bac28828a49181c34110.png?imageView2/2/w/42/h/42/q/85/format/webp/interlace/1" class="lazy thumb tag-icon" style="background-image: none; background-size: contain;"></div><div data-v-3300248a="" class="tag-title">前端</div></a><a data-v-3300248a="" href="/tag/Hexo" target="_blank" rel="" st:name="tag" class="item" data-v-81eba26a=""><div data-v-a444215c="" data-v-41441f3f="" data-v-3300248a="" data-src="https://lc-gold-cdn.xitu.io/bb655f08310127a75843.png?imageView2/2/w/42/h/42/q/85/format/webp/interlace/1" class="lazy thumb tag-icon" style="background-image: none; background-size: contain;"></div><div data-v-3300248a="" class="tag-title">Hexo</div></a><a data-v-3300248a="" href="/tag/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="" st:name="tag" class="item" data-v-81eba26a=""><div data-v-a444215c="" data-v-41441f3f="" data-v-3300248a="" data-src="https://lc-gold-cdn.xitu.io/be1879c7e9983dab0049.png?imageView2/2/w/42/h/42/q/85/format/webp/interlace/1" class="lazy thumb tag-icon" style="background-image: none; background-size: contain;"></div><div data-v-3300248a="" class="tag-title">服务器</div></a></div></div><a data-v-3300248a="" href="/user/585001e12f301e00573d9d0c" target="_blank" rel="" data-v-81eba26a=""></a><div data-v-3300248a="" class="footer-author-block"><a data-v-3300248a="" href="/user/585001e12f301e00573d9d0c" target="_blank" rel="" data-v-81eba26a=""></a><div data-v-3eacb830="" data-v-3300248a="" itemscope="itemscope" itemtype="http://schema.org/Person" class="author"><a data-v-3300248a="" href="/user/585001e12f301e00573d9d0c" target="_blank" rel="" data-v-81eba26a=""><meta itemprop="url" content="https://juejin.im/user/585001e12f301e00573d9d0c"><meta itemprop="image" content="https://user-gold-cdn.xitu.io/2018/8/13/165327b43b6809be?w=1004&amp;h=1004&amp;f=jpeg&amp;s=171066"><meta itemprop="name" content="lawler61"><meta itemprop="jobTitle" content="前端搬砖工"><div itemprop="memberOf" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="字节跳动"></div></a><div data-v-3eacb830="" class="author-info-block"><a data-v-3300248a="" href="/user/585001e12f301e00573d9d0c" target="_blank" rel="" data-v-81eba26a=""></a><a data-v-3eacb830="" href="/user/585001e12f301e00573d9d0c" target="_blank" rel="" class="avatar-link"><div data-v-a444215c="" data-v-30f85d34="" data-v-3eacb830="" data-src="https://user-gold-cdn.xitu.io/2018/8/13/165327b43b6809be?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1" class="lazy avatar avatar" style="background-image: none;"></div></a><div data-v-3eacb830="" class="author-info-box"><div data-v-3eacb830="" class="profile-box"><a data-v-1fbe08ff="" data-v-3eacb830="" href="/user/585001e12f301e00573d9d0c" target="_blank" rel="" class="username username ellipsis">lawler61</a><a data-v-7bfacf50="" data-v-1fbe08ff="" href="/book/5c90640c5188252d7941f5bb/section/5c9065385188252da6320022" target="_blank" rel="" class="rank"><img data-v-7bfacf50="" src="https://b-gold-cdn.xitu.io/v3/static/img/lv-2.f597b88.svg" alt="lv-2"></a><span data-v-3eacb830="" class="position ellipsis">前端搬砖工 @ 字节跳动</span></div><div data-v-3eacb830="" class="meta-box"><a data-v-3eacb830="" href="/user/585001e12f301e00573d9d0c/posts" target="_blank" rel="" class="posts"><span data-v-3eacb830="" class="count post-count">发布了 8 篇专栏 · </span></a><span data-v-3eacb830="" class="count">获得点赞 52 · </span><span data-v-3eacb830="" class="count">获得阅读 5,531</span></div></div><button data-v-81b0e688="" data-v-3eacb830="" class="follow-button follow">关注</button></div></div></div><div data-v-3300248a="" data-v-81eba26a="" st:block="banner" class="article-banner"><a data-v-3300248a="" data-v-81eba26a="" st:name="link" st:state="https://juejin.im/extension/?utm_source=juejin.im&amp;utm_medium=post&amp;utm_campaign=extension_promotion" class="banner-title" href="https://juejin.im/extension/?utm_source=juejin.im&amp;utm_medium=post&amp;utm_campaign=extension_promotion" target="_blank">安装掘金浏览器插件</a><div data-v-3300248a="" data-v-81eba26a="" class="banner-content">打开新标签页发现好内容，掘金、GitHub、Dribbble、ProductHunt 等站点内容轻松获取。快来安装掘金浏览器插件获取高质量内容吧！</div></div><!----><!----><div data-v-28283acd="" data-v-3300248a="" class="comment-list-box" id="comment-box" data-v-81eba26a=""><div data-v-28283acd="" class="title">评论</div><div data-v-685300f0="" data-v-28283acd="" class="comment-form comment-form"><div data-v-685300f0="" class="avatar-box"><div data-v-a444215c="" data-v-30f85d34="" data-v-685300f0="" data-src="https://b-gold-cdn.xitu.io/v3/static/img/default-avatar.e30559a.svg" class="lazy avatar avatar" style="background-image: none;"></div></div><div data-v-685300f0="" class="form-box"><div data-v-685300f0="" class="input-box"><div data-v-d96d107c="" data-v-685300f0="" class="auth-card"><!----><div data-v-685300f0="" data-v-d96d107c="" contenteditable="true" spellcheck="false" placeholder="输入评论..." class="rich-input empty"><br data-v-685300f0="" data-v-d96d107c=""></div></div><!----></div><!----></div><input data-v-685300f0="" type="file" class="hidden"></div><!----><!----></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git服务器</title>
    <link href="https://lufeifan.github.io/2019/09/08/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://lufeifan.github.io/2019/09/08/搭建Git服务器/</id>
    <published>2019-09-08T03:38:14.911Z</published>
    <updated>2019-09-08T04:00:59.669Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="1-从本地导出-git文件夹"><a href="#1-从本地导出-git文件夹" class="headerlink" title="1.从本地导出.git文件夹"></a>1.从本地导出.git文件夹</h4><pre><code>git clone --bare my_project my_project.gitmy_project:  .git结尾的文件my_project.git: 生成的文件</code></pre><h4 id="2-放到远程服务器上"><a href="#2-放到远程服务器上" class="headerlink" title="2.放到远程服务器上"></a>2.放到远程服务器上</h4><pre><code>$ scp -r my_project.git 用户名@服务器ip:/home/放到服务器的文件位置</code></pre><h4 id="3-在服务器上下载上传的文件"><a href="#3-在服务器上下载上传的文件" class="headerlink" title="3.在服务器上下载上传的文件"></a>3.在服务器上下载上传的文件</h4><pre><code>1.创建新的文件夹2.在文件夹里 执行 git init --bare，git init --bare --shared3.下载 git clone 用户名@服务器ip:/home/放到服务器</code></pre><p>遇到的问题：<br>    Git无法访问：解决办法找到本地计算机的.ssh文件，找到known_hosts删除你服务器的记录<br>    权限：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lufeifan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言链表</title>
    <link href="https://lufeifan.github.io/2019/09/07/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://lufeifan.github.io/2019/09/07/链表基础知识总结/</id>
    <published>2019-09-07T15:44:37.562Z</published>
    <updated>2019-09-07T23:55:01.843Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><div class="blog-content-box">    <div class="article-header-box">        <div class="article-header">            <div class="article-title-box">                <span class="article-type type-1 float-left">原</span>                <h1 class="title-article">链表基础知识总结</h1>            </div>            <div class="article-info-box">                <div class="article-bar-top" style="height: 24px;">                                                                                                                                            <span class="time">2018年05月02日 19:47:49</span>                    <a class="follow-nickName" href="https://me.csdn.net/u012531536" target="_blank" rel="noopener">zql_3393089</a>                    <span class="read-count">阅读数 62396</span><span class="article_info_click" style="position: static;">更多</span>                                                                    <div class="tags-box space">                                <span class="label">分类专栏：</span>                                                                                                            <a class="tag-link" target="_blank" rel="noopener" href="https://blog.csdn.net/u012531536/article/category/7635058">                                            On the way                                        </a>                                                                                                </div>                                        </div>                <div class="operating">                                    </div>            </div>        </div>    </div>    <article class="baidu_pl">                <div id="article_content" class="article_content clearfix">                                                <div class="article-copyright">                <span class="creativecommons">                <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">                    </a>            <span>版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。 </span>               <div class="article-source-link2222">                    本文链接：<a href="https://blog.csdn.net/u012531536/article/details/80170893" target="_blank" rel="noopener">https://blog.csdn.net/u012531536/article/details/80170893</a>                </div>            </span>                    </div>                                                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">                                        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">                <div class="htmledit_views" id="content_views">                                            <p>链表和数组作为算法中的两个基本数据结构，在程序设计过程中经常用到。尽管两种结构都可以用来存储一系列的数据，但又各有各的特点。</p><p>数组的优势，在于可以方便的遍历查找需要的数据。在查询数组指定位置（如查询数组中的第4个数据）的操作中，只需要进行1次操作即可，时间复杂度为O(1)。但是，这种时间上的便利性，是因为数组在内存中占用了连续的空间，在进行类似的查找或者遍历时，本质是指针在内存中的定向偏移。然而，当需要对数组成员进行添加和删除的操作时，数组内完成这类操作的时间复杂度则变成了O(n)。</p><p>链表的特性，使其在某些操作上比数组更加高效。例如当进行插入和删除操作时，链表操作的时间复杂度仅为O(1)。另外，因为链表在内存中不是连续存储的，所以可以充分利用内存中的碎片空间。除此之外，链表还是很多算法的基础，最常见的哈希表就是基于链表来实现的。基于以上原因，我们可以看到，链表在程序设计过程中是非常重要的。本文总结了我们在学习链表的过程中碰到的问题和体会。</p><p>接下来，我们将对链表进行介绍，用C语言分别实现：链表的初始化、创建、元素的插入和删除、链表的遍历、元素的查询、链表的删除、链表的逆序以及判断链表是否有环等这些常用操作。并附上在Visual Studio 2010 中可以运行的代码供学习者参考。</p><p>说到链表，可能有些人还对其概念不是很了解。我们可以将一条链表想象成环环相扣的结点，就如平常所见到的锁链一样。链表内包含很多结点（当然也可以包含零个结点）。其中每个结点的数据空间一般会包含一个数据结构（用于存放各种类型的数据）以及一个指针，该指针一般称为next，用来指向下一个结点的位置。由于下一个结点也是链表类型，所以next的指针也要定义为链表类型。例如以下语句即定义了链表的结构类型。</p><p><span style="font-family:'Times New Roman';">typedef struct LinkList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p><span style="font-family:'Times New Roman';">{</span></p><p><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int Element;</span></p><p><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LinkList * next;</span></p><p><span style="font-family:'Times New Roman';">}LinkList;</span></p><h3><a name="t0"></a><span style="font-size:18px;">链表初始化</span></h3><p>在对链表进行操作之前，需要先新建一个链表。此处讲解一种常见的场景下新建链表：在任何输入都没有的情况下对链表进行初始化。</p><p>链表初始化的作用就是生成一个链表的头指针，以便后续的函数调用操作。在没有任何输入的情况下，我们首先需要定义一个头指针用来保存即将创建的链表。所以函数实现过程中需要在函数内定义并且申请一个结点的空间，并且在函数的结尾将这个结点作为新建链表的头指针返回给主调函数。本文给出的例程是生成一个头结点的指针，具体的代码实现如下：</p><p align="left"><span style="color:#0000FF;">linklist</span> *&nbsp; <span style="color:#880000;">List_init</span>()</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>= (<span style="color:#0000FF;">linklist</span>*)<span style="color:#A000A0;">malloc</span>(<span style="color:#0000FF;">sizeof</span>(<span style="color:#0000FF;">linklist</span>));</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">HeadNode</span> == <span style="color:#A000A0;">NULL</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#880000;">printf</span>(<span style="color:#A31515;">"</span><span style="color:#A31515;">空间缓存不足</span><span style="color:#A31515;">"</span>);</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; HeadNode-&gt;<span style="color:#000080;">Element</span>= 0;</p><p align="left">&nbsp;&nbsp;&nbsp; HeadNode-&gt;<span style="color:#000080;">next</span>= <span style="color:#000080;">NULL</span>;</p><p align="left">&nbsp;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span>HeadNode;</p><p align="left">}</p><p>当然,初始化的过程或者方法不只这一种，其中也包含头指针存在的情况下对链表进行初始化，此处不再一一罗列。</p><p>这里引申一下，此处例程中返回的链表指针为该链表的头结点，相对应的还有一个头指针的概念。头指针内只有指针的元素，并没有数据元素，但头结点除了指针还有数据。</p><p>头指针就是链表的名字，仅仅是个指针而已。头结点是为了操作的统一与方便而设立的，放在第一个有效元素结点（首元结点）之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。一般情况下见到的链表的指针多为头指针，但最近在一个程序员编程网站leetcode中发现，题目中所给的链表一般是首元结点作为第一个元素，而不是头指针。</p><p>下图为头指针与头结点以及首元结点的关系。</p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20180502195346635" alt=""><br></p><h3><a name="t1"></a><span style="font-size:18px;">链表创建</span></h3><p>创建链表需要将既定数据按照链表的结构进行存储，本文以一种最简单的方式来演示：使用数组对链表赋值。将原来在连续空间存放的数组数据，放置在不连续的链表空间中，使用指针进行链接。</p><p>链表创建的步骤一般使用给定的头指针以及需要初始化的数据序列作为输入参数，本文使用数组作为输入数据序列。在下面的例程中，先将首元结点使用数组第一个元素初始化，再在首元结点之后创建新的链表结点赋值数组内余下的数据。具体实现如下：</p><p align="left"><span style="color:#0000FF;">void</span> <span style="color:#880000;">CreatList</span>(<span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>,<span style="color:#0000FF;">int</span> *<span style="color:#000080;">InData</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">DataNum</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">i</span> = 0;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode = (</span><span style="color:#0000FF;">linklist</span>*<span style="color:#000080;">) HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">for</span>(<span style="color:#000080;">i</span> = 0;<span style="color:#000080;">i</span>&lt;<span style="color:#000080;">DataNum</span>;<span style="color:#000080;">i</span>++)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#000080;">Element</span> = <span style="color:#000080;">InData</span>[<span style="color:#000080;">i</span>];</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">i</span>&lt; DataNum-1)<span style="color:#008000;">//</span> <span style="color:#008000;">由于每次赋值后需要新建结点，为了保证没有多余的废结点</span></p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurrentNode-&gt;next =(linklist *)<span style="color:#000080;">malloc</span>(<span style="color:#0000FF;">sizeof</span>(linklist));</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#A000A0;">CurrentNode</span>= <span style="color:#0000FF;">CurrentNode</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>-&gt;next= NULL;</p><p align="left">}</p><p>程序内先新建了一个指针变量CurrentNode用来表示当前的结点指针。最初，我们让CurrentNode指向了首元结点HeadNode的位置。然后根据输入数组的大小进行循环赋值，赋值完成之后再重新申请一个结点空间用来存放下一个结点的内容，并且将当前结点指针CurrentNode指向新生成的结点。由于链表创建函数调用时已经存在一个首元结点，按照这个逻辑最终在使用最后一个数组数据赋值之后还会多生成一个结点。因此，为了保证没有冗余的结点，循环内需要用DataNum-1来控制结点数量。</p><p>另外，C语言的初学者需要注意：无论被调子函数内含在几个参数，虽然子函数内的形参使用的是主函数内实参的指针，但在子函数内是不会改变主函数里实参的地址的。也就是说，只要子函数不返回指针，子函数的内容就不会影响主函数内的参数指针。正如程序中CurrentNode的指针最初是主函数内的头指针传递进来的，虽然创建链表的函数内CurrentNode的指针一直在往后移动，但并不会改变主调函数内的首元结点的指针。本文链表的学习过程中会大量使用指针，建议各位学习者在打牢基础后再进行学习。</p><h3><a name="t2"></a><span style="font-size:18px;">插入链表结点</span></h3><p>链表创建完之后，下面我们将介绍如何向链表内插入结点。一般添加结点可以分为两类：一类是在链表尾部插入；另一类为在中间插入。</p><p>链表结尾添加结点的步骤就是新建一个链表结点，将其链接到当前链表尾指针。</p><p>在中间结点插入结点的步骤稍微复杂一些，其中也包含两种情况，分别是在指定结点前插入和指定结点后插入。其操作原理一样，本文只对指定位置后插入结点进行介绍。指定结点前插入结点留给大家尝试。</p><p>假设一个链表内存在几个几点A1，A2,A3,A4….，当根据要求需要在指定位置之后（比如A2结点）插入一个新结点时。首先我们需要新建立一个结点NodeToInsert，然后将新结点的next指向A3，并且将A2的next指针指向新建立的结点NodeToInsert，切记操作顺序不要改变。如果操作顺序变换一下，先将A2的next指向了新建立的结点，那么我们就丢失了A3的寻址方式。因此，在将A2的next指向其他任何地方之前，请务必将A3的地址存在NodeToInsert或者某个新建节点内。</p><p>插入结点的具体操作如下：</p><p align="left"><span style="color:#0000FF;">bool</span> <span style="color:#880000;">InsertList</span>(<span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">LocateIndex</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">InData</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">i</span>=1;<span style="color:#008000;">//</span> <span style="color:#008000;">由于起始结点</span><span style="color:#000080;">HeadNode</span><span style="color:#008000;">是头结点，所以计数从</span><span style="color:#008000;">1</span><span style="color:#008000;">开始</span></p><p align="left">&nbsp;&nbsp;&nbsp; linklist *CurrentNode= (<span style="color:#0000FF;">linklist</span> *) HeadNode;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#008000;">//</span><span style="color:#008000;">将</span><span style="color:#008000;">CurrentNode</span><span style="color:#008000;">指向待插入位置的前一个结点（</span><span style="color:#008000;">index -1</span><span style="color:#008000;">）</span></p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(CurrentNode&amp;&amp; i&lt;LocateIndex-1)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= <span style="color:#000080;">CurrentNode</span>-&gt;next;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">i</span>++;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; linklist *<span style="color:#000080;">NodeToInsert</span>=(linklist*)<span style="color:#0000FF;">malloc</span>(<span style="color:#0000FF;">sizeof</span>(<span style="color:#000080;">linklist</span>));</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">NodeToInsert</span> == <span style="color:#A000A0;">NULL</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#880000;">printf</span>(<span style="color:#A31515;">"</span><span style="color:#A31515;">空间缓存不足</span><span style="color:#A31515;">"</span>);</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">ERROR</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">NodeToInsert</span>-&gt;Element= <span style="color:#0000FF;">InData</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">NodeToInsert</span>-&gt;<span style="color:#000080;">next</span> = CurrentNode-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">NodeToInsert</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">OK</span>;</p><p align="left">}</p><h3><a name="t3"></a><span style="font-size:18px;">删除链表结点</span></h3><p>对应于插入链表结点，链表的基本操作中同样也有删除链表结点。删除结点包括删除指定位置的结点和指定元素的结点。其基本原理都是先锁定待删除的结点的位置，然后将该结点的后置结点链接到前置结点的next指针处。这样中间这个结点即我们要删除的结点就从原来的链表中脱离开来。相对于原来的链表，即删除了该结点。</p><p align="left"><span style="color:#0000FF;">bool</span> <span style="color:#880000;">DeleteList</span>(<span style="color:#0000FF;">linklist</span> * <span style="color:#000080;">HeadNode</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">index</span>, <span style="color:#0000FF;">int</span> * <span style="color:#000080;">DataToDel</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">i</span> = 1;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode</span> &nbsp;= <span style="color:#000080;">HeadNode</span>;&nbsp; </p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">NodeToDelete</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#008000;">//</span><span style="color:#008000;">将</span><span style="color:#008000;">CurrentNode</span><span style="color:#008000;">指向待删除位置的前一个结点（</span><span style="color:#008000;">index -1</span><span style="color:#008000;">）</span></p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(CurrentNode&amp;&amp; i&lt;<span style="color:#000080;">index</span>-1)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= CurrentNode-&gt;next;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">i</span>++;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; NodeToDelete = CurrentNode-&gt;next;</p><p align="left">&nbsp;&nbsp;&nbsp; *<span style="color:#000080;">DataToDel</span> =NodeToDelete-&gt;Element;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>-&gt;next= <span style="color:#000080;">NodeToDelete</span>-&gt;next;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">free</span>(<span style="color:#000080;">NodeToDelete</span>);</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">OK</span>;</p><p align="left">}</p><p>此处为什么还要重新建立一个指针来记录或者保存待删除的结点呢？明明一个简单的步骤CurrentNode -&gt;next = CurrentNode -&gt;next-&gt;next;就可以将这个结点CurrentNode-&gt;next删除了，为什么要多此一举呢？</p><p>此处新建的链表类型的指针NodeToDelete是为了释放CurrentNode-&gt;next。直接使用CurrentNode -&gt;next = CurrentNode -&gt;next-&gt;next只是将该节点从链表中剔除，但是没有将其空间从内存中释放。而且,经过了CurrentNode -&gt;next = CurrentNode -&gt;next-&gt;next这个赋值语句之后，我们已经丢失了原本需要删除的结点的地址。所以，在删除之前新建了个结点用来保存待删除的结点地址，以便后面对内存空间的释放。</p><h3><a name="t4"></a><span style="font-size:18px;">获取链表长度&amp;链表遍历</span></h3><p>获取链表的长度实际上和遍历链表具有相同的操作。遍历的过程将链表内的结点都访问了一边。获取链表长度的具体步骤是遍历链表之后能够记录并返回链表结点个数。</p><p>本文给出获取链表长的函数代码。</p><p align="left"><span style="color:#0000FF;">int</span> <span style="color:#880000;">GetListLength</span>(<span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>)</p><p align="left">{</p><p align="left">&nbsp;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">ListLength</span> = 0;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode</span>= (<span style="color:#0000FF;">linklist</span>*)<span style="color:#000080;"> HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">CurrentNode</span>)<span style="color:#008000;">//</span> <span style="color:#008000;">当前指针不为空时可以计数累加</span></p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListLength++;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= <span style="color:#000080;">CurrentNode</span>-&gt;next;&nbsp;&nbsp;&nbsp; <span style="color:#008000;">//</span><span style="color:#008000;">指针移到下一结点</span></p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span>ListLength;</p><p align="left">}</p><p>在该函数中，出现了CurrentNode = CurrentNode -&gt;next的表示方法，这是将CurrentNode -&gt;next这个结点的指针移动到了当前这个结点CurrentNode，下一次使用CurrentNode指针的时候CurrentNode实际已经指向了下一个结点CurrentNode -&gt;next。所以这也是常说到的结点后移。</p><p>对于链表内的赋值操作我们总结出几种情况：</p><h3><a name="t5"></a><span style="font-size:18px;">获取链表元素</span></h3><p>接下来我们将“给定链表中的某一个位置，返回该位置的数据值”和“返回链表内某一个元素的位置”这两个问题放在一起介绍。</p><p>这两种情况的思路都是需要遍历链表。在给定元素值的情况下，定义一个元素序号随着遍历的过程累加，遍历的过程校验链表的结点是否与给定的元素匹配，如果匹配则返回元素位置的序号；在给定位置的情况下就更简单一些，元素序号累加到对应位置，返回对应结点的元素即可。</p><p>本文只列出给定元素值的例子：</p><p align="left"><span style="color:#0000FF;">int</span> <span style="color:#880000;">LocateElement</span>(<span style="color:#0000FF;">linklist</span> * <span style="color:#000080;">HeadNode</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">DataToLocate</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">LocateIndex</span> = 1;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode</span>= (<span style="color:#0000FF;">linklist</span>*)<span style="color:#000080;"> HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">CurrentNode</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#000080;">Element</span>== <span style="color:#000080;">DataToLocate</span>)</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span><span style="color:#000080;">LocateIndex</span>;<span style="color:#008000;"> //</span><span style="color:#008000;">找到位置返回</span></p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= <span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#880000;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">LocateIndex</span>++;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> -1;<span style="color:#008000;"> //</span><span style="color:#008000;">如果没有这个值，返回</span><span style="color:#008000;">-1</span></p><p align="left">&nbsp;</p><p align="left">}</p><p>本函数的逻辑是如果遍历链表之后能够找到与所给元素匹配的结点，则将该结点的位置返回。但如果没有匹配的结点的话，则返回一个-1，表示获取元素位置失败。</p><h3><a name="t6"></a><span style="font-size:18px;">链表置空</span></h3><p>链表置空又可以称为销毁链表。同样是在遍历的前提下，一直到链表结尾结束，所有遍历到的链表结点均释放掉空间，具体代码如下：</p><p align="left"><span style="color:#0000FF;">bool</span> <span style="color:#880000;">DestroyList</span>(<span style="color:#0000FF;">linklist</span> * <span style="color:#000080;">HeadNode</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">pNext</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode</span>= (<span style="color:#0000FF;">linklist</span>*)<span style="color:#000080;"> HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">CurrentNode</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pNext</span> = <span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#880000;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#A000A0;">free</span>(<span style="color:#000080;">CurrentNode</span>);</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= <span style="color:#000080;">pNext</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">HeadNode</span>-&gt;<span style="color:#880000;">next</span> = <span style="color:#A000A0;">NULL</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#A000A0;">OK</span>;</p><p align="left">}</p><h3><a name="t7"></a><span style="font-size:18px;">链表逆序</span></h3><p>链表的逆序有很多种思路，本文介绍一种将当前结点的下一结点一直往头指针之后移动的思路。</p><p>假设当前有5个结点，head、a1、a2、a3、a4、a5，他们的头指针是head。我们的思路便是将a1作为当前元素一直往后遍历，并且将a1后面的数据依次挪到head之后。 &nbsp;&nbsp;</p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20180502195718402" alt=""><br></p><p>在第一次搬移的过程中，需要将a1的下一个元素a2放在head之后。如图所示，当前结点选定为a1，起一个变量名为current，当前结点的下一个结点为pNext，则a2便成了pNext = current-&gt;next。如果想要将pNext移到head之后，我们按照图中第1步先将a3连接到a1的后面，然后第2步再将head后面的整体链表放到要移动的a2的后面，也就是pNext-&gt;next= head-&gt;next，第3步将a2移到head之后。这三个步骤下来，我们的第一次反转工作就算完成了。此时的链表链表就变成了head、a2、a1、a3、a4、a5，如图所示：</p><p style="text-align:center;">                              <img src="https://img-blog.csdn.net/20180502195849229" alt=""><br></p><p>如果上面移动的步骤不按图中进行会出现什么情况呢？假设现在按照3-2-1的步骤来实现a2移动到head后面。当先进行第三步之后，即head-&gt;next = pNext;这一步直接将a2挪到了head之后。然后我们接下来应该再将原来head后面的一串数据链接到刚刚移动到head后面的a2后面，此处由于head后面的数据已经被pNext更新了，此时head后面是a2结点，所以在执行第二步以后，链表就变成了无限循环的链表，而且循环的元素值是a2。</p><p>按照上图正确的顺序实现第一次反转以后，可以判定当前的current指针是否已经是尾指针，如果不是就可以继续执行。第二次反转后链表就变成了head、a3、a2、a1、a4、a5。因此当把链表内的最后一个元素也移动到head之后时，链表逆序的工作就算完成了。</p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20180502195918818" alt=""><br></p><p>具体的代码实现如下。</p><p align="left"><span style="color:#0000FF;">linklist</span> * <span style="color:#880000;">ListRotate</span>(<span style="color:#0000FF;">linklist</span> * <span style="color:#000080;">HeadNode</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span>* <span style="color:#000080;">current</span>,*<span style="color:#000080;">pNext</span>,*<span style="color:#000080;">pPrev</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pPrev</span> = (<span style="color:#0000FF;">linklist</span>*)<span style="color:#A000A0;">malloc</span>(<span style="color:#0000FF;">sizeof</span>(<span style="color:#0000FF;">linklist</span>));</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">pPrev</span> == <span style="color:#A000A0;">NULL</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#880000;">printf</span>(<span style="color:#A31515;">"</span><span style="color:#A31515;">空间缓存不足</span><span style="color:#A31515;">"</span>);</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">ERROR</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pPrev</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">current</span> = <span style="color:#000080;">HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">current</span>-&gt;<span style="color:#000080;">next</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pNext</span> = <span style="color:#000080;">current</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">current</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">pNext</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pNext</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">pPrev</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pPrev</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">pNext</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">pPrev</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">}</p><h3><a name="t8"></a>链表判断是否有环</h3><p>判断链表是否存在环的过程中，通常最先想到的方法就是从定义下手，有环的话就没有尾结点，也就是说不存在一个结点的next指针是null。通过这种思路可以对有环无环进行判定，但需要判定到何时呢？</p><p>当遍历了4000个结点都没有遇到null结点，难道就可以断定这就是一个有环的链表吗？如果它的第4001个结点就是尾结点呢？很多情况下，我们是不知道链表的长度的，所以我们很难确定需要判定到哪一个结点才能确定链表是否为环形链表。因此我们需要借助快指针、慢指针的概念，这是目前用来判断链表内有环无环的最通用有效的方法。</p><p>假设有这样一种情况，有两辆车，一辆车每秒钟可以跑n米，另外一辆速度要快一些，每秒能跑2n米，这两辆车都匀速运行。如果在一个没有交叉点的跑道上，这时跑道上有一个终点，快车和慢车同时在起始点相遇出发之后，一直到终点，快车和慢车的距离只会越拉越大，等到快车到达终点的时候，两者之间的距离差最大。假想一种情况，如果跑道的终点与起始点连接了起来，虽然说从慢车的角度看，快车在前方越来越远。但快车的角度看，慢车在后面越来越远，但在前面看的话确实越来越近。所以在一个环形的跑道上，快车终究会有第二次与慢车相遇，此时正好超车一圈。</p><p>函数的执行过程如下：</p><p align="left"><span style="color:#0000FF;">bool</span> <span style="color:#880000;">IsListLoop</span>(<span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">pFast</span>,*<span style="color:#000080;">pSlow</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pFast</span> = <span style="color:#000080;">pSlow</span> = <span style="color:#000080;">HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">pFast</span> &amp;&amp; <span style="color:#000080;">pSlow</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pSlow</span> = <span style="color:#000080;">pSlow</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">pFast</span>-&gt;<span style="color:#000080;">next</span>)</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pFast</span>= <span style="color:#000080;">pFast</span>-&gt;<span style="color:#000080;">next</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">else</span></p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pFast</span>= <span style="color:#000080;">pFast</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">pFast</span> == <span style="color:#000080;">pSlow</span>)</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span><span style="color:#A000A0;">TRUE</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#A000A0;">FALSE</span>;</p><p align="left">}</p><p>&nbsp;</p><p>以上介绍了链表的部分基本操作，这些操作是实现很多算法的基础。希望大家共同学习进步，不足之处望指出。</p><p><span style="color:#FF0000;">&nbsp;</span></p>                                    </div>                    </div>    </article></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://lufeifan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言指针</title>
    <link href="https://lufeifan.github.io/2019/09/07/%E6%8C%87%E9%92%88/"/>
    <id>https://lufeifan.github.io/2019/09/07/指针/</id>
    <published>2019-09-07T15:12:45.269Z</published>
    <updated>2019-09-07T23:55:07.881Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>本文转载自：<a href="https://www.cnblogs.com/tongye/p/9650573.html" target="_blank" rel="noopener">https://www.cnblogs.com/tongye/p/9650573.html</a></p><div class="post">            <h1 class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/tongye/p/9650573.html" target="_blank" rel="noopener">C语言--指针详解</a><div id="cnblogs_post_body" class="blogpost-body ">    <p>　　这段时间在看 Linux 内核，深觉 C 语言功底不扎实，很多代码都看不太懂，深入学习巩固 C 语言的知识很有必要。先从指针开始。</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>一、什么是指针</strong></span></p><p>　　C语言里，变量存放在内存中，而<strong>内存其实就是一组有序字节组成的数组</strong>，每个字节有唯一的内存地址。CPU 通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。也就是说：<strong>指针是一种保存变量地址的变量</strong>。</p><p>　　前面已经提到内存其实就是一组有序字节组成的数组，数组中，每个字节大大小固定，都是 8bit。对这些连续的字节从 0 开始进行编号，每个字节都有唯一的一个编号，这个编号就是内存地址。示意如下图：</p><p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918115659254-712651853.png" alt=""></p><p style="text-align: left;">　　这是一个 4GB 的内存，可以存放 2^32 个字节的数据。左侧的连续的十六进制编号就是内存地址，每个内存地址对应一个字节的内存空间。而指针变量保存的就是这个编号，也即内存地址。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>二、为什么要使用指针</strong></span></p><p>　　在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p><p>1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p><p>2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p><p>3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>三、如何声明一个指针</strong></span></p><p><span style="font-size: 18px; background-color: #ffffff;"><strong>3.1 声明并初始化一个指针</strong></span></p><p>　　指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p;        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 int 类型的指针 p</span><span style="color: #0000ff;">char</span> *p        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 char 类型的指针 p</span><span style="color: #0000ff;">int</span> *arr[<span style="color: #800080;">10</span>]   <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span><span style="color: #0000ff;">int</span> (*arr)[<span style="color: #800080;">10</span>] <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个数组指针，该指针指向一个 int 类型的一维数组</span><span style="color: #0000ff;">int</span> **p;       <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针 p ，该指针指向一个 int 类型的指针</span></pre></div><p>　　指针的声明比普通变量的声明多了一个一元运算符 “*”。运算符 “*” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。</p><p>　　声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre><span style="color: #008000;">/*</span><span style="color: #008000;"> 方法1：使指针指向现有的内存 </span><span style="color: #008000;">*/</span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span><span style="color: #000000;">;</span><span style="color: #0000ff;">int</span> *p = &amp;x;　　<span style="color: #008000;">//</span><span style="color: #008000;"> 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span>/ 方法2：动态分配内存给指针 <span style="color: #008000;">/int *p;p = (int *)malloc(sizeof(int) * 10);　　　　// malloc 函数用于动态分配内存free(p);　　　　// free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</p><p>&nbsp;</p><p><span style="background-color: #ffffff;"><span style="font-size: 18px;"><strong>3.2 未初始化和非法的指针</strong></span>&nbsp;</span></p><p>　　 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在 Linux 上，错误类型是 Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> *<span style="color: #000000;">p;<br>    </span><em>p = <span style="color: #800080;">1</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);</span></p><pre><code>&lt;/span&gt;&lt;span style="color: #0000ff;"&gt;return&lt;/span&gt; &lt;span style="color: #800080;"&gt;0&lt;/span&gt;&lt;span style="color: #000000;"&gt;;  </code></pre><p>}</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这个程序可以编译通过，但是运行的话会报错，报错信息如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917175256031-967973584.png" alt=""></p><p>　　要想使这个程序运行起来，需要先对指针 p 进行初始化：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span><span style="color: #000000;">;<br>    </span><span style="color: #0000ff;">int</span> <em>p = &amp;<span style="color: #000000;">x;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);<br>　  </span><em>p = <span style="color: #800080;">2</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这段代码的输出结果如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917212250007-280056505.png" alt="">&nbsp;</p><p>　　可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。&nbsp;</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>3.3 NULL指针</strong></span></p><p>　　<strong>NULL 指针是一个特殊的指针变量，表示不指向任何东西</strong>。可以通过给一个指针赋一个零值来生成一个 NULL 指针。&nbsp;</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> *p =<span style="color: #000000;"> NULL;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">p的地址为%d\n</span><span style="color: #800000;">“</span><span style="color: #000000;">,p);<br>}</span></p><p><span style="color: #008000;">/*</span><span style="color: #008000;"><strong><strong><strong>**</strong></strong></strong></span></p><ul><li>程序输出：</li><li>p的地址为0<br><strong><strong><strong>**</strong></strong></strong><span style="color: #008000;">*/</span></li></ul></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明改指针不指向一个可访问的内存位置。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>四、指针的运算</strong></span></p><p>　　C 指针的算术运算只限于两种形式：</p><p>1） 指针 +/- 整数 ：</p><p>　　 可以对指针变量 p 进行 p++、p--、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下：</p><p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180921154218407-1813012241.png" alt=""></p><p>　　在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。举个例子：</p><p>&nbsp;</p><p>2）指针 - 指针</p><p>　　只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">10</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">7</span>,<span style="color: #800080;">8</span>,<span style="color: #800080;">9</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> sub;<br>    </span><span style="color: #0000ff;">int</span> *p1 = &amp;a[<span style="color: #800080;">2</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span> *p2 = &amp;a[<span style="color: #800080;">8</span><span style="color: #000000;">];<br>    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>五、指针与数组</strong></span></p><p>　　在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。</p><p><span style="font-size: 18px;"><strong>5.1 指针与数组的关系</strong></span></p><p>　　我们先声明一个数组：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">10</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个int类型的数组，这个数组有10个元素</span></pre></div><p>　　我们可以用 a[0]、a[1]、...、a[9] 来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。</p><p>　　接下来，我们再声明一个指针：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p;           <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个int类型的指针变量</span></pre></div><p>　　 p 是一个指针变量，指向内存中的一个区域。如果我们对指针 p 做如下的初始化：</p><div class="cnblogs_code"><pre>p = &amp;a[<span style="color: #800080;">0</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0]</span></pre></div><p>　　我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即 *(p + 1) 将指向 a[1] ；同样的， *(p + i) 将指向 a[i] 。因此，我们可以使用该指针来遍历数组 a[10] 的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，<strong>数组类型的变量或表达式的值是该数组第 1 个元素的地址</strong>，且数组名所代表的的就是该数组第 1 个元素的地址，故，上述赋值语句可以直接写成：</p><div class="cnblogs_code"><pre>p = a;        <span style="color: #008000;">//</span><span style="color: #008000;"> a 为数组名，代表该数组最开始的一个元素的地址</span>&nbsp;</pre></div><p>　　很显然，<strong>一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，<em>指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址</em>，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span>                                                                          <p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> x[<span style="color: #800080;">10</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">7</span>,<span style="color: #800080;">8</span>,<span style="color: #800080;">9</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};<br>    </span><span style="color: #0000ff;">int</span> <em>p =<span style="color: #000000;"> x;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">x的地址为：%p\n</span><span style="color: #800000;">“</span><span style="color: #000000;">,x);<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">x[0]的地址为：%p\n</span><span style="color: #800000;">“</span>,&amp;x[<span style="color: #800080;">0</span><span style="color: #000000;">]);<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">p的地址为：%p\n</span><span style="color: #800000;">“</span>,&amp;p);　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 打印指针 p 的地址，并不是指针所指向的地方的地址</span><br><span style="color: #000000;"><br>    p </span>+= <span style="color: #800080;">2</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;"></span></em>(p+2)的值为：%d\n<span style="color: #800000;">“</span>,<em>p);　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为 3，</span></em>(p+2)指向了 x[2]<br>}</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　结果如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918160417548-189120951.png" alt=""></p><p>　　可以看到，&nbsp;x 的值与 x[0] 的地址是一样的，也就是说数组名即为数组中第 1 个元素的地址。实际上，打印 &amp;x 后发现，x 的地址也是这个值。而 x 的地址与指针变量 p 的地址是不一样的。故而数组和指针并不能完全等价。</p><p>（笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015 编译运行的话，则输出结果是一个 8位的十六进制数，也就是32位二进制，寻址空间为 4GB）&nbsp;</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>5.2 指针数组</strong></span></p><p>　　指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 <strong>指针数组是一个数组，数组中的每一个元素都是指针</strong>。声明一个指针数组的方法如下：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p[<span style="color: #800080;">10</span>];    <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针</span></pre></div><p>　　在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 *p[i]，而 <strong>p[i] 是一个指针</strong>。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>5.3 数组指针</strong></span></p><p>　　<strong>数组指针是一个指针，它指向一个数组</strong>。声明一个数组指针的方法如下：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> (*p)[<span style="color: #800080;">10</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个数组指针 p ，该指针指向一个数组</span></pre></div><p>　　由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre> #include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>     </span><span style="color: #0000ff;">int</span> arr[<span style="color: #800080;">2</span>][<span style="color: #800080;">3</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>};               <span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个二维数组并初始化</span><br>     <span style="color: #0000ff;">int</span> (<em>p)[<span style="color: #800080;">3</span>];                                 <span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个数组指针，指针指向一个含有3个元素的一维数组</span><br><span style="color: #000000;"><br>     p </span>= arr;                                     <span style="color: #008000;">//</span><span style="color: #008000;"> 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0]</span><br>     printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,(</em>p)[<span style="color: #800080;">0</span>]);　　　　　　　　　　　　  <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为 1</span><br>     p++;　　　　　　　　　　　　　　　　　　　　　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0]</span><br>     printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,(*p)[<span style="color: #800080;">1</span>]);                      <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为5</span><br> }&nbsp;</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>六、指针与结构</strong></span></p><p><span style="font-size: 18px;"><strong>6.1 简单介绍一下结构</strong></span></p><p>　　结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre><span style="color: #0000ff;">struct</span> message{　　　　　　      <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个结构 message</span>    <span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span>];             <span style="color: #008000;">//</span><span style="color: #008000;"> 成员</span>    <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;  };<p>typedef </p></span><span style="color: #0000ff;">struct</span> message s_message;　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 类型定义符 typedef</span><br><span style="color: #000000;"><br>s_message mess </span>= {<span style="color: #800000;">“</span><span style="color: #800000;">tongye</span><span style="color: #800000;">“</span>,<span style="color: #800080;">23</span>,<span style="color: #800080;">83</span>};　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 struct message 类型的变量 mess,并对其进行初始化　</span><br><br>————————————————————————————————————–<br><span style="color: #008000;">/*</span><span style="color: #008000;"> 另一种更简便的声明方法 </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br>typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span><span style="color: #000000;">];<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> age;<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;<br>}message;</span></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　可以使用 <strong>结构名.成员</strong> 的方式来访问结构中的成员，如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>　　printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">“</span>,mess.name);　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果：tongye</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,mess.age);　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果：23</span></p><p>　　<span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>6.2 结构指针</strong></span>　</p><p>　　结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：</p><div class="cnblogs_code"><pre>s_message *p;        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构</span>*p = &amp;mess;　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp;</span></pre></div><p>　　C语言中使用 -&gt; 操作符来访问结构指针的成员，举个例子：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><span style="color: #000000;"><p>typedef </p></span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{<br>    </span><span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> age;<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;<br>}message;<p></p><p></p></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    message mess </span>= {<span style="color: #800000;">“</span><span style="color: #800000;">tongye</span><span style="color: #800000;">“</span>,<span style="color: #800080;">23</span>,<span style="color: #800080;">83</span><span style="color: #000000;">};<br>    message </span>*p = &amp;<span style="color: #000000;">mess;<br>}</span>&nbsp;</pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>七、指针与函数</strong></span></p><p>　　<strong>C语言的所有参数均是以“传值调用”的方式进行传递的</strong>，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。&nbsp;</p><p><span style="font-size: 18px;"><strong>7.1 指针作为函数的参数</strong></span></p><p>　　传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值。</strong>用一个例子来说明：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">void</span> swap1(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b)　　　　　　  <span style="color: #008000;">//</span><span style="color: #008000;"> 参数为普通的 int 变量</span><br><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> temp;<br>　　temp </span>=<span style="color: #000000;"> a;<br>　　a </span>=<span style="color: #000000;"> b;<br>　　b </span>=<span style="color: #000000;"> temp;<br>}</span></p><p><span style="color: #0000ff;">void</span> swap2(<span style="color: #0000ff;">int</span> <em>a,<span style="color: #0000ff;">int</span> *b)　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作</span><br><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">int</span> temp;　　　　                <span style="color: #008000;">//</span><span style="color: #008000;"> 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化</span><br>　　temp = *<span style="color: #000000;">a;<br>　　</span></em>a = *<span style="color: #000000;">b;<br>　　</span>*b =<span style="color: #000000;"> temp;<br>}</span></p><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br>{<br>　　</span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span>,y = <span style="color: #800080;">2</span><span style="color: #000000;">;<br>　　swap1(x,y);                     </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x,y 的值本身作为参数传递给了被调函数</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d %5d\n</span><span style="color: #800000;">“</span>,x,y);         <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为：1     2</span><br><span style="color: #000000;"><br>　　swap(</span>&amp;x,&amp;y);                    <span style="color: #008000;">//</span><span style="color: #008000;"> 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d %5d\n</span><span style="color: #800000;">“</span>,x,y);         <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为：2     1</span><br>　　<span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>7.2 指向函数的指针</strong></span></p><p>　　在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。&nbsp;声明一个函数指针的方法如下：</p><div class="cnblogs_code"><pre>返回值类型 （*<span style="color: #000000;"> 指针变量名）（[形参列表]）;<p></p></span><span style="color: #0000ff;">int</span> (*pointer)(<span style="color: #0000ff;">int</span> *,<span style="color: #0000ff;">int</span> *);        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数指针</span></pre><p></p></div><p>　　上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><span style="color: #000000;">#include </span><span style="color: #800000;">"</span><span style="color: #800000;">string.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span> str_comp(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> <em>m,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> <em>n);                             <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型</span><br><span style="color: #0000ff;">void</span> comp(<span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *b,<span style="color: #0000ff;">int</span> (</em>prr)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span></em>));       <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针</span></p><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br>{<br>    </span><span style="color: #0000ff;">char</span> str1[<span style="color: #800080;">20</span>];      <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个字符数组</span><br>    <span style="color: #0000ff;">char</span> str2[<span style="color: #800080;">20</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span> (*p)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *) = str_comp;　　　　　　　　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型</span><br>    gets(str1);         <span style="color: #008000;">//</span><span style="color: #008000;"> 使用 gets() 函数从 I/O 读取一行字符串</span><br><span style="color: #000000;">    gets(str2);<br>    comp(str1,str2,p);  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 函数指针 p 作为参数传给 comp 函数</span><br>}</p><p><span style="color: #0000ff;">int</span> str_comp(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *m,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">n)<br>{<br>　　 </span><span style="color: #008000;">//</span><span style="color: #008000;"> 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2);</span><br>    <span style="color: #0000ff;">if</span>(strcmp(m,n) == <span style="color: #800080;">0</span><span style="color: #000000;">)<br>        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>    </span><span style="color: #0000ff;">else</span><br>        <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;<br>}</span></p><p><span style="color: #008000;">/*</span><span style="color: #008000;"> 函数 comp 接受一个函数指针作为它的第三个参数 </span><span style="color: #008000;"><em>/</em></span><br><span style="color: #0000ff;">void</span> comp(<span style="color: #0000ff;">char</span> <em>a,<span style="color: #0000ff;">char</span> *b,<span style="color: #0000ff;">int</span> (</em>prr)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span><span style="color: #000000;">))<br>{<br>    </span><span style="color: #0000ff;">if</span>((*prr)(a,b) == <span style="color: #800080;">0</span><span style="color: #000000;">)<br>        printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">str1 = str2\n</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br>        printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">str1 != str2\n</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>} </span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。</p><p>　　注意，声明一个函数指针时，() 不能漏掉，否则：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p(<span style="color: #0000ff;">void</span> *,<span style="color: #0000ff;">void</span>*);</pre></div><p>　　这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。</p><p>&nbsp;</p><p>参考文献：</p><p>1）C程序设计语言（第2版）</p><p>2）C和指针</p><p>&nbsp;</p><p>参考：</p><p><a href="https://blog.csdn.net/soonfly/article/details/51131141" target="_blank">https://blog.csdn.net/soonfly/article/details/51131141</a></p><p><a href="https://www.cnblogs.com/lulipro/p/7460206.html" target="_blank">https://www.cnblogs.com/lulipro/p/7460206.html</a></p></div></h1></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://lufeifan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序学习第二天</title>
    <link href="https://lufeifan.github.io/2019/09/07/wxml2/"/>
    <id>https://lufeifan.github.io/2019/09/07/wxml2/</id>
    <published>2019-09-07T05:09:24.590Z</published>
    <updated>2019-09-07T12:07:10.324Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h6 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h6><pre><code>添加 scroll-x就可看到滑动</code></pre><h2 id="理解display"><a href="#理解display" class="headerlink" title="理解display"></a>理解display</h2><pre><code>display: flex;display: inline-block;</code></pre><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><pre><code>属性：flex-direction:row/column 行或列</code></pre><p>问题：<br>white-space: nowrap;<br> justify-content: center;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://lufeifan.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序学习第一天</title>
    <link href="https://lufeifan.github.io/2019/09/06/wxml1/"/>
    <id>https://lufeifan.github.io/2019/09/06/wxml1/</id>
    <published>2019-09-06T12:36:17.421Z</published>
    <updated>2019-09-07T12:14:49.653Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><pre><code>pages    index        index.js    Pages({})        index.json  可以设置顶部文字和颜色        index.wxml  相当于html        index.wxss  相当于cssapp.jsapp.json    导入页面的文件app.wxss    设置全局样式</code></pre><h4 id="设置顶部"><a href="#设置顶部" class="headerlink" title="设置顶部"></a>设置顶部</h4><pre><code>"navigationBarTitleText": "String" 顶部文字"navigationBarBackgroundColor": "color", 顶部颜色"navigationBarTextStyle": "black" 仅支持白色和黑色"enablePullDownRefresh": false, //是否开启下拉刷新</code></pre><h4 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h4><pre><code>在swiper标签加swiper-item，swiper-item就是每一页的内容幻灯片小圆点:indicator-dots="true"current,记录当前页面的index</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://lufeifan.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>windows安装虚拟机</title>
    <link href="https://lufeifan.github.io/2019/09/01/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://lufeifan.github.io/2019/09/01/虚拟机/</id>
    <published>2019-09-01T11:48:14.695Z</published>
    <updated>2019-09-01T11:55:21.248Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>下载VMware Workstation，CentOS<br>在VMware Workstation中安装CentOS镜像<br>配置跟着里面安装就行</p><blockquote><p>在CentOS中还可以安装图形化界面</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>行列式</title>
    <link href="https://lufeifan.github.io/2019/09/01/%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>https://lufeifan.github.io/2019/09/01/行列式/</id>
    <published>2019-09-01T11:18:04.350Z</published>
    <updated>2019-09-01T11:59:45.145Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h5 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h5><pre><code>n个数就是n阶排列</code></pre><h5 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h5><pre><code>前面的数比后面的小</code></pre><h5 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h5><pre><code>前面的数比后面的大</code></pre><h5 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h5><pre><code>两种判断方法：    1.一个排列中前面的数比他大的有几个，总和    2.一个排列中前面的数比他小的有几个，总和</code></pre><blockquote><p>总和为奇数就是奇排列，为偶数就是偶排列</p></blockquote><blockquote><p>行列式的计算：其实可以观察矩阵用连线来记住，多少阶就一次连多少个数字，都具有一定的规律，<code>\</code>这样连线数据是想加，<code>/</code>再减去这样连线的数据就得到结果。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="线性代数" scheme="https://lufeifan.github.io/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>豆瓣插件</title>
    <link href="https://lufeifan.github.io/2019/09/01/%E8%B1%86%E7%93%A3%20%E6%8F%92%E4%BB%B6%E7%88%AC%E5%8F%96%E5%A4%B1%E8%B4%A5/"/>
    <id>https://lufeifan.github.io/2019/09/01/豆瓣 插件爬取失败/</id>
    <published>2019-09-01T05:56:24.776Z</published>
    <updated>2019-09-01T11:46:27.440Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>user 在登录豆瓣个人中心网址上面的那串数字title 突入你想填的就行quote 用来浏览器F12取消一小段爬取那部分的html</code></pre><h4 id="豆瓣插件爬取失败"><a href="#豆瓣插件爬取失败" class="headerlink" title="豆瓣插件爬取失败"></a>豆瓣插件爬取失败</h4><p>使用： hexo douban -updata<br>       hexo g<br>       hexo s<br>就可以看到爬取效果</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote><p>上传的时候不能用hexo d 只能用<code>hexo deploy</code></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lufeifan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>人物模型</title>
    <link href="https://lufeifan.github.io/2019/08/24/live2d%E4%BA%BA%E7%89%A9%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lufeifan.github.io/2019/08/24/live2d人物模型/</id>
    <published>2019-08-24T02:07:17.168Z</published>
    <updated>2019-09-01T11:37:37.871Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>1.站点配置文件下Git运行:npm install –save hexo-helper-live2d<br>2.站点配置文件写下（主题配置文件下不生效）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 添加萌妹子效果</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local  </span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko    //模型名字</span><br><span class="line">  display:    </span><br><span class="line">    position: right   //位置</span><br><span class="line">    width: 150    //妹子宽度</span><br><span class="line">    height: 300    //妹子高度</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></tbody></table></figure><p>更多模型：<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a><br>更换模型 npm install 模型名称</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lufeifan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>java文件输入输出流</title>
    <link href="https://lufeifan.github.io/2019/08/23/%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/"/>
    <id>https://lufeifan.github.io/2019/08/23/文件的读写/</id>
    <published>2019-08-23T05:37:52.750Z</published>
    <updated>2019-08-23T06:13:32.498Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><p>输入：<code>InputStream</code><br>read()方法：-1表示无</p></li><li><p>输出: <code>OutputStream</code><br>write()方法</p></li></ul><hr><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li>输入: <code>Reader</code></li><li>输出: <code>Writer</code></li></ul><hr><h3 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h3><ul><li>输入<code>FileInputStream</code></li><li>输出:<code>FileOutputStream</code></li></ul><hr><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>  输入：<code>BufferdReader</code><br>  输出：<code>BufferdWriter</code></p><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>  序列化：ObjectInputStream<br>  反序列化：ObjectOutputStream<br>  <span style="color: red">要求对象实现Serializable接口</span></p><hr><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p><img src="http://pwmvr65mz.bkt.clouddn.com/201908231353_863.png" alt="常用的操作"><br><img src="http://pwmvr65mz.bkt.clouddn.com/201908231355_407.png" alt="常用的处理流"></p><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>文件的操作要进行错误处理</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lufeifan.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>实用推荐</title>
    <link href="https://lufeifan.github.io/2019/08/23/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <id>https://lufeifan.github.io/2019/08/23/网站推荐/</id>
    <published>2019-08-23T03:34:07.080Z</published>
    <updated>2019-09-07T05:17:58.959Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><ul><li>1.在线平面设计 <a href="https://www.fotor.com.cn" target="_blank" rel="noopener">https://www.fotor.com.cn</a></li><li>2.<a href="https://pixabay.com/zh/" target="_blank" rel="noopener">https://pixabay.com/zh/</a></li><li>3.<a href="https://www.pexels.com/zh-cn/" target="_blank" rel="noopener">https://www.pexels.com/zh-cn/</a><h3 id="小图标"><a href="#小图标" class="headerlink" title="小图标"></a>小图标</h3> <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">https://fontawesome.com/v4.7.0/icons/</a><h3 id="截图推荐"><a href="#截图推荐" class="headerlink" title="截图推荐"></a>截图推荐</h3> snipaste:能将图片贴在屏幕，很好地观察，快捷键：快速截屏F1,快速贴图F3,退出贴图shift+Esc。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows安装MySQL</title>
    <link href="https://lufeifan.github.io/2019/08/23/Windows%20%E4%B8%8A%E5%AE%89%E8%A3%85%20MySQL/"/>
    <id>https://lufeifan.github.io/2019/08/23/Windows 上安装 MySQL/</id>
    <published>2019-08-23T01:54:15.699Z</published>
    <updated>2019-08-23T02:38:58.899Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>1.下载<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">最新版本</a><br>2.<img src="http://pwmvr65mz.bkt.clouddn.com/201908231000_464.png" alt="如图"><br>3.<img src="http://pwmvr65mz.bkt.clouddn.com/201908231002_844.png" alt="如图"><br>4.安装MySQL<br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231020_317.png" alt="安装模式"><br> 更改地址<img src="http://pwmvr65mz.bkt.clouddn.com/201908231023_822.png" alt="更改地址"><br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231024_793.png" alt=""><br> <img src="http://pwmvr65mz.bkt.clouddn.com/201908231032_70.png" alt=""><br> 然后一点击下一步就可以<br>5.运行MySQL<img src="http://pwmvr65mz.bkt.clouddn.com/201908231035_680.png" alt="运行MySQL"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://lufeifan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>七牛云截屏上传返回图片地址</title>
    <link href="https://lufeifan.github.io/2019/08/22/%E4%B8%83%E7%89%9B%E4%BA%91%E6%88%AA%E5%B1%8F%E4%B8%8A%E4%BC%A0/"/>
    <id>https://lufeifan.github.io/2019/08/22/七牛云截屏上传/</id>
    <published>2019-08-22T14:09:08.556Z</published>
    <updated>2019-08-22T14:24:49.691Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.到<a href="https://github.com/jiwenxing/qimage-win/releases" target="_blank" rel="noopener">github</a>下载release版本</p></li><li><p>2.打开release中的 <code>settings.ini</code> 文件</p></li><li><p>3.去七牛云找到密匙填写<img src="http://pwmvr65mz.bkt.clouddn.com/201908222218_401.png" alt="密匙"> </p></li><li><p>4.BUCKET_NAME：储存空间的名称</p></li><li><p>5BUCKET_DOMAIN：你自己的域名</p></li><li><p>6.UP_HOST = <a href="http://up-z2.qiniup.com" target="_blank" rel="noopener">http://up-z2.qiniup.com</a></p></li><li><p>7.DEBUG_MODE：调试开关，截屏上传失败可以把false改为true</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="markdown" scheme="https://lufeifan.github.io/categories/markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>鼠标点击特效</title>
    <link href="https://lufeifan.github.io/2019/08/21/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%86%E7%82%B8%E6%95%88%E6%9E%9C/"/>
    <id>https://lufeifan.github.io/2019/08/21/鼠标点击爆炸效果/</id>
    <published>2019-08-21T08:53:07.782Z</published>
    <updated>2019-08-21T09:18:16.453Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.主题配置文件找 <code>layout</code> 文件夹中的 <code>_layout.swig</code>在body中加入</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{% if theme.fireworks %}</span><br><span class="line">   &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; </span><br><span class="line">   &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; </span><br><span class="line">   &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;</span><br><span class="line">  {% endif %}</span><br></pre></td></tr></tbody></table></figure></li><li><p>2.主题配置文件找<code>source</code> 文件夹中的 <code>js</code>新建src文件夹，在src新建fireworks.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)}"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)};</span><br></pre></td></tr></tbody></table></figure></li><li><p>3.主题配置文件末尾加入：</p><pre><code># Fireworksfireworks: true</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lufeifan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA面向对象（2)</title>
    <link href="https://lufeifan.github.io/2019/08/21/java2/"/>
    <id>https://lufeifan.github.io/2019/08/21/java2/</id>
    <published>2019-08-21T08:46:43.225Z</published>
    <updated>2019-08-23T06:15:47.820Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>类的组成：变量，方法，构造方法</li><li>构造方法：与类同名，不返回数字类型</li><li>方法<ul><li>实例方法</li><li>静态方法 </li><li>方法重载：该方法有多个名字但参数的个数和类型不同，可以用来实现<span style="color: red">多态</span></li></ul></li><li>变量：<ul><li>实例变量</li><li>静态变量</li></ul></li><li>类的对象：可以访问类中的方法</li><li>继承：<ul><li>声明 子类 extends 父类</li><li>继承父类的变量和方法</li><li>可以修改父类的变量和方法，还可以添加自己的变量和方法，名字相同就会进行覆盖和修改</li><li>关键字：this表示该类的对象</li><li>super：<span style="color: red">必须放在第一句</span>用于访问父类的变量和方法（一般用于同名），可用来调用父类的构造方法</li><li>父类对象和子类对象的转换（好像是上转型对象）</li></ul></li></ul><hr><h3 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h3><ul><li>import用于导入其他类，放在文件的首位</li><li>同包类可以相互访问,反之不得</li></ul><hr><h3 id="控制符"><a href="#控制符" class="headerlink" title="控制符"></a>控制符</h3><ul><li>static</li><li>final</li><li>abstract</li><li></li><li></li></ul><hr><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>  定义接口：interface<br>  实现接口：implements<br>  调用接口则接口中的所有方法必须重写<br>  可以实现多继承<br>  接口定义的常量具有final，static，public属性</p><hr><p><img src="http://pwmvr65mz.bkt.clouddn.com/201908231331_490.png" alt="完整的类定义"><br><img src="http://pwmvr65mz.bkt.clouddn.com/201908231333_501.png" alt="完整的接口定义"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lufeifan.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA面向对象（1)</title>
    <link href="https://lufeifan.github.io/2019/08/21/java1/"/>
    <id>https://lufeifan.github.io/2019/08/21/java1/</id>
    <published>2019-08-21T07:34:17.216Z</published>
    <updated>2019-08-23T06:14:45.112Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>整数型<ul><li>进制的表示</li></ul></li><li>浮点数型<ul><li>注意单精度的书写要加f</li></ul></li><li>逻辑型—boolean</li><li>字符型—char</li><li>数据类型的转换</li></ul><hr><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>可以由数字，字母，下划线_,美元符号$组成</li><li>不能以数字开头</li><li>通常类名开头要大写（java大小写敏感）</li><li>其余的小写字母开头</li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组的创建<ul><li>数组的声明 <code>int []a;</code>(不能声明数组的长度)</li><li>为数组分配内存空间 <code>a=new[5]</code></li><li>数组的定义</li></ul></li><li>数组的引用类型<br><code>int []a=new int[5]</code><br>这里的a就是引用</li><li>数组默认初始化为0或者null</li><li>数组的遍历：</li><li>简单的循环语句</li><li>也可以用for(int age;age){}只读遍历</li><li>数组长度：数组名.length 可以获取</li><li>数组的复制：Array.Copy<br></li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lufeifan.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>视频嵌入</title>
    <link href="https://lufeifan.github.io/2019/08/20/%E8%A7%86%E9%A2%91/"/>
    <id>https://lufeifan.github.io/2019/08/20/视频/</id>
    <published>2019-08-20T04:48:57.358Z</published>
    <updated>2019-08-20T07:00:02.285Z</updated>
    
    <content type="html"><![CDATA[<iframe width="100%" height="350" src="//player.bilibili.com/player.html?aid=62244859&amp;cid=108194807&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><a id="more"></a><hr><iframe width="100%" height="350" frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=k0029f52ciy" allowfullscreen="true"></iframe><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;iframe width=&quot;100%&quot; height=&quot;350&quot; src=&quot;//player.bilibili.com/player.html?aid=62244859&amp;amp;cid=108194807&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
    
    </summary>
    
      <category term="外接嵌入" scheme="https://lufeifan.github.io/categories/%E5%A4%96%E6%8E%A5%E5%B5%8C%E5%85%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>pr</title>
    <link href="https://lufeifan.github.io/2019/08/20/Pr/"/>
    <id>https://lufeifan.github.io/2019/08/20/Pr/</id>
    <published>2019-08-20T02:50:43.636Z</published>
    <updated>2019-08-21T01:25:00.156Z</updated>
    
    <content type="html"><![CDATA[<hr><p>教程推荐 :<a href="https://www.bilibili.com/video/av5540953/?p=9" target="_blank" rel="noopener">https://www.bilibili.com/video/av5540953/?p=9</a></p><a id="more"></a><ul><li>画面放大缩小： 双击预览视频区</li><li>弹幕制作： 使用默认静态字幕<pre><code>弹幕效果：使用关键帧 -- 运动 设置关键帧的开始和结束位置（&lt;span style="color: red"&gt;记得打点&lt;/span&gt;）</code></pre></li><li>视频速度：右键更改速度比例(鬼畜)</li><li>视频的衔接：左侧工具栏找到 <span style="color: red">- 视频过度</span></li><li>视频结尾：使用关键帧 – 运动 设置关键帧的开始和结束位置（记得打点）</li><li>导出：<span style="color: red">h.264</span></li></ul><hr><ul><li>视频转场：<br>  1.全选素材<br>  2.Ctrl+d<br>  3.转场素材可去设置默认</li><li>批量缩放素材：<br>  找到首选项中的默认媒体缩放设置为<span style="color: red"> 帧大小</span></li><li>批量调色：<br>  1.效果控件将颜色复制在删掉<br>  2.找到只要进行粘贴</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;教程推荐 :&lt;a href=&quot;https://www.bilibili.com/video/av5540953/?p=9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/av5540953/?p=9&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="剪辑软件" scheme="https://lufeifan.github.io/categories/%E5%89%AA%E8%BE%91%E8%BD%AF%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>音乐载入</title>
    <link href="https://lufeifan.github.io/2019/08/19/%E9%9F%B3%E4%B9%90/"/>
    <id>https://lufeifan.github.io/2019/08/19/音乐/</id>
    <published>2019-08-19T13:56:09.136Z</published>
    <updated>2019-08-20T06:56:30.289Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&amp;id=2946604834&amp;auto=0&amp;height=430"></iframe><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="外接嵌入" scheme="https://lufeifan.github.io/categories/%E5%A4%96%E6%8E%A5%E5%B5%8C%E5%85%A5/"/>
    
    
  </entry>
  
</feed>
