<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陆陆陆啊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lululua.cn/"/>
  <updated>2019-10-10T14:00:15.719Z</updated>
  <id>https://lululua.cn/</id>
  
  <author>
    <name>陆陆陆啊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL基础知识</title>
    <link href="https://lululua.cn/2019/10/10/SQl%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://lululua.cn/2019/10/10/SQl基础知识/</id>
    <published>2019-10-10T13:27:09.159Z</published>
    <updated>2019-10-10T14:00:15.719Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h4><pre><code>CREATE TABLE &lt;表名&gt;(    &lt;列名&gt;[列级完整性约束],    &lt;列名&gt;[列级完整性约束],    [表级完整性约束]；    )数据类型:...</code></pre><h4 id="模式和表"><a href="#模式和表" class="headerlink" title="模式和表"></a>模式和表</h4><pre><code>CREATE TABLE "S-T".&lt;表名&gt;(...);</code></pre><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><pre><code>ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt;]</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://lululua.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>java二级</title>
    <link href="https://lululua.cn/2019/09/10/java%E4%BA%8C%E7%BA%A7/"/>
    <id>https://lululua.cn/2019/09/10/java二级/</id>
    <published>2019-09-10T10:20:08.729Z</published>
    <updated>2019-08-26T13:38:59.530Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="一、Java的历史、现状"><a href="#一、Java的历史、现状" class="headerlink" title="一、Java的历史、现状"></a>一、Java的历史、现状</h1><h2 id="1-Java历史"><a href="#1-Java历史" class="headerlink" title="1.Java历史"></a>1.Java历史</h2><p>在上世纪90年代初，sun公司有一个叫做Green的项目，目的是为家用消费电子产品开发一个分布式代码系统，这样就可以对家用电器进行控制，和它们进行信息交流。詹姆斯·高斯林(JamesGosling)等人基于C++开发一种新的语言Oak(Java的前身)。Oak是一种用于网络的精巧而安全的语言。Sun公司曾依此投标一个交互式电视项目，但结果是被SGI打败，Sun打算抛弃Oak。随着互联网的发展，Sun看到了Oak在计算机网络上的广阔应用前景，于是改造Oak，在1995年5月以“Java”的名称正式发布，从此Java走上繁荣之路。</p><p>当然提到Java历史，不得不提的一个故事就是Java的命名。开始“Oak”的命名是以项目小组办公室外的树而得名，但是Oak商标被其他公司注册了，必须另外取一个名字，传说有一天，几位Java成员组的会员正在讨论给这个新的语言取什么名字，当时他们正在咖啡馆喝着Java(爪哇)咖啡，有一个人灵机一动说就叫Java怎样，得到了其他人的赞同，于是，Java这个名字就这样传开了。当然对于传说，了解一下就好了，不必过于认真。</p><h2 id="2-Java"><a href="#2-Java" class="headerlink" title="2.Java"></a>2.Java</h2><p>作为学习Java的人士，对Java历史上发生的大事件有一个了解是应该的。</p><p>JDK(JavaSoftwareDevelopKit))：Java软件开发工具包。JDK是Java的核心，包括了Java运行环境，一系列Java开发工具和Java基础的类库。目前主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了自己的JDK，例如IBM公司开发的JDK，BEA公司的Jrocket，还有GNU组织开发的JDK等等。</p><p>​                                                  </p><h2 id="3-Java特点"><a href="#3-Java特点" class="headerlink" title="3.Java特点"></a>3.Java特点</h2><p>简单地说，Java具有如下特点：简单的、面向对象、平台无关、多线程、分布式、安全、高性能、可靠的、解释型、自动垃圾回收等特点。</p><p>这里只解释一下平台无关和分布式，其余的在后面会逐步接触到。</p><h3 id="3-1平台无关"><a href="#3-1平台无关" class="headerlink" title="3.1平台无关"></a>3.1平台无关</h3><p>所谓平台无关指的是：用Java写的程序不用修改就可在不同的软硬件平台上运行。这样就能实现同样的程序既可以在Windows下运行，到了Unix或者Linux环境不用修改就直接可以运行了。Java主要靠Java虚拟机(JVM)实现平台无关性。</p><p>平台无关性就是一次编写，到处运行：Write Once, Run Anywhere</p><h3 id="3-2分布式"><a href="#3-2分布式" class="headerlink" title="3.2分布式"></a>3.2分布式</h3><p>分布式指的是：软件由很多个可以独立执行的模块组成，这些模块被分布在多台计算机上，可以同时运行，对外看起来还是一个整体。也就是说，分布式能够把多台计算机集合起来就像一台计算机一样，从而提供更好的性能。</p><h2 id="4-Java标准组织——JCP"><a href="#4-Java标准组织——JCP" class="headerlink" title="4.Java标准组织——JCP"></a>4.Java标准组织——JCP</h2><p>JCP(Java Community Process) 是一个开放的国际组织，成立于 1995 年，主要职能是发展和更新 Java 技术规范、参考实现(RI) 、技术兼容包(TCK) 。Java 技术和 JCP 两者的原创者都是 SUN 计算机公司。组织成员可以提交 JSR(Java Specification Requests) ，通过讨论、认可、审核以后，将进入到下一版本的规范里面。</p><p>也就是说 JCP 是目前 Java 技术发展事实上的控制者和领领导者。</p><h1 id="二、Java从代码到运行"><a href="#二、Java从代码到运行" class="headerlink" title="二、Java从代码到运行"></a>二、Java从代码到运行</h1><p><strong>用一个图来描述这个过程会比较容易理解：</strong></p><h2 id="1-编写代码"><a href="#1-编写代码" class="headerlink" title="1.编写代码"></a>1.编写代码</h2><p>首先把我们想要计算机做的事情，通过 Java 表达出来，写成 Java 文件，这个过程就是编写代码的过程。如上图所示的 Hello.java 文件。</p><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h2><p>写完 Java 代码后，机器并不认识我们写的 Java 代码，需要进行编译成为字节码，编译后的文件叫做 class 文件。如上图所示的 Hello.class 文件。</p><h2 id="3-类装载ClassLoader"><a href="#3-类装载ClassLoader" class="headerlink" title="3.类装载ClassLoader"></a>3.类装载ClassLoader</h2><p>类装载的功能是为执行程序寻找和装载所需要的类。</p><p>ClassLoader能够加强代码的安全性，主要方式是：把本机上的类和网络资源类相分离， 在调入类的时候进行检查，因而可以限制任何“特洛伊木马”的应用。</p><h2 id="4-字节码-byte-code-校验"><a href="#4-字节码-byte-code-校验" class="headerlink" title="4.字节码(byte-code)校验"></a>4.字节码(byte-code)校验</h2><p>功能是对 class 文件的代码进行校验，保证代码的安全性。</p><p>Java 软件代码在实际运行之前要经过几次测试。JVM 将代码输入一个字节码校验器以测试代码段格式并进行规则检查–检查伪造指针、 违反对象访问权限或试图改变对象类型的非法代码。</p><p>注意—-所有源于网络的类文件都要经过字节码校验器字节码校验器对程序代码进行四遍校验， 这可以保证代码符合JVM 规范并且不破坏系统的完整性。如果校验器在完成四遍校验后未返回出错信息，则下列各点可被保证：</p><p>- 类符合JVM规范的类文件格式</p><p>- 无访问限制异常</p><p>- 代码未引起操作数栈上溢或下溢</p><p>- 所有操作代码的参数类型将总是正确的</p><p>- 无非法数据转换发生，如将整数转换为对象引用</p><p>- 对象域访问是合法的</p><h2 id="5-解释-Interpreter"><a href="#5-解释-Interpreter" class="headerlink" title="5.解释(Interpreter)"></a>5.解释(Interpreter)</h2><p>可是机器也不能认识 class 文件，还需要被解释器进行解释，机器才能最终理解我们所要表达的东西。</p><h2 id="6-运行"><a href="#6-运行" class="headerlink" title="6.运行"></a>6.运行</h2><p>最后由运行环境中的 Runtime 对代码进行运行，真正实现我们想要机器完成的工作。</p><h2 id="7-说明"><a href="#7-说明" class="headerlink" title="7.说明"></a>7.说明</h2><p>由上面的讲述，大家看到，Java通过一个编译阶段和一个运行阶段，来让机器最终理解我们想要它完成的工作，并按照我们的要求进行运行。</p><p>在这两个阶段中，需要我们去完成的就是编译阶段的工作，也就是说：我们需要把我们想要机器完成的工作用 Java 语言表达出来，写成 Java 源文件，然后把源文件进行编译，形成 class 文件， 最后就可以在 Java 运行环境中运行了。 运行阶段的工作由 Java 平台自身提供，我们不需要做什么工作。</p><h1 id="三、Java程序设计基础"><a href="#三、Java程序设计基础" class="headerlink" title="三、Java程序设计基础"></a>三、Java程序设计基础</h1><h2 id="1-Java编程概况"><a href="#1-Java编程概况" class="headerlink" title="1**.Java编程概况**"></a><strong>1**</strong>.<strong><strong>Java</strong></strong>编程概况**</h2><p>现在你可以复习一下Java语言的背景材料，它的基本结构象C/C++，但任何用面向过程语言编写过程序的人都可以了解Java语言的大部分结构.</p><h3 id="1-1-程序结构"><a href="#1-1-程序结构" class="headerlink" title="1.1**程序结构**"></a><strong>1.1**</strong>程序结构**</h3><p>Java语言的源程序代码由一个或多个编译单元(compilationunit)组成，每个编译单元只能包含下列内容(空格和注释除外)：<em>一个程序包语句(packagestatement)</em>入口语句(importstatements)<em>类的声明(classdeclarations)</em>界面声明(interfacedeclarations)每个Java的编译单元可包含多个类或界面，但是每个编译单元最多只能有一个类或者界面是公共的。Java的源程序代码被编译后，便产生了Java字节代码。Java的运行系统工作起来如同一台虚拟机。在当前的Java实现中，每个编译单元就是一个以.java为后缀的文件。每个编译单元有若干个类，编译后，每个类生成一个.class文件。.class文件是Java虚拟机能够识别的代码。</p><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2**注释**"></a><strong>1.2**</strong>注释**</h3><p>三种类型如下://注释一行/<em>一行或多行注释</em>//<strong>文档注释</strong>/文档注释一般放在一个变量或函数定义前,指示在任何自动生成文档系统中调入。</p><h3 id="1-3标识符"><a href="#1-3标识符" class="headerlink" title="1.3标识符"></a>1.3标识符</h3><p>变量，函数，类和对象的名称都是标识符，程序员需要标识和使用的东西都需要标识符。在Java语言里,标识符以字符或_,$开头,后面可以包含数字，标识符是大小写有区别的,没有长度限制。</p><p>有效的标识符mynameict_networkHello_sys_path$bill</p><p>例子：inta_number;char_onechar;float$bill;</p><h3 id="1-4数据类型"><a href="#1-4数据类型" class="headerlink" title="1.4数据类型"></a>1.4数据类型</h3><p>Java使用五种基本类型:integer(整数),floating(浮点数),point(指针),Boolean(布尔变量),CharacterorString(字符或字符串)。</p><p>integer整数下边给出的数据表示都是整数的例子：4，15，089，0xAD00整数长度数据类型表示8bitsbyte16bitsshort32bitsint64bitslong</p><p>floating浮点数下边给出的数据表示都是浮点数的例子：6.37，3.7E15，3e8</p><p>浮点数长度数据类型表示32bitsfloat64bitsdouble</p><p>Boolean布尔变量下边是布尔变量的两种可能取值：</p><p>truefalseCharacter字符下边给出的都是字符的例子：a\t(tab)\u????(unicode)</p><p>String字符串下边给出的都是字符串的例子：</p><p>"Thisisastringliteral""中国科学院计算所"数组你可以定义任意类型的数组.chars[];这是字符型数组;int[]array;这是整型数组;你还可以定义数组的数组.intblock[][]=newint[2][3];数组边界在运行时被检测,避免堆栈溢出和内存崩溃.</p><p>在Java里,数组实际上是一个对象,数组有一个成员变量：</p><p>length。你可以用这个成员函数来查看任意数组的长度.inta[][]=newint[10][3]a.length/<em>10</em>/a[0].length/<em>3</em>/创建数组在Java里创建数组,你可使用两种基本方法：</p><p>创建一个空数组：intlist[]=newint[50];或你可以用初始数值填充数组.Stringnames[]={"Chenji","Yuan","Chun","Yang"};</p><p>相当于下面功能：Stringnames[];names=newString[4];names[0]=newString("Chenji");names[1]</p><p>=newString</p><p>("Yuan");names[2]=newString("Chun");names[3]=newString("Yang");在编译时你不能象下例那样创建静态数组。intname[50];//将产生一个编译错误你也不能用new操作去填充一个没定义大小的数组。intname[];for(inti=0;i</p><h3 id="1-5表达式"><a href="#1-5表达式" class="headerlink" title="1.5表达式"></a>1.5表达式</h3><p>Java语言的表达式和C语言非常类似。运算符运算符(operator)优先级从高到底排列如下：.<a href=""></a>++–!～instanceof<em>/%+-\==!=&amp;^&amp;&amp;||?:=op=,整数运算符在整数运算时，如果操作数是long类型，则运算结果是long类型，否则为int类型，绝不会是byte，short或char型。这样，如果变量i被声明为short或byte，i+1的结果会是int。如果结果超过该类型的取值范围，则按该类型的最大值取模。单目整数运算符是：运算符操作-单目非～位补码++加1–减1++运算符用于表示直接加1操作。增量操作也可以用加运算符和赋值操作间接完成。++lvalue(表示lvalue+=1,++lvalue也表示lvalue=lvalue+1(只要lvalue没有副作用)。–运算符用于表示减1操作。++和–运算符既可以作为前缀运算符，也可以做为后缀运算符。双目整数运算符是：运算符操作*</em>+加-减*乘/除%取模&amp;位与|位或^位异或=，==和!=产生boolean类型的数据。</p><p>布尔运算符布尔(boolean)变量或表达式的组合运算可以产生新的boolean值。单目运算符!是布尔非。双目运算符&amp;，|和^是逻辑AND，OR和XOR运算符，它们强制两个操作数求布尔值。为避免右侧操作数冗余求值，用户可以使用短路求值运算符&amp;&amp;和||。用户可以使用==和!=，赋值运算符也可以用&amp;=、|=、^=。三元条件操作符?:和C语言中的一样。</p><p>浮点运算符浮点运算符可以使用常规运算符的组合：如单目运算符++、–，双目运算符+、-、<em>和/，以及赋值运算符+=，-=，</em>=，和/=。此外，还有取模运算：%和%=也可以作用于浮点数，例如：a%b和a-((int)(a/b)*b)的语义相同。这表示a%b的结果是除完后剩下的浮点数部分。只有单精度操作数的浮点表达式按照单精度运算求值，产生单精度结果。如果浮点表达式中含有一个或一个以上的双精度操作数，则按双精度运算，结果是双精度浮点数。</p><p>数组运算符数组运算符形式如下：</p><p>[]可给出数组中某个元素的值。合法的取值范围是从0到数组的长度减1。取值范围的检查只在运行时刻实。运算符以String对象实现。运算符"+"完成并操作，如果必要则自动把操作数转换为String型。如果操作数是一个对象，它可定义一个方法toString()返回该对象的String方式，例如floata=1.0print("Thevalueofais"+a+"\n");+运算符用到例子Strings="a="+a;+=运算符也可以用于String。注意，左边(下例中的s1)仅求值一次。s1+=a;//s1=s1+a//若a非String型，自动转换为String型。对象运算符双目运算符instanceof测试某个对象是否是指定类或其子类的实例。例如：if(myObjectinstanceofMyClass){MyClassanothermyObject=(MyClass)myObject;…}是判定myObject是否是MyClass的实例或是其子类的实例。强制和转换Java语言和解释器限制使用强制和转换，以防止出错导致系统崩溃。整数和浮点数之间可以来回</p><p>强制转换，但整数不能强制转换成数组或对象。对象不能被强制为基本类型。</p><h3 id="1-6Java流控制"><a href="#1-6Java流控制" class="headerlink" title="1.6Java流控制"></a>1.6Java流控制</h3><p>下面几个控制结构是从C语言借鉴的。分支结构</p><p>if/else分支结构if(Boolean){statemanets;}else{statements;}</p><p>switch分支结构switch(expr1){caseexpr2:statements;break;caseexpr3:statements;break;default:statements;break;}</p><p>循环结构for循环结构for(initexpr1;testexpr2;incrementexpr3){statements;}</p><p>While循环结构While(Boolean){statements;}</p><p>Do循环结构do{statements;}while(Boolean);</p><p>一般顺序控制break[label]continue[label]reutrnexpr;label:statement;</p><p>for循环例子下面是一个程序例子，画几条线，分别用红,绿,蓝颜色，这段程序可能是Java函数的一部分：intcount;for(count=1;count</p><h2 id="2-Java变量和函数的实例"><a href="#2-Java变量和函数的实例" class="headerlink" title="2.Java变量和函数的实例"></a>2.Java变量和函数的实例</h2><p>Java的类包含变量和函数。数据变量可以是一些原始的类型,如int,char等。成员函数是一些可执行的过程。例如,下面程序里：publicclassClassOne{inti;publicClassOne(){i=10;}publicvoidAdd_i(intj){i=i+j;}}ClassOne包含一个变量i和两个成员函数,ClassOne(intfirst)和Add_i(intj)。</p><p>成员函数成员函数是一些可被其它类或自己类调用的处理子程序。一个特殊的成员函数叫构造函数,这个函数名称一般与本类名程相同。它没有返回值。构造函数和成员函数当你在Java里定义一个类时,你可定义一个或多个可选的构造函数,当创建本类的一个对象时用某一个构造函数来初始化本对象。用前面的程序例子来说明,当ClassOne类创建一个新实例时,所有成员函数和变量被创建(创建实例)。构造函数被调用。ClassOnemc:mc=newClassOne();</p><p>关键词new用来创建一个类的实例,一个类用new初始化前并不占用内存,它只是一个类型定义,当mc对象初始化后,mc对象里的i变量等于10。你可以通过对象名来引用变量i。(有时称为实例变量)mc.i++;//mc实例变量加1因为mc有ClassOne类的所有变量和成员函数，我们可以使用同样的语法来调用成员函数Add_i：Add_i(10);现在mc.i变量等于21.</p><p>结束函数Java并不支持析构函数(C++里的定义),因为java本身提供对象无用时自动清除的功能,同时它也提供了一个自动拉圾箱的成员函数，在清除对象时被调用：Protectedvoidfinalize(){close();}</p><h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h2><p>有效范围和废物自动回收对象有一定的生命期并在它的生命期间使用资源,当一个对象不再被使用时,它应释放内存,避免内存溢出。在Java里,收集和释放内存是一个叫自动废品回收站的线程的责任。这个线程监视对象有效范围并给一个走出有效范围的对象作上标识。</p><p>例如：Strings;//没有分配内存s=newString("oldstring");//分配内存s="newstring";//重新分配内存(创建新对象)我们将在以后访问String类时将更加明白它的工作过程,但它的快速工作过程是这样的：1.创建一个新的String类对象并填充以"oldstring"2.创建另一个String对象并填充以"newstring"注意我们创建了两个对象。Stirng对象"oldstring"Stirng对象"newstring"在第三条语句里,第一个包括"oldstring"的叫做s的对象已走出了有效范围,没有任何方法可以再访问他,我们现在有一个新的对象也叫s,包含"newstring"。在下一个废品回收线程,前一个对象将被标识并清除。</p><h2 id="4-子类"><a href="#4-子类" class="headerlink" title="4.子类"></a>4.子类</h2><p>子类是利用存在的对象创建一个新对象的机制,比如,如果你有一个Horse类,你可以创建一个Zebra子类,Zebra是Horse的一种。</p><p>classZebraextendsHorse{intnumber_OF_stripes:}关键词extends来定义对象有的子类.Zebra是Horse的子类。Horse类里的所有特征都将拷贝到Zebra类里,而Zebra类里可以定义自己的成员函数和实例变量。Zebra称为Horse的派生类或继承。另外,你也许还想覆盖基类的成员函数。用ClassOne说明,下面是一个派生类覆盖Add_i功能的例子.</p><p>importClassOne;publicclassNewClassextendsClassOne{publicvoid</p><p>Add_i(intj){i=i+(j/2);}}</p><p>当NewClass类的实例创建时,变量i初始化值为10,但调用Add_i产生不同的结果。NewClassmnc;mnc=newNewClass();mnc.Add_i(10);访问控制Java里当你创建一个新类时,你可以标明变量和成员函数的访问层次。</p><p>publicpublicvoidAnyOneCanAccess(){}public实例变量和成员函数可以任意其它类调用。</p><p>protectedprotectedvoidOnlySubClasses(){}protected实例变量和成员函数只能被其子类调用.</p><p>privateprivateStringCreditCardNumber;private实例变量和成员函数只能在本类里调用.</p><p>friendlyvoidMyPackageMethod(){}缺省的,如果没有定义任何防火控制,实例变量或函数缺省定义成friendly,意味着可以被本包里的任意对象访问,但其它包里的对象不可访问。所有这个类的对象都只有实例变量的同一个拷贝，这种方法的关键词是static，例如：classBlock{staticintnumber=50;}</p><p>所有从Block类创建的对象的number变量值都是相同的。无任在哪个对象里改变了number的值,所有对象的number都跟着改变。同样的,你可以定义static成员函数,但这个成员函数不能访问非static函数和变量。classBlock{staticintnumber=50;intlocalvalue;staticvoidadd_local(){localvalue++;//没有运行}staticvoidadd_static(){number++;//运行}}</p><h2 id="5-this和super"><a href="#5-this和super" class="headerlink" title="5.this和super"></a>5.this和super</h2><p>访问一个类的实例变量时,this关键词是指向这个类本身的指针,在前面ClassOne例子中,我们可以增加构造函数如下：</p><p>publicclassClassOne{inti;publicClassOne(){i=10;}</p><p>publicClassOne(intvalue)this.i=value;}</p><p>publicvoidAdd_i(intj){i=i+j;}}</p><p>这里,this指向ClassOne类的指针。如果在一个子类里覆盖了父类的某个成员函数,但又想调用父类的成员函数,你可以用super关键词指向父类的成员函数。</p><p>importClassOne;publicclassNewClassextendsClassOne{publicvoidAdd_i(intj){i=i+(j/2);super.Add_i(j);}}</p><p>下面程序里,i变量被构造函数设成10,然后15，最后被父类(ClassOne)设成25。NewClassmnc;mnc=newNewClass();mnc.Add_i(10);</p><h2 id="6-类的类型"><a href="#6-类的类型" class="headerlink" title="6.类的类型"></a>6.类的类型</h2><p>至今为止,我用在类前面只用了一个public关键词,其实它有下面4种选择：abstract一个abstract类必须至少有一个虚拟函数,一个abstract类不能直接创建对象,必须继承子类后才能。</p><p>final一个final类声明了子类链的结尾,用final声明的类不能再派生子类。publicpublic类能被其它的类访问。在其它包里,如果想使用这个类必须先import,则它只能在它定义的package里使用。</p><h2 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7.抽象类"></a>7.抽象类</h2><p>面向对象的一个最大优点就是能够定义怎样使用这个类而不必真正定义好成员函数。如果程序由不同的用户实现时是很有用的，这不需用户使用相同的成员函数名。</p><p>在java里Graphics类里一个abstract类的例子如下：publicabstractclassGraphics{publicabstractvoiddrawLine(intx1,inty1,intx2,inty2);</p><p>publicabstractvoiddrawOval(intx,inty,intwidth,intheight);publicabstractvoiddrawRect</p><p>(intx,inty,intwidth,intheight);…}</p><p>在Graphics类里声明了几个成员函数,但成员函数的实际代码是在另外一处地方实现的。</p><p>publicclassMyClassextendsGraphics{publicvoiddrawLine(intx1,inty1,intx2,inty2){}}</p><p>当一个类包含一个abstract成员函数,这个类必须定义为abstract类。然而并不是abstract类的所有的成员函数都是abstract的。Abstract类不能有私有成员函数(它们不能被实现),也不能有静态成员函数。</p><h2 id="8-包-Packages"><a href="#8-包-Packages" class="headerlink" title="8.包(Packages)"></a>8.包(Packages)</h2><p>包(Package)由一组类(class)和界面(interface)组成。它是管理大型名字空间，避免名字冲突的工具。每一个类和界面的名字都包含在某个包中。按照一般的习惯，它的名字是由"."号分隔的单词构成，第一个单词通常是开发这个包的组织的名称。</p><p>定义一个编译单元的包编译单元的包由package语句定义。如果使用package语句，编译单元的第一行必须无空格，也无注释。其格式如下：packagepackageName;若编译单元无package语句，则该单元被置于一个缺省的无名的包中。使用其它包中的类和界面在Java语言里提供;一个包可以使用另一个包中类和界面的定义和实现的机制。用import关键词来标明来自其它包中的类。一个编译单元可以自动把指定的类和界面输入到它自己的包中。在一个包中的代码可以有两种方式来定义来自其它包中的类和界面：<em>在每个引用的类和界面前面给出它们所在的包的名字;//前缀包名法acme.project.FooBarobj=newacme.project.FooBar();*使用import语句，引入一个类或一个界面，或包含它们的包。引入的类和界面的名字在当前的名字空间可用。引入一个包时，则该包所有的公有类和界面均可用。其形式如下：//从acme.project引入所有类importacme.project.</em>;这个语句表示acme.project中所有的公有类被引入当前包。以下语句从acme.project包中进入一个类Employec_List。//从acme.project而引入Employee_Listimportacme.project.Employee_list;Employee_Listobj=newEmployee</p><p>_List();在使用一个外部类或界面时，必须要声明该类或界面所在的包，否则会产生编译错误。import(引用)类包(classpackage)用import关键词调入,指定package名字如路径和类名,用*匹配符可以调入多于一个类名。</p><p>importjava.Date;importjava.awt.*;</p><p>如果java源文件不包含package,它放在缺省的无名package。这与源文件同目录，类可以这样引入:importMyClass。</p><p>Java系统包：Java语言提供了一个包含窗口工具箱，实用程序，一般I/O,工具和网络功能的包。</p><p>java.applet这个包包含量了设计applet的类,用一个类Applet和三个接口.AppletContext;AppletStub;和AudioClip.</p><p>java.awt另一个窗口工具箱包.awt,包含了产生装饰物和GUI成员的类。这个package包括：</p><p>Button,Checkbox,Choice,Component,Graphics,Menu,Pane1,TextArea和TextField。</p><p>java.ioI/Opackage包含文件输入/输出类，FileInputStream和FileOutputStream.</p><p>java.lang这个包包含Java语言类,包含:对象,线程,异常出口,系统,整数,原点,数学,字符等。</p><p>java.net这个类支持TCP/IP网络协议，并包含Socket类,URL和URL相联系的类。</p><p>java.util这个类包含程序的同步类,它包含Date,Dictionary类等。</p><h1 id="四、Java程序编写"><a href="#四、Java程序编写" class="headerlink" title="四、Java程序编写"></a>四、Java程序编写</h1><p>象其它编程语言一样，Java 编程语言也被用来创建应用程序。一个共同的应用程序范例是在屏幕上显示字串“Hello World!” 。下列代码给出了这个 Java 应用程序。</p><p>虽然很多你可能都不明白，没有关系，主要是来体会一下 Java 程序是什么样子，你可以先看看，有个印象，然后可以先模仿着做。</p><h2 id="1-HelloWorldApp"><a href="#1-HelloWorldApp" class="headerlink" title="1.HelloWorldApp"></a>1.HelloWorldApp</h2><p>1.//</p><p>2.// HelloWorld 应用示例</p><p>3.//</p><p>4.public class HelloWorldApp{</p><p>\5. public static void main (String args[]) {</p><p>\6. System.out.println (“Hello World!”);</p><p>\7. }</p><p>8.}</p><p>以上程序行是在你的屏幕上打印“Hello World!”所需的最少代码。</p><h2 id="2-描述HelloWorldApp"><a href="#2-描述HelloWorldApp" class="headerlink" title="2.描述HelloWorldApp"></a>2.描述HelloWorldApp</h2><p>第 1-3 行</p><p>程序中的 1-3 行是注释行</p><p>1 //</p><p>2 // HelloWorld 应用示例</p><p>3 //</p><p>第 4 行</p><p>第 4 行声明类名为 HelloWorldApp。类名(Classname)是在源文件中指明的，它可在与源代码相同的目录上创建一个 classname · class 文件。在本例题中，编译器创建了一个称为HelloWorldApp.class的文件, 它包含了公共类HelloWorldApp的编译代码。</p><p>4 public class HelloWorldApp{</p><p>第 5 行</p><p>第 5 行是程序执行的起始点。Java 解释器必须发现这一严格定义的点，否则将拒绝运行程序。</p><p>其它程序语言(特别是 C 和 C++)也采用 main ()声明作为程序执行的起始点。此声明的不同部分将在本课程的后几部分介绍。</p><p>如果在程序的命令行中给出了任何自变量(命令行参数) ，它们将被传递给 main()方法中被称作 args 的 String 数组。在本例题中，未使用自变量。</p><p>public static void main (String args[]) {</p><p>public-方法 main()可被任何程序访问，包括 Java 解释器。</p><p>static- 是一个告知编译器 main()是用于类 HelloWorldApp 中的方法的关键字。</p><p>为使 main()在程序做其它事之前就开始运行，这一关键字是必要的。</p><p>void- 表明 main()不返回任何信息。这一点是重要的，因为 Java 编程语言要进行谨慎的类型检查，包括检查调用的方法确实返回了这些方法所声明的类型。</p><p>String args[] - 是一个 String 数组的声明， 它将包含位于类名之后的命令行中的自变量。</p><p>java HelloWorldApp args[0] args[1]· · · ·</p><p>第 6 行</p><p>第 6 行声明如何使用类名、对象名和方法调用。它使用由 System 类的 out 成员引用的 PrintStream 对象的 println()方法，将字串“Hello World!”打印到标准输出上。</p><p>6 System.out.println(“Hello World!”);</p><p>在这个例子中，println()方法被输入了一个字串自变量并将其写在了标准输出流上。</p><p>第 7-8 行</p><p>本程序的 7-8 行分别是方法 main()和类 HelloWorldApp 的下括号。</p><p>7 ｝</p><p>8 ｝</p><h2 id="3-编译并运行HelloWorldApp"><a href="#3-编译并运行HelloWorldApp" class="headerlink" title="3.编译并运行HelloWorldApp"></a>3.编译并运行HelloWorldApp</h2><p>编译</p><p>当你创建了 HelloWorldApp.java 源文件后，用下列程序行进行编译：</p><p>javac HelloWorldApp.java</p><p>如果编译器未返回任何提示信息， 新文件 HelloWorldApp.class 则被存储在与源文件相同的目录中，除非另有指定。</p><p>如果在编译中遇到问题，请参阅本模块的查错提示信息部分。</p><p>运行</p><p>为运行你的 HelloWorldApp 应用程序，需使用 Java 解释器和位于 bin 目录下的 java程序:</p><p>java HelloWorldApp</p><p>Hello World!</p><h2 id="4-编译查错"><a href="#4-编译查错" class="headerlink" title="4.编译查错"></a>4.编译查错</h2><p>编译时的错误，以下是编译时的常见错误：</p><p>javac:Command not found</p><p>PATH 变量未正确设置以包括 javac 编译器。javac 编译器位于 JDK 目录下的 bin 目录。</p><p>HelloWorldApp.java:6: Method printl(java.lang.String)</p><p>not found in class java.io.PrintStream.System.</p><p>out.printl (“Hello World!”);</p><p>方法名 println 出现打印错误。</p><p>In class HelloWorldApp:main must be public or static</p><p>该错误的出现是因为词 static 或 public 被放在了包含 main 方法的行之外。</p><p>运行时的错误 can’t find class HelloWorldApp(这个错误是在打印 java HelloWorldApp时产生的) ， 通常, 它表示在命令行中所指定的类名的拼写与 filename.class 文件的拼写不同。Java 编程语言是一种大小写区别对待的语言。</p><p>例如： public class HelloWorldapp {</p><p>创建了一个 HellloWorldapp.class ，它不是编译器所预期的类名(HelloWorldApp.class)。</p><h3 id="4-1-命名"><a href="#4-1-命名" class="headerlink" title="4.1.命名"></a>4.1.命名</h3><p>如果 java 文件包括一个公共类，那么它必须使用与那个公共类相同的文件名。例如在前例中的类的定义是</p><p>public class HelloWorldapp</p><p>源文件名则必须是 HelloWorldapp.java</p><h3 id="4-2-类计数"><a href="#4-2-类计数" class="headerlink" title="4.2.类计数"></a>4.2.类计数</h3><p>在源文件中每次只能定义一个公共类。</p><h3 id="4-3-源文件布局"><a href="#4-3-源文件布局" class="headerlink" title="4.3.源文件布局"></a>4.3.源文件布局</h3><p>一个 Java 源文件可包含三个“顶级”要素：</p><p>(1)一个包(package)声明(可选)</p><p>(2)任意数量的导入(import)语句</p><p>(3)类(class)声明</p><p>该三要素必须以上述顺序出现。即，任何导入语句出现在所有类定义之前;如果使用包声明，则包声明必须出现在类和导入语句之前。</p><h1 id="五、关键字"><a href="#五、关键字" class="headerlink" title="五、关键字"></a>五、关键字</h1><h2 id="1-什么是关键字"><a href="#1-什么是关键字" class="headerlink" title="1.什么是关键字"></a>1.什么是关键字</h2><p>Java 语言保留的，Java 的开发和运行平台认识，并能正确处理的一些单词。</p><p>其实就是个约定，就好比我们约定好，我画个勾勾表示去吃饭。那好了，只要我画个勾勾，大家就知道是什么意思，并能够正确执行了。</p><p>关键字这个约定在 Java 语言和 Java 的开发和运行平台之间，我们只要按照这个约定使用了某个关键字，Java 的开发和运行平台就能够认识它，并正确地处理。</p><h2 id="2-Java中有哪些关键字"><a href="#2-Java中有哪些关键字" class="headerlink" title="2.Java中有哪些关键字"></a>2.Java中有哪些关键字</h2><p>abstract  do  implements  private  throw</p><p>boolean  double  import  protected  throws</p><p>break  else  instanceof  public  transient</p><p>byte  extends  int  return  true</p><p>case  false  interface  short  try</p><p>catch  final  long  static  void</p><p>char  finally  native  super  volatile</p><p>class  float  new  switch  while</p><p>continue  for  null  synchronized  enum</p><p>default  if  package  this  assert</p><h2 id="3-Java中关键字的基本含义"><a href="#3-Java中关键字的基本含义" class="headerlink" title="3.Java中关键字的基本含义"></a>3.Java中关键字的基本含义</h2><p>• abstract：表明类或类中的方法是抽象的;</p><p>• boolean：基本数据类型之一，布尔类型;</p><p>• break：提前跳出一个块;</p><p>• byte：基本数据类型之一，字节类型;</p><p>• case：在 switch 语句中，表明其中的一个分支;</p><p>• catch：用于处理例外情况，用来捕捉异常;</p><p>• char：基本数据类型之一，字符类型;</p><p>• class：类;</p><p>• continue：回到一个块的开始处;</p><p>• default：用在 switch 语句中，表明一个默认的分支;</p><p>• do：用在”do while”循环结构中;</p><p>• double：基本数据类型之一，双精度浮点数类型;</p><p>• else：在条件语句中，表明当条件不成立时的分支;</p><p>• extends：用来表明一个类是另一个类的子类;</p><p>• final：用来表明一个类不能派生出子类，或类中的方法不能被覆盖，或声明一个变量是常量;</p><p>• finally：用于处理异常情况，用来声明一个肯定会被执行到的块;</p><p>• float：基本数据类型之一，单精度浮点数类型;</p><p>• for：一种循环结构的引导词;</p><p>• if：条件语句的引导词;</p><p>• implements：表明一个类实现了给定的接口;</p><p>• import：表明要访问指定的类或包;</p><p>• instanceof：用来测试一个对象是否是一个指定类的实例;</p><p>• int：基本数据类型之一，整数类型;</p><p>• interface：接口;</p><p>• long：基本数据类型之一，长整数类型;</p><p>• native：用来声明一个方法是由与机器相关的语言(如 C/C++/FORTRAN 语言)实现的;</p><p>• new：用来申请新对象;</p><p>• package：包;</p><p>• private：一种访问方式：私有模式;</p><p>• protected：一种访问方式：保护模式;</p><p>• public：一种访问方式：公共模式;</p><p>• return：从方法中返回值;</p><p>• short：基本数据类型之一，短整数类型;</p><p>• static：表明域或方法是静态的，即该域或方法是属于类的;</p><p>• strictfp：用来声明 FP-strict(双精度或单精度浮点数)表达式，参见 IEEE 754 算术规范;</p><p>• super：当前对象的父类对象的引用;</p><p>• switch：分支结构的引导词;</p><p>• synchronized：表明一段代码的执行需要同步;</p><p>• this：当前对象的引用;</p><p>• throw：抛出一个异常;</p><p>• throws：声明方法中抛出的所有异常;</p><p>• transient：声明不用序列化的域;</p><p>• try：尝试一个可能抛出异常的程序块</p><p>• void：表明方法不返回值;</p><p>• volatile：表明两个或多个变量必须同步地发生变化;</p><p>• while：用在循环结构中;</p><p>• assert：声明断言;</p><p>• enum：声明枚举类型;</p><h2 id="4-解释几点"><a href="#4-解释几点" class="headerlink" title="4.解释几点"></a>4.解释几点</h2><p>(1)：这些关键字的具体含义和使用方法，会在后面用到的地方讲述</p><p>(2)：Java 的关键字也是随新的版本发布在不断变动中的，不是一成不变的</p><p>(3)：所有关键字都是小写的</p><p>(4)：goto 和 const 不是 Java 编程语言中使用的关键字，但是是 Java 的保留字，也就是说 Java 保留了它们，但是没有使用它们。true 和 false 不是关键字，而是 boolean 类型直接量</p><p>(5)：表示类的关键字是 class</p><h1 id="六、数据类型"><a href="#六、数据类型" class="headerlink" title="六、数据类型"></a>六、数据类型</h1><h2 id="1-什么叫数据类型"><a href="#1-什么叫数据类型" class="headerlink" title="1.什么叫数据类型"></a>1.什么叫数据类型</h2><p>数据类型简单的说就是对数据的分类， 对数据各自的特点进行类别的划分， 划分的每种数据类型都具有区别于其它类型的特征， 每一类数据都有相应的特点和操作功能。 例如数字类型的就能够进行加减乘除的操作。</p><p>在现实生活中， 我们通常会对信息进行分类， 从而使得我们能很容易的判断某个数据是表示一个百分数还是一个日期，我们通常是通过判断数字是否带”%”，或者是否是一个我们熟悉的”日期格式”。</p><p>类似的在程序中， 计算机也需要某种方式来判断某个数字是什么类型的。 这通常是需要程序员显示来声明某个数据是什么类型的，Java 就是这样的。Java 是一种强类型的语言，凡是使用到的变量，在编译之前一定要被显示的声明。</p><h2 id="2-Java数据类型的分类"><a href="#2-Java数据类型的分类" class="headerlink" title="2.Java数据类型的分类"></a>2.Java数据类型的分类</h2><p>Java 里面的数据类型从大的方面分为两类，一是基本数据类型，一是引用类型，基本 的 Java 数据类型层次图如下：</p><h2 id="3-Java中的基本数据类型"><a href="#3-Java中的基本数据类型" class="headerlink" title="3.Java中的基本数据类型"></a>3.Java中的基本数据类型</h2><p>Java 中的基本数据类型分为八个原始数据类型，原始类型可分为四种：</p><p>(1)整数型：byte、short、int、long</p><p>(2)浮点型：float、double</p><p>(3)字符型：char</p><p>(4)逻辑型：boolean</p><h3 id="3-1-整数型：byte、short、int、long"><a href="#3-1-整数型：byte、short、int、long" class="headerlink" title="3.1.整数型：byte、short、int、long"></a>3.1.整数型：byte、short、int、long</h3><p>byte：字节型</p><p>short：短整型</p><p>int： 整型</p><p>long：长整型</p><p>在 Java 中，整数型的值都是带符号的数字，可以用十进制、八进制和十六进制来表示。</p><p>所谓多少进制， 就是满多少就进位的意思， 如十进制表示逢十进位， 八进制就表示逢八进位。</p><p>示例：</p><p>15：十进制的 15</p><p>015：八进制的 15 ，相当于十进制的 13，计算公式：1*8 +5 = 13</p><p>0x15：十六进制的 15，相当于十进制的 21，计算公式：1*16+5=21</p><p>3.1.1.在Java中的定义示例</p><p>示例 1.byte abc = 5;</p><p>表示在 Java 中定义一个变量 abc，类型是 byte 类型，值是 5</p><p>同理可以定义其它的类型：</p><p>比如：</p><p>short abc1 = 5;</p><p>int abc2 = 5;</p><p>long abc3 = 5;</p><p>这些都是可以的，如果要明确表示是long型的值，可以在后面直接跟一个字母“L”。L表示一个long值。</p><p>也就是写成：long abc4 = 5L;</p><p>请注意，在 Java 编程语言中使用大写或小写 L 同样都是有效的，但由于小写 l 与数字 1 容易混淆，因而，尽量不要使用小写。</p><p>注意：整数型的值，如果没有特别指明，默认是是int型</p><p>3.1.2取值范围和默认值</p><p>取值范围的表示是按 Java 编程语言规范定义的且不依赖于平台</p><h3 id="3-2-浮点型：float、double"><a href="#3-2-浮点型：float、double" class="headerlink" title="3.2.浮点型：float、double"></a>3.2.浮点型：float、double</h3><p>Java 用浮点型来表示实数，简单地说就是带小数的数据。</p><p>用 float 或 double 来定义浮点类型，如果一个数字包括小数点或指数部分，或者在数字后带有字母 F 或 f(float) 、D 或 d(double) ，则该数字文字为浮点型的。</p><p>示例：</p><p>12.3 //简单的浮点型数据</p><p>12.3E10 //数据很大的一个浮点数据</p><p>3.2.1.在在Java中的定义示例</p><p>如下定义都是可以的：</p><p>float abc = 5.6F;</p><p>float abc = 5.6f;</p><p>double abc = 5.6;</p><p>double abc = 5.6D;</p><p>double abc = 5.6d;</p><p>3.2.2.提示</p><p>(1)浮点型的值，如果没有特别指明，默认是是double型的</p><p>(2)定义float型的时候，一定要指明是float型的，可以通过在数字后面添加”F”或者”f”来表示。</p><p>(3)定义double型的时候，可以不用指明，默认就是double型的，也可以通过在数字后面添加”D”或者”d”来表示。</p><p>3.2.3 取值范围 和 默认值</p><p>Java 技术规范的浮点数的格式是由电力电子工程师学会(IEEE)754 定义的，是独立于平台的。 可以通过 Float.MAX_VALUE 和 Float.MIN_VALUE 取得 Float 的最大最小值; 可以通过 Double.MAX_VALUE 和 Double.MIN_VALUE 来取得 Double 的最大最小值。</p><h3 id="3-3-字符型：char"><a href="#3-3-字符型：char" class="headerlink" title="3.3.字符型：char"></a>3.3.字符型：char</h3><p>char类型用来表示单个字符。一个char代表一个16-bit无符号的(不分正负的)</p><p>Unicode字符，一个char字符必须包含在单引号内。</p><p>示例：</p><p>‘a’//表示简单的字符</p><p>‘1’//用数字也可以表示字符</p><p>下面就错了，只能使用单个字符</p><p>‘ab’//错误</p><p>‘12’//错误</p><p>3.3.1.什么是Unicode编码</p><p>Unicode 编码又叫统一码、万国码或单一码，是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码， 以满足跨语言、 跨平台进行文本转换、 处理的要求。 1990 年开始研发， 1994 年正式公布。 随着计算机工作能力的增强， Unicode也在面世以来的十多年里得到普及。unicode 的表达如下：</p><p>‘\u????’ 一个 Unicode 字符。????应严格按照四个 16 进制数进行替换。</p><p>3.3.2.在在Java中的定义示例</p><p>char c = ‘a’;</p><p>char c = ‘1’;</p><p>3.3.3.取值范围和默认值</p><p>3.3.4.Java里面的转义字符</p><p>转义字符是指， 用一些普通字符的组合来代替一些特殊字符， 由于其组合改变了原来字符表示的含义，因此称为“转义”。 常见的转义字符：</p><p>\n 回车(\u000a)</p><p>\t 水平制表符(\u0009)</p><p>\b 空格(\u0008)</p><p>\r 换行(\u000d)</p><p>\f 换页(\u000c)</p><p>' 单引号(\u0027)</p><p>" 双引号(\u0022)</p><p>\ 反斜杠(\u005c)</p><h3 id="3-4-逻辑型：boolean"><a href="#3-4-逻辑型：boolean" class="headerlink" title="3.4.逻辑型：boolean"></a>3.4.逻辑型：boolean</h3><p>逻辑值有两种状态， 即人们经常使用的 “on” 和 “off” 或 “true” 和 “false” 或 “yes”</p><p>和“no” ，这样的值是用 boolean 类型来表示的。boolean 有两个文字值，即 true 和 false。</p><p>以下是一个有关 boolean 类型变量的声明和初始化：</p><p>boolean truth = true; //声明变量 truth</p><p>注意──在整数类型和 boolean 类型之间无转换计算。有些语言(特别值得强调的是 C和 C++)允许将数字值转换成逻辑值(所谓“非零即真” ),这在 Java 编程语言中是不允许的;boolean 类型只允许使用 boolean 值(true 或 false) 。</p><p>注意：Java中不可以直接将整数类型和逻辑类型转换.</p><h3 id="3-5-声明和赋值"><a href="#3-5-声明和赋值" class="headerlink" title="3.5.声明和赋值"></a>3.5.声明和赋值</h3><p>3.5.1.什么是声明</p><p>声明为 Java 程序实体引入标识符， 能够使用这些名字访问到这些实体， 声明实体包括：类名、属性名、方法名、变量名、参数名、接口名等等。其实简单点说就是定义某个东西并对外宣称它。</p><p>3.5.2.什么是赋值</p><p>赋值就是为一个声明的变量或者常量赋予具体的值， 也就是赋予值的意思。 使用一个等号”=”来表示。</p><p>示例：</p><p>int a = 5;</p><p>这句话的意思就是，声明一个类型为int的变量a，并将它赋值为5。</p><h3 id="3-6-特别介绍：字符串型String"><a href="#3-6-特别介绍：字符串型String" class="headerlink" title="3.6.特别介绍：字符串型String"></a>3.6.特别介绍：字符串型String</h3><p>字符型只能表示一个字符，那么多个字符怎么表示呢？</p><p>Java 中使用 String 这个类来表示多个字符， 表示方式是用双引号把要表示的字符串引起来，字符串里面的字符数量是任意多个。字符本身符合 Unicode 标准，且上述 char 类型的反斜线符号 (转义字符) 适用于 String。 与 C 和 C++不同， String 不能用 \0 作为结束。 String的文字应用双引号封闭，如下所示：</p><p>“The quick brown fox jumped over the lazy dog.”</p><p>char 和 String 类型变量的声明和初始化如下所示：</p><p>char ch = ‘A’; // 声明并初始化一个字符变量</p><p>char ch1,ch2 ; //声明两个字符变量</p><p>// 声明两个字符串变量并初始化它们</p><p>String greeting = “Good Morning !! \n” ;</p><p>String err_msg = “Record Not Found !” ;</p><p>String str1,str2 ; // 声明两个字符串变量</p><p>String s = “12abc”; //基本的字符串型</p><p>String s = “”; //表示空串</p><p>注意：</p><p>(1)：String不是原始的数据类型，而是一个类(class)</p><p>(2)：String包含的字符数量是任意多个，而字符类型只能是一个。</p><p>要特别注意：”a”表示的是字符串，而’a’表示的是字符类型，它们具有不同的功能。</p><p>(3)：String的默认值是null</p><h3 id="3-7-示例"><a href="#3-7-示例" class="headerlink" title="3.7.示例"></a>3.7.示例</h3><p>下列程序显示了如何为整数、浮点数、boolean、字符和 String 类型变量声明和赋值</p><p>\1. public class Assign {</p><p>\2. public static void main(String args []) {</p><p>\3. int x, y; // 声明 int 变量</p><p>4.float z = 3.414f; // 声明并赋值 float</p><p>5.double w = 3.1415; //声明并赋值 double</p><p>6.boolean truth = true; //声明并赋值 boolean</p><p>7.char c; // 声明字符变量</p><p>8.String str; // 声明 String 字符串</p><p>9.String str1 = “bye”; //声明并赋值 String 变量</p><p>10.c = ‘A’; // 给字符变量赋值</p><p>11.str = “Hi out there!”; // 给 String 变量赋值</p><p>12.x = 6;</p><p>13.y = 1000; // 给 int 变量赋值</p><p>14….</p><p>15.}</p><p>16.}</p><p>非法赋值举例</p><p>y = 3.1415926; // 3.1415926 不是一个 int.</p><p>// 需要类型转换并且小数位要截掉</p><p>w = 175,000; // 逗号( , ) 不能够出现</p><p>truth = 1; // 一个优秀的 C/C++程序员常犯的错误，在 Java 语言中 boolean 型变量只能为 true 或 false</p><p>z = 3.14156 ; // double 型的值不能赋给 float 变量，需要类型转换</p><h1 id="七、面向对象三大特征"><a href="#七、面向对象三大特征" class="headerlink" title="七、面向对象三大特征"></a>七、面向对象三大特征</h1><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><p>封装这个词听起来好象是将什么东西包裹起来不要别人看见一样，就好象是把东西装进箱子里面，这样别人就不知道箱子里面装的是什么东西了。其实 JAVA 中的封装这个概念也就和这个是差不多的意思。</p><p>封装是 JAVA 面向对象的特点的表现，封装是一种信息隐蔽技术。它有两个含义：即把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位; 以及尽可能隐藏对象的内部结构。也就是说，如果我们使用了封装技术的话，别人就只能用我们做出来的东西而看不见我们做的这个东西的内部结构了。</p><p>封装的功能</p><p>- 隐藏对象的实现细节</p><p>- 迫使用户去使用一个界面访问数据</p><p>- 使代码更好维护</p><p>封装迫使用户通过方法访问数据能保护对象的数据不被误修改，还能使对象的重用变得更简单。数据隐藏通常指的就是封装。它将对象的外部界面与对象的实现区分开来，隐藏实现细节。迫使用户去使用外部界面，即使实现细节改变，还可通过界面承担其功能而保留原样，确保调用它的代码还继续工作。封装使代码维护更简单。</p><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h2><p>is a 关系—— 子对象</p><p>在面向对象世界里面，常常要创建某对象(如：一个职员对象)，然后需要一个该基本对象的更专业化的版本，比如，可能需要一个经理的对象。显然经理实际上是一个职员，经理和职员具有 is a 的关系，经理只是一个带有附加特征的职员。因此，需要有一种办法从现有对象来创建一个新对象。这个方式就是继承。</p><p>“继承”是面向对象软件技术当中的一个概念。 如果一个 对象 A 继承自另一个 对象 B， 就把这个 A 称为”B 的子 对象 “，而把 B 称为”A 的父 对象 “。继承可以使得子 对象 具有父 对象 的各种属性和方法，而不需要再次编写相同的代码。在令子 对象 继承父 对象 的同时，可以重新定义某些属性，并重写某些方法，即覆盖父 对象 的原有属性和方法，使其获得与父对象不同的功能。</p><h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h2><p>同一行为的多种不同表达，或者同一行为的多种不同实现就叫做多态。</p><p>还是用刚才经理和职员这个例子来举例：人事部门需要对公司所有职员统一制作胸卡(一般也就是门禁卡，进出公司证明身份使用)，制作的师傅说，只要告诉我一个人员的信息，就可以制作出一份胸卡，简化一下就是：一位职员的信息对应一份胸卡。</p><p>这个时候，对胸卡制作的师傅而言，所有的人都是职员，无所谓是经理还是普通职员。</p><p>也就是说，对于传递职员信息这样一个行为，存在多种不同的实现，既可以传递经理的信息， 也可以传递普通职员的信息。这就是多态的表现。</p><p>再举一个例子：比如我们说“笔”这个对象，它就有很多不同的表达或实现，比如有钢笔、铅笔、圆珠笔等等。那么我说“请给我一支笔”，你给我钢笔、铅笔或者圆珠笔都可以，这里的“笔”这个对象就具备多态。</p><h1 id="八、Java类的基本构成"><a href="#八、Java类的基本构成" class="headerlink" title="八、Java类的基本构成"></a>八、Java类的基本构成</h1><h2 id="1-Java类的定义形式"><a href="#1-Java类的定义形式" class="headerlink" title="1.Java类的定义形式"></a>1.Java类的定义形式</h2><p>一个完整的 Java 类通常由下面六个部分组成：</p><p>包定义语句</p><p>import 语句</p><p>类定义{</p><p>成员变量</p><p>构造方法</p><p>成员方法</p><p>}</p><p>其中：只有类定义和“{}”是不可或缺的，其余部分都可以根据需要来定义。</p><p>下面分别来学习各个部分的基本规则，看看如何写 Java 的类。</p><h2 id="2-包"><a href="#2-包" class="headerlink" title="2.包"></a>2.包</h2><h3 id="2-1-包是什么"><a href="#2-1-包是什么" class="headerlink" title="2.1.包是什么"></a>2.1.包是什么</h3><p>在 Java 中，包是类、接口或其它包的集合，包主要用来将类组织起来成为组，从而对类进行管理。</p><h3 id="2-2-包能干什么"><a href="#2-2-包能干什么" class="headerlink" title="2.2.包能干什么"></a>2.2.包能干什么</h3><p>包对于下列工作非常有用：</p><p>(1)：包允许您将包含类代码的文件组织起来，易于查找和使用适当的类。</p><p>(2)：包不止是包含类和接口，还能够包含其它包。形成层次的包空间。</p><p>(3)：它有助于避免命名冲突。当您使用很多类时，确保类和方法名称的唯一性是非常困难的。包能够形成层次命名空间，缩小了名称冲突的范围，易于管理名称。</p><p>为便于管理数目众多的类，Java 语言中引入了“包”的概念，可以说是对定义的 Java类进行“分组” ，将多个功能相关的类定义到一个“包”中，以解决命名冲突、引用不方便、安全性等问题。</p><p>就好似当今的户籍制度，每个公民除有自己的名字“张三” 、 “李四”外还被规定了他的户籍地。假定有两个人都叫张三，只称呼名字就无法区分他们，但如果事先登记他们的户籍分别在北京和上海，就可以很容易的用“北京的张三” 、 “上海的张三”将他们区分开来。如果北京市仍有多个张三，还可以细分为“北京市.海淀区的张三” 、 “北京市.西城区.平安大街的张三”等等，直到能惟一标识每个“张三”为止。</p><p>JDK 中定义的类就采用了“包”机制进行层次式管理，下图显示了其组织结构的一部分：</p><p>从图中可以看出，一个名为 java 的包中又包含了两个子包：io 包和 lang 包。lang 包中包含了 System, String, Object 三个类的定义。事实上，Java 包中既可以包含类的定义，也可以包含子包，或同时包含两者。</p><p>简而言之：从逻辑上讲，包是一组相关类的集合;从物理上讲，同包即同目录。</p><h3 id="2-1-JDK中常用的包"><a href="#2-1-JDK中常用的包" class="headerlink" title="2.1.JDK中常用的包"></a>2.1.JDK中常用的包</h3><p>java.lang—-包含一些 Java 语言的核心类，包含构成 Java 语言设计基础的类。在此包中定义的最重要的一个类是“Object” ，代表类层次的根，Java 是一个单根系统，最终的根就是“Object” ，这个类会在后面讲到。</p><p>Java 并不具有“自由”的方法，例如，不属于任何类的方法，Java 中的所有方法必须始终属于某个类。经常需要使用数据类型转换方法。Java 在 Java.lang 包中定义了“包装对象”类，使我们能够实现数据类型转换。如 Boolean、Character、Integer、Long、Float 和Double，这些在后面会讲到。</p><p>此包中的其它类包括：</p><p>? Math——封装最常用的数学方法，如正弦、余弦和平方根。</p><p>? String，StringBuffer——封装最常用的字符串操作。</p><p>你不必显示导入该包，该 Java 包通常已经导入。</p><p>java.awt—-包含了构成抽象窗口工具集(abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。</p><p>javax.swing—-完全 Java 版的图形用户界面(GUI)解决方案，提供了很多完备的组件，可以应对复杂的桌面系统构建。</p><p>java.net—-包含执行与网络相关的操作的类，如 URL, Socket, ServerSocket 等。</p><p>java.io—-包含能提供多种输入/输出功能的类。</p><p>java.util—-包含一些实用工具类，如定义系统特性、使用与日期日历相关的方法。还有重要的集合框架。</p><h3 id="2-2-Java中如何表达包——package语句"><a href="#2-2-Java中如何表达包——package语句" class="headerlink" title="2.2.Java中如何表达包——package语句"></a>2.2.Java中如何表达包——package语句</h3><p>Java 语言使用 package 语句来实现包的定义。package 语句必须作为 Java 源文件的第一条语句， 指明该文件中定义的类所在的包。 若缺省该语句， 则指定为无名包， 其语法格式为：</p><p>package pkg1[.pkg2[.pkg3…]]; //“[]”表示可选Java 编译 器 把包对 应 于 文 件系 统 的目 录管 理，因此包也可以嵌套使用，即一个包中可以含有类的定义也可以含有子包，其嵌套层数没有限制。package 语句中，用‘.’来指明包的层次;</p><p>Java 语言要求包声明的层次和实际保存类的字节码文件的目录结构存在对应关系， 以便将来使用该类时能通过包名(也就是目录名)查找到所需要的类文件。简单地说就是包的层次结构需要和文件夹的层次对应。</p><p>注意：每个源文件只有一个包的声明，而且包名应该全部小写。</p><p>具体来说，程序员要做以下工作：</p><h3 id="2-3-编译和生成包"><a href="#2-3-编译和生成包" class="headerlink" title="2.3.编译和生成包"></a>2.3.编译和生成包</h3><p>如果在程序 Test.java 中已定义了包 p1，就必须将编译生成的字节码文件 Test.class 保存在与包名同名的子目录中，可以选用下述两种方式之一：</p><p>采用下述命令编译：</p><p>javac Test.java</p><p>则编译器会在当前目录下生成 Test.class 文件， 再在适合位置手动创建一个名为 p1 的子目录，将 Test.class 复制到该 p1 目录下。</p><p>采用简化的编译命令，就是可以带包编译</p><p>javac -d destpath Test.java</p><p>归入该包的类的字节代码文件应放在 java 的类库所在路径的 destpath 子目录下。 现在包的相对位置已经决定了，但 java 类库的路径还是不定的。事实上，java 可以有多个存放类库的目录，其中的缺省路径为 java 目录下的 lib 子目录，你可以通过使用-classpath 选项来确定你当前想选择的类库路径。 除此之外， 你还可以在 CLASSPATH 环境变量中设置类库路径。 destpath 为目标路径， 可以是本地的任何绝对或相对路径。 则编译器会自动在 destpath目录下建立一个子目录 p1，并将生成的.class 文件自动保存到 destpath/p1 下。例如：</p><p>javac -d .\ Test.java</p><p>javac -d C:\test\ Test.java</p><h3 id="2-4-带包运行"><a href="#2-4-带包运行" class="headerlink" title="2.4.带包运行"></a>2.4.带包运行</h3><p>运行带包的程序，需要使用类的全路径，也就是带包的路径，比如上面的那个程序，就使用如下的代码进行运行：</p><p>java p1.Test</p><h2 id="3-import"><a href="#3-import" class="headerlink" title="3.import"></a>3.import</h2><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用“import”语句可完成此功能。在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以有 0~多条，其语法格式为：</p><p>import package1[.package2…].(classname|*);</p><p>java 运行时环境将到 CLASSPATH + package1.[package2…]路径下寻找并载入相应的字节码文件 classname.class。 “*”号为通配符，代表所有的类。也就是说 import 语句为编译器指明了寻找类的途径。</p><p>例，使用 import 语句引入类程序：TestPackage.java</p><p>java 编译器默认为所有的 java 程序引入了 JDK 的 java.lang 包中所有的类(import java.lang.*;) ，其中定义了一些常用类：System、String、Object、Math 等。因此我们可以直接使用这些类而不必显式引入。但使用其它非无名包中的类则必须先引入、后使用。</p><h3 id="3-1-Java类搜寻方式"><a href="#3-1-Java类搜寻方式" class="headerlink" title="3.1.Java类搜寻方式"></a>3.1.Java类搜寻方式</h3><p>程序中的 import 语句标明要引入 p1 包中的 Test 类， 假定环境变量 CLASSPATH 的值为</p><p>“.;C:\jdk6\lib;D:\ex” ， java 运行环境将依次到下述可能的位置寻找并载入该字节码</p><p>文件 Test.class：</p><p>.\p1\Test.class</p><p>C:\jdk6\lib\p1\Test.class</p><p>D:\ex\p1\Test.class</p><p>其中， “.”代表当前路径，如果在第一个路径下就找到了所需的类文件，则停止搜索。</p><p>否则依次搜索后续路径，如果在所有的路径中都未找到所需的类文件，则编译或运行出错。</p><h2 id="4-访问修饰符"><a href="#4-访问修饰符" class="headerlink" title="4.访问修饰符"></a>4.访问修饰符</h2><p>Java 语言允许对类中定义的各种属性和方法进行访问控制， 即规定不同的保护等级来限制对它们的使用。为什么要这样做?Java 语言引入类似访问控制机制的 目的 在 于实 现 信息的 封 装 和 隐藏。 Java 语言为对类中的属性和方法进行有效地访问控制， 将它们分为四个等级：private, 无修饰符, protected, public，具体规则如下：</p><p>变量和方法可以处于四个访问级别中的一个：公共，受保护，无修饰符或私有。类可以在公共或无修饰级别。</p><p>变量、方法或类有缺省(无修饰符)访问性，如果它没有显式受保护修饰符作为它的声明的一部分的话。这种访问性意味着，访问可以来自任何方法，当然这些方法只能在作为对象的同一个包中的成员类当中。</p><p>以修饰符 protected 标记的变量或方法实际上比以缺省访问控制标记的更易访问。 一个protected 方法或变量可以从同一个包中的类当中的任何方法进行访问， 也可以是从任何子类中的任何方法进行访问。 当它适合于一个类的子类但不是不相关的类时， 就可以使用这种受保护访问来访问成员。</p><h2 id="5-类定义"><a href="#5-类定义" class="headerlink" title="5.类定义"></a>5.类定义</h2><p>Java 程序的基本单位是类，你建立类之后，就可用它来建立许多你需要的对象。Java把每一个可执行的成分都变成类。</p><p>类的定义形式如下：</p><p>这里，类名要是合法的标识符。在类定义的开始与结束处必须使用花括号。你也许想建立一个矩形类，那么可以用如下代码：</p><p>​    </p><h2 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6.构造方法"></a>6.构造方法</h2><h3 id="6-1-什么是构造方法"><a href="#6-1-什么是构造方法" class="headerlink" title="6.1.什么是构造方法"></a>6.1.什么是构造方法</h3><p>类有一个特殊的成员方法叫作构造方法， 它的作用是创建对象并初始化成员变量。 在创建对象时，会自动调用类的构造方法。</p><h3 id="6-2-构造方法定义规则"><a href="#6-2-构造方法定义规则" class="headerlink" title="6.2.构造方法定义规则"></a>6.2.构造方法定义规则</h3><p>Java 中的构造方法必须与该类具有相同的名字，并且没有方法的返回类型(包括没有void) 。另外，构造方法一般都应用 public 类型来说明，这样才能在程序任意的位置创建类的实例–对象。</p><h3 id="6-3-示例"><a href="#6-3-示例" class="headerlink" title="6.3.示例"></a>6.3.示例</h3><p>下面是一个 Rectangle 类的构造方法，它带有两个参数，分别表示矩形的长和宽：</p><h3 id="6-4-说明"><a href="#6-4-说明" class="headerlink" title="6.4.说明"></a>6.4.说明</h3><p>每个类至少有一个构造方法。 如果不写一个构造方法， Java 编程语言将提供一个默认的，该构造方法没有参数，而且方法体为空。</p><p>注意：如果一个类中已经定义了构造方法则系统不再提供默认的构造方</p><h2 id="7-析构方法"><a href="#7-析构方法" class="headerlink" title="7.析构方法"></a>7.析构方法</h2><p>析构方法 finalize 的功能是： 当对象被从内存中删除时， 该成员方法将会被 自动调用。通常，在析构方法内，你可以填写用来回收对象内部的动态空间的代码。</p><p>特别注意：当我们去调用析构方法的时候，并不会引起该对象实例从内存中删除，而是不会起到任何作用。</p><p>在 Java 编程里面，一般不需要我们去写析构方法，这里只是了解一下就可以了。</p><h2 id="8-属性"><a href="#8-属性" class="headerlink" title="8.属性"></a>8.属性</h2><h3 id="8-1-属性是什么"><a href="#8-1-属性是什么" class="headerlink" title="8.1.属性是什么"></a>8.1.属性是什么</h3><p>简单点说，属性就是对象所具有的静态属性。</p><h3 id="8-2-定义规则"><a href="#8-2-定义规则" class="headerlink" title="8.2.定义规则"></a>8.2.定义规则</h3><p>Java 类中属性的声明采用如下格式：</p><p>访问修饰符 修饰符 类型 属性名称=初始值;</p><p>访问修饰符：可以使用四种不同的访问修饰符中的一种，包括 public(公共的)、protected(受保护的) ，无修饰符和 private(私有的) 。public 访问修饰符表示属性可以从任何其它代码调用。private 表示属性只可以由该类中的其它方法来调用。protected 将在以后的课程中讨论。</p><p>修饰符：是对属性特性的描述，例如后面会学习到的：static、final 等等。</p><p>类型：属性的数据类型，可以是任意的类型。</p><p>属性名称：任何合法标识符</p><p>初始值：赋值给属性的初始值。如果不设置，那么会自动进行初始化，基本类型使用缺省值，对象类型自动初始化为 null。</p><h3 id="8-3-说明"><a href="#8-3-说明" class="headerlink" title="8.3.说明"></a>8.3.说明</h3><p>属性有时候也被称为成员变量、实例变量、域，它们经常被互换使用。</p><h2 id="9-方法"><a href="#9-方法" class="headerlink" title="9.方法"></a>9.方法</h2><h3 id="9-1-方法是什么"><a href="#9-1-方法是什么" class="headerlink" title="9.1.方法是什么"></a>9.1.方法是什么</h3><p>方法就是对象所具有的动态功能。</p><h3 id="9-2-定义规则"><a href="#9-2-定义规则" class="headerlink" title="9.2.定义规则"></a>9.2.定义规则</h3><p>Java 类中方法的声明采用以下格式：访问修饰符 修饰符 返回值类型 方法名称 (参数列表) throws 异常列表 {方法体}</p><p>访问修饰符：可以使用四种不同的访问修饰符中的一种，包括 public(公共的)、protected(受保护的) ，无修饰符和 private(私有的) 。public 访问修饰符表示方法可以从任何其它代码调用。private 表示方法只可以由该类中的其它方法来调用。protected 将在以后的课程中讨论。</p><p>修饰符：是对方法特性的描述，例如后面会学习到的：static、final、abstract、synchronized 等等。</p><p>返回值类型：：表示方法返回值的类型。 如果方法不返回任何值， 它必须声明为 void(空)。</p><p>Java 技术对返回值是很严格的，例如，如果声明某方法返回一个 int 值，那么方法必须从所有可能的返回路径中返回一个 int 值(只能在等待返回该 int 值的上下文中被调用。 )</p><p>方法名称：可以是任何合法标识符，并带有用已经使用的名称为基础的某些限制条件。</p><p>参数列表：允许将参数值传递到方法中。列举的元素由逗号分开，而每一个元素包含一个类型和一个标识符。在下面的方法中只有一个形式参数，用 int 类型和标识符 days 来声明：public void test(int days){}</p><p>throws 异常列表：子句导致一个运行时错误(异常)被报告到调用的方法中，以便以合适的方式处理它。异常在后面的课程中介绍。</p><p>花括号内是方法体，即方法的具体语句序列。</p><h3 id="9-3-示例"><a href="#9-3-示例" class="headerlink" title="9.3.示例"></a>9.3.示例</h3><p>比如现在有一个“车”的类——Car， “车”具有一些基本的属性，比如四个轮子，一个方向盘，车的品牌等等。当然，车也具有自己的功能，也就是方法，比如车能够“开动”——run。要想车子能够开动，需要给车子添加汽油，也就是说，需要为 run 方法传递一些参数“油”进去。车子跑起来过后，我们需要知道当前车辆运行的速度，就需要 run 方法具有返回值“当前的速度” 。</p><h3 id="9-4-形参和实参"><a href="#9-4-形参和实参" class="headerlink" title="9.4.形参和实参"></a>9.4.形参和实参</h3><p>形参：就是形式参数的意思。是在定义方法名的时候使用的参数，用来标识方法接收的参数类型，在调用该方法时传入。</p><p>实参：就是实际参数的意思。是在调用方法时传递给该方法的实际参数。</p><p>比如：上面的例子中“int oil”就是个形式参数，这里只是表示需要加入汽油，这个方法才能正常运行，但具体加入多少，要到真正使用的时候，也就是调用这个方法的时候才具体确定，加入调用的时候传入“80” ，这就是个实际参数。</p><p>形参和实参有如下基本规则：</p><p>(1)：形参和实参的类型必须要一致，或者要符合隐含转换规则</p><p>(2)：形参类型不是引用类型时，在调用该方法时，是按值传递的。在该方法运行时，形参和实参是不同的变量，它们在内存中位于不同的位置，形参将实参的值复制一份，在该方法运行结束的时候形参被释放，而实参内容不会改变。</p><p>(3)：形参类型是引用类型时，在调用该方法时，是按引用传递的。运行时，传给方法的是实参的地址， 在方法体内部使用的也是实参的地址， 即使用的就是实参本身对应的内存空间。所以在函数体内部可以改变实参的值。</p><h3 id="9-5-参数可变的方法"><a href="#9-5-参数可变的方法" class="headerlink" title="9.5.参数可变的方法"></a>9.5.参数可变的方法</h3><p>从 JDK5.0 开始，提供了参数可变的方法。</p><p>当不能确定一个方法的入口参数的个数时，5.0 以前版本的 Java 中，通常的做法是将多个参数放在一个数组或者对象集合中作为参数来传递，5.0 版本以前的写法是：</p><p>int sum(Integer[] numbers){…}</p><p>//在别处调用该方法</p><p>sum(new Integer[] {12,13,20});</p><p>而在 5.0 版本中可以写为：</p><p>int sum(Integer… numbers){//方法内的操作}</p><p>注意：方法定义中是三个点</p><p>//在别处调用该方法</p><p>sum(12,13,20);//正确</p><p>sum(10,11); //正确</p><p>也就是说，传入参数的个数并不确定。但请注意：传入参数的类型必须是一致的，究其本质，就是一个数组。</p><p>显然，JDK5.0 版本的写法更为简易，也更为直观，尤其是方法的调用语句，不仅简化很多，而且更符合通常的思维方式，更易于理解。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lululua.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>二级（Java语言程序设计）考试大纲</title>
    <link href="https://lululua.cn/2019/09/10/Java%E4%BA%8C%E7%BA%A7%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/"/>
    <id>https://lululua.cn/2019/09/10/Java二级考试大纲/</id>
    <published>2019-09-10T10:20:08.728Z</published>
    <updated>2019-08-26T13:47:13.483Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>公共基础知识</strong></p><p><strong>基本要求</strong> </p><p>\1. 掌握算法的基本概念。</p><p>\2. 掌握基本数据结构及其操作。</p><p>\3. 掌握基本排序和查找算法。</p><p>\4. 掌握逐步求精的结构化程序设计方法。</p><p>\5. 掌握软件工程的基本方法，具有初步应用相关技术进行软件开发的能力。</p><p>\6. 掌握数据库的基本知识，了解关系数据库的设计。 </p><p><strong>考试内容</strong></p><p><strong>一、基本数据结构与算法</strong></p><p>\1. 算法的基本概念；算法复杂度的概念和意义（时间复杂度与空间复杂度）。</p><p>\2. 数据结构的定义；数据的逻辑结构与存储结构；数据结构的图形表示；线性结构与非线性结构的概念。</p><p>\3. 线性表的定义；线性表的顺序存储结构及其插入与删除运算。</p><p>\4. 栈和队列的定义；栈和队列的顺序存储结构及其基本运算。</p><p>\5. 线性单链表、双向链表与循环链表的结构及其基本运算。</p><p>\6. 树的基本概念；二叉树的定义及其存储结构；二叉树的前序、中序和后序遍历。</p><p>\7. 顺序查找与二分法查找算法；基本排序算法（交换类排序，选择类排序，插入类排序）。</p><p><strong>二、程序设计基础</strong></p><p>\1. 程序设计方法与风格。</p><p>\2. 结构化程序设计。</p><p>\3. 面向对象的程序设计方法，对象，方法，属性及继承与多态性。</p><p><strong>三、软件工程基础</strong></p><p>\1. 软件工程基本概念，软件生命周期概念，软件工具与软件开发环境。</p><p>\2. 结构化分析方法，数据流图，数据字典，软件需求规格说明书。</p><p>\3. 结构化设计方法，总体设计与详细设计。</p><p>\4. 软件测试的方法，白盒测试与黑盒测试，测试用例设计，软件测试的实施，单元测试、集成测试和系统测试。</p><p>\5. 程序的调试，静态调试与动态调试。</p><p><strong>四、数据库设计基础</strong></p><p>\1. 数据库的基本概念：数据库，数据库管理系统，数据库系统。</p><p>\2. 数据模型，实体联系模型及E-R图，从E-R图导出关系数据模型。</p><p>\3. 关系代数运算，包括集合运算及选择、投影、连接运算，数据库规范化理论。</p><p>\4. 数据库设计方法和步骤：需求分析、概念设计、逻辑设计和物理设计的相关策略。</p><p><strong>考试方式</strong></p><p>\1. 公共基础知识不单独考试，与其他二级科目组合在一起，作为二级科目考核内容的一部分。</p><p>\2. 上机考试，10道单项选择题，占10分。</p><p><strong>JAVA**</strong>语言程序设计**</p><p><strong>基本要求</strong></p><p>\1.  掌握Java语言的特点，实现机制和体系结构。</p><p>\2.  掌握Java语言中面向对象的特性。</p><p>\3.  掌握Java语言提供的数据类型和结构。</p><p>\4.  掌握Java语言编程的基本技术。</p><p>\5.  会编写Java用户界面程序。</p><p>\6.  会编写Java简单应用程序。</p><p>\7.  会编写Java小应用程序（Applet）。</p><p>\8.  了解Java语言的广泛应用。</p><p><strong>考试内容</strong></p><p><strong>一、Java语言的特点和实现机制</strong></p><p><strong>二、Java体系结构</strong></p><p>\1.  Java程序结构。</p><p>\2.  Java类库结构。</p><p>\3.  Java程序开发环境结构。</p><p><strong>三、Java语言中面向对象的特性</strong></p><p>\1.  面向对象编程的基本概念和特征。</p><p>\2.  类的基本组成和使用。</p><p>\3.  对象的生成、使用和删除。</p><p>\4.  包与接口。</p><p>\5.  Java类库的常用类和接口。</p><p><strong>四、Java简单数据类型及运算</strong></p><p>\1.  变量和常量。</p><p>\2.  基本数据类型及转换。</p><p>\3.  Java类库中对基本数据类型的类包装。</p><p>\4.  运算符和表达式运算。</p><p>\5.  字符串和数组。</p><p><strong>五、Java语言的基本语句</strong></p><p>\1.  条件语句。</p><p>\2.  循环语句。</p><p>\3.  注释语句。</p><p>\4.  异常处理语句。</p><p>\5.  表达式语句。</p><p><strong>六、Java编程技术基础</strong></p><p>\1.  输入输出流及文件操作。</p><p>\2.  线程的概念和使用。</p><p>\3.  程序的同步与共享。</p><p>\4.  Java语言的继承、多态和高级特性。</p><p>\5.  异常处理和断言概念。</p><p>\6.  Java语言的集合（Collections）框架和泛型概念。</p><p><strong>七、编写用户界面程序基础</strong></p><p>\1.  用AWT编写图形用户界面的基本技术。</p><p>\2.  用Swing编写图形用户界面的特点。</p><p>\3.  Swing的事件处理机制。</p><p><strong>八、编写小应用程序（Applet）基础</strong></p><p>\1.  Applet类的API基本知识。</p><p>\2.  Applet编写步骤及特点。</p><p>\3.  基于AWT和Swing编写用户界面。</p><p>\4.  Applet的多媒体支持和通信。</p><p><strong>九、Java SDK 6.0的下载和安装</strong></p><p><strong>考试方式</strong></p><p>上机考试，考试时长120分钟，满分100分。</p><p>\1.  题型及分值</p><p>单项选择题40分（含公共基础知识部分10分）、操作题60分（包括基本操作题、简单应用题及综合应用题）。</p><p>\2. 考试环境</p><p>NetBeans。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lululua.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java二级公共基础知识资料</title>
    <link href="https://lululua.cn/2019/09/10/Java%E4%BA%8C%E7%BA%A7%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%B5%84%E6%96%99/"/>
    <id>https://lululua.cn/2019/09/10/Java二级公共基础知识资料/</id>
    <published>2019-09-10T10:20:08.726Z</published>
    <updated>2019-08-26T13:42:28.416Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><strong>第一章</strong>  <strong>数据结构与算法</strong></p><p><strong>【考点1**</strong>】算法的基本概念**</p><p>1、算法：是指一组有穷的指令集，是解题方案的准确而完整的描述。算法不等于程序，也不等于计算方法。</p><p>2、算法的基本特征：</p><p>1）确定性，算法中每一步骤都必须有明确定义，不允许有多义性；</p><p>2）有穷性，算法必须能在有限的时间内做完，即能在执行有限个步骤后终止；</p><p>3）可行性，算法原则上能够精确地执行；</p><p>4）拥有足够的情报。</p><p>3、算法的组成要素：一个算法由数据对象的运算和操作以及其控制结构这两部分组成。</p><p>4、算法的基本运算和操作：算术运算，逻辑运算，关系运算，数据传输。</p><p>5、算法的基本控制结构：顺序，选择，循环。</p><p>6、算法基本设计方法：列举法、归纳法、递推、递归、减半递推技术。</p><p><strong>【考点2**</strong>】算法的复杂度**</p><p>1、算法效率的度量——算法的复杂度：时间复杂度和空间复杂度。</p><p>1）算法时间复杂度：指执行算法所需要的计算工作量。通常，一个算法所用的时间包括编译时间和运行时间。</p><p>2）算法空间复杂度：指执行这个算法所需要的内存空间。包括算法程序所占的空间，输入的初始数据所占的空间，算法执行过程中所需的额外空间。</p><p>空间复杂度和时间复杂度并不相关。</p><p><strong>【考点3**</strong>】数据结构的基本概念**</p><p>数据：数据是客观事物的符号表示，是能输入到计算机中并被计算程序识别和处理的符号的总称，如文档，声音，视频等。</p><p>数据元素：数据元素是数据的基本单位。</p><p>数据对象：数据对象是性质相同的数据元素的集合。</p><p>数据结构：是指由某一数据对象中所有数据成员之间的关系组成的集合。</p><p><strong>【考点4**</strong>】逻辑结构和存储结构**</p><p>1、数据结构可分为数据的逻辑结构和存储结构。</p><p>1）数据的逻辑结构是对数据元素之间的逻辑关系的描述，与数据的存储无关，是面向问题的，是独立于计算机的。它包括数据对象和数据对象之间的关系。</p><p>2）数据的存储结构也称为数据的物理结构，是数据在计算机中的存放的方式，是面向计算机的，它包括数据元素的存储方式和关系的存储方式。</p><p>2、存储结构和逻辑结构的关系：一种数据的逻辑结构可以表示成多种存储结构即数据的逻辑结构和存储结构不一定一一对应。</p><p>3、常见的存储结构有：顺序，链接，索引等。采用不同的存储结构其数据处理的效率是不同的。</p><p><strong>【考点5**</strong>】线性结构和非线性结构**</p><p>1、线性结构的条件（一个非空数据结构)：（1）有且只有一个根结点；（2）每一个结点最多有一个前件，也最多有一个后件。</p><p>2、非线性结构：不满足线性结构条件的数据结构。</p><p>栈、队列、双向链表是线性结构，树、二叉树为非线性结构。</p><p><strong>【考点6**</strong>】线性表及其顺序存储结构**</p><p>1、线性表是由一组数据元素构成，数据元素的位置只取决于自己的序号，元素之间的相对位置是线性的。</p><p>2、在复杂线性表中，由若干项数据元素组成的数据元素称为记录；由多个记录构成的线性表称为文件。</p><p>3、非空线性表的结构特征：</p><p>（1）有且只有一个根结点a1，它无前件；</p><p>（2）有且只有一个终端结点an，它无后件；</p><p>（3）除根结点与终端结点外，其他所有结点有且只有一个前件，也有且只有一个后件。</p><p>结点个数n称为线性表的长度，当n=0时，称为空表。</p><p>4、线性表的顺序存储结构具有以下两个基本特点：</p><p>（1）线性表中所有元素所占的存储空间是连续的；</p><p>（2）线性表中各数据元素在存储空间中是按逻辑顺序依次存放的。</p><p>元素ai的存储地址为：ADR(ai)=ADR(a1)+(i-1)*k，ADR(a1)为第一个元素的地址，k代表每个元素占的字节数。</p><p>5、顺序表的运算：查找、插入、删除。</p><p><strong>【考点7**</strong>】线性链表**</p><p>线性链表是线性表的链式存储结构，数据结构中的每一个结点对应于一个存储单元，这种存储单元称为存储结点，简称结点。结点由两部分组成：(1) 用于存储数据元素值，称为数据域；(2) 用于存放指针，称为指针域，用于指向前一个或后一个结点。</p><p>在链式存储结构中，存储数据结构的存储空间可以不连续，各数据结点的存储顺序与数据元素之间的逻辑关系可以不一致，而数据元素之间的逻辑关系是由指针域来确定的。</p><p>链式存储方式既可用于表示线性结构，也可用于表示非线性结构。</p><p>线性单链表中，HEAD称为头指针，HEAD=NULL（或0）称为空表。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p><p>双向链表有两个指针：左指针（Llink）指向前件结点，右指针（Rlink）指向后件结点。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png" alt="img"><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img"></p><p>循环链表：循环链表与单链表的不同的是它的最后一个结点的指针域存放的事指向第一个结点的指针而单链表存放的是空指针。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png" alt="img"></p><p>线性链表的基本运算：查找、插入、删除。</p><p><strong>【考点8**</strong>】栈**</p><p>1、栈的基本概念</p><p>栈是一种特殊的线性表，只允许在表的一端进行插入和删除的线性表；插入，删除的一端为栈顶，另一端为栈底；当表中没有元素时为空栈。</p><p>栈是一种后进先出（或先进后出Last In First Out）的线性表。栈具有记忆功能。栈的实例：火车调度，子弹夹。</p><p>2、栈的存储结构</p><p>顺序存储结构：用一组地址连续的存储单元即一维数组来存储；</p><p>链式存储：用线性链表来存储；</p><p>3、栈的基本运算</p><p>(1) 入栈运算，在栈顶位置插入元素；</p><p>(2) 退栈运算，删除元素(取出栈顶元素并赋给一个指定的变量)；</p><p>(3) 读栈顶元素，将栈顶元素赋给一个指定的变量，此时指针无变化。</p><p><strong>【考点9**</strong>】队列**</p><p>1.队列的基本概念</p><p>队列是一种特殊的线性表，只允许在表的一端插入，在另一端删除，允许插入的一端是队尾（rear），允许删除的一端为队头（front）；当表中没有元素是空队列；队列是一种先进先出的线性表。(FIFO)</p><p>2、队列的存储结构</p><p>顺序存储：一维数组。</p><p>链式存储：线性链表。</p><p>3、队列的运算: </p><p>(1) 入队运算：从队尾插入一个元素；  (2) 退队运算：从队头删除一个元素。</p><p>4、队列的顺序存储结构一般采用循环队列的形式。循环队列s=0表示队列为空；s=1且front=rear表示队满。</p><p>5、计算循环队列的元素个数：“尾指针减头指针”，若为负数，再加其容量即可。</p><p><strong>【考点10**</strong>】树的基本概念**</p><p>树是一种非线性结构，是n个结点的有限集。当n=0 时为空树，n&gt;0时为非空树。结点的度：结点所拥有的子树的个数。</p><p>叶子结点：度为0的结点。</p><p>分支结点：除叶子结点以外的结点。</p><p>结点的层次：根结点在第一层，同一层上左右结点的子结点在下一层。</p><p>树的深度：所处层次最大的那个结点的层次。</p><p>树的度：树中所有结点的度的最大值。</p><p><strong>【考点11**</strong>】二叉树及其基本性质**</p><p>1、二叉树的概念</p><p>二叉树是一种特殊的树形结构，每个结点最多只有两棵子树，且有左右之分不能互换，因此，二叉树有五种不同的形态。</p><p>2、二叉树的性质</p><p>性质1 在二叉树的第k层上，最多有2k-1(k≥1）个结点。</p><p>性质2 深度为m的二叉树最多有2m-1个结点。</p><p>性质3 在任意一棵二叉树中，度为0的结点（叶子结点）总是比度为2的结点多一个。</p><p>性质4 具有n个结点的二叉树，其深度不小于[log2n]+1,其中[log2n]表示为log2n的整数部分。</p><p><strong>【考点12**</strong>】满二叉树与完全二叉树**</p><p>满二叉树：除最后一层外，每一层上的所有结点都有两个子结点。在满二叉树中，每一层上的结点数都达到最大值，即在满二叉树的第k层上有2k-1个结点，且深度为m的满二叉树有2m－1个结点。</p><p>完全二叉树是指这样的二叉树：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</p><p>满二叉树是完全二叉树，而完全二叉树一般不是满二叉树。</p><p><strong>【考点13**</strong>】完全二叉树的性质**</p><p>性质1 具有n个结点的完全二叉树的深度为[log2n]+1。</p><p>性质2 完全二叉树中度为1的结点数为0或1。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img"><strong>【考点14**</strong>】二叉树的遍历**</p><p>1、前序遍历：先访问根结点、然后遍历左子树，最后遍历右子树；并且，在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>前序遍历图5可得：ABCDFHEG。</p><p>2、中序遍历：先遍历左子树、然后访问根结点，最后遍历右子树；并且，在遍历左、右子树时，仍然先遍历左子树，然后访问根结点，最后遍历右子树。</p><p>中序遍历图5可得：BAFHDCGE。</p><p>3、后序遍历：先遍历左子树、然后遍历右子树，最后访问根结点；并且，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后访问根结点。</p><p>后序遍历图5可得：BHFDGECA。</p><p><strong>【考点15**</strong>】顺序查找**</p><p>顺序查找是从表的一端开始，依次扫描表中的各个元素，并与所要查找的数进行比较。</p><p>在下列两种情况下也只能采用顺序查找： </p><p>（1）如果线性表为无序表，则不管是顺序存储结构还是链式存储结构，只能用顺序查找。 </p><p>（2）即使是有序线性表，如果采用链式存储结构，也只能用顺序查找。</p><p><strong>【考点16**</strong>】二分查找**</p><p>二分查找的条件：（1）用顺序存储结构   (2)线性表是有序表。</p><p>对于长度为n的有序线性表，在最坏情况下，二分法查找只需比较log2n次，而顺序查找需要比较n次。</p><p><strong>【考点17**</strong>】排序**</p><p>1、交换排序</p><p>（1）冒泡排序法，在最坏的情况下，冒泡排序需要比较次数为n(n－1)/2。 </p><p>（2）快速排序法 ，在最坏的情况下，快速排序需要比较次数为n(n－1)/2。</p><p>2、插入类排序法：</p><p>（1）简单插入排序法，最坏情况需要n(n-1)/2次比较；</p><p>（2）希尔排序法，最坏情况需要O(n1.5)次比较。（大写O是算法复杂度的表示方法）</p><p>3、选择类排序法：</p><p>（1）简单选择排序法，最坏情况需要n(n-1)/2次比较；</p><p>（2）堆排序法，最坏情况需要O(nlog2n)次比较。</p><p>相比以上几种(除希尔排序法外)，堆排序法的时间复杂度最小。</p><p><strong>第二章</strong>  <strong>程序设计基础</strong></p><p><strong>【考点1**</strong>】程序设计方法与风格**</p><p>形成良好的程序设计风格需注意： </p><p>1、源程序文档化； 2、数据说明的方法； 3、语句的结构；  4、输入和输出。</p><p><strong>【考点2**</strong>】结构化程序设计方法的四条原则**</p><p>1、自顶向下； 2、逐步求精； 3、模块化； 4、限制使用goto语句。</p><p><strong>【考点3**</strong>】结构化程序的基本结构**</p><p>顺序结构：是最基本、最普通的结构形式，按照程序中的语句行的先后顺序逐条执行。</p><p>选择结构：又称为分支结构，它包括简单选择和多分支选择结构。</p><p>循环结构：根据给定的条件，判断是否要重复执行某一相同的或类似的程序段。循环结构对应两类循环语句：先判断后执行的循环体称为当型循环结构；先执行循环体后判断的称为直到型循环结构。</p><p><strong>【考点4**</strong>】面向对象的程序设计及面向对象方法的优点**</p><p>面向对象的程序设计以对象为核心，强调对象的抽象性，封装性，继承性和多态性。</p><p>面向对象方法的优点</p><p>（1）人类习惯的思维方法一致； （2）稳定性好； （3）可重用性好；</p><p>（4）易于开发大型软件产品；   （5）可维护性好。</p><p><strong>【考点5**</strong>】对象及其特点**</p><p>对象（object）：面向对象方法中最基本的概念，可以用来表示客观世界中的任何实体，对象是实体的抽象。</p><p>对象的基本特点：</p><p>（1）标识惟一性； （2）分类性； （3）多态性； （4）封装性； （5）模块独立性好。</p><p><strong>【考点6**</strong>】属性，类和实例**</p><p>属性：即对象所包含的信息，它在设计对象时确定，一般只能通过执行对象的操作来改变。</p><p>类：是具有相似属性与操作的一组对象。类是关于对象性质的描述。类是对象的抽象，对象是其对应类的一个实例。</p><p><strong>【考点7**</strong>】消息及其组成**</p><p>消息：是一个实例与另一个实例之间传递的信息。对象间的通信靠消息传递。它请求对象执行某一处理或回答某一要求的信息，它统一了数据流和控制流。</p><p>消息的组成包括：</p><p>(1)接收消息的对象的名称； （2）消息标识符，也称消息名； （3）零个或多个参数。</p><p><strong>【考点8**</strong>】继承和多态**</p><p>1、继承：是使用已有的类定义作为基础建立新类的定义技术，广义指能够直接获得已有的性质和特征，而不必重复定义他们。</p><p>2、继承具有传递性，一个类实际上继承了它上层的全部基类的特性。</p><p>3、继承分单继承和多重继承。单继承指一个类只允许有一个父类，即类等级为树形结构；多重继承指一个类允许有多个父类。</p><p>4、多态性：是指同样的消息被不同的对象接受时可导致完全不同的行动的现象。</p><p><strong>第三章</strong>  <strong>软件工程基础</strong></p><p><strong>【考点1**</strong>】软件定义与软件特点**</p><p>软件指的是计算机系统中与硬件相互依存的另一部分，包括程序、数据和相关文档的完整集合。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>程序</td><td>软件开发人员根据用户需求开发的、用程序设计语言描述的、适合计算机执行的指令序列</td></tr><tr><td>数据</td><td>使程序能正常操纵信息的数据结构</td></tr><tr><td>文档</td><td>与程序的开发、维护和使用有关的图文资料</td></tr></tbody></table><p>1、软件的特点：</p><p>1）软件是一种逻辑实体，具有抽象性；</p><p>2）软件的生产与硬件不同，它没有明显的制作过程；</p><p>3）软件在运行、使用期间不存在磨损、老化问题；</p><p>4）软件的开发、运行对计算机系统具有依赖性，受计算机系统的限制，这导致了软件移植的问题；</p><p>5）软件复杂性高，成本昂贵；</p><p>6）软件开发涉及诸多的社会因素。</p><p>2、根据应用目标的不同，软件可分应用软件、系统软件和支撑软件（或工具软件）。 </p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>应用软件</td><td>为解决特定领域的应用而开发的软件，如办公自动化软件</td></tr><tr><td>系统软件</td><td>计算机管理自身资源，提高计算机使用效率并为计算机用户提供各种服务的软件，如操作系统</td></tr><tr><td>支撑软件（或工具软件）</td><td>支撑软件是介于两者之间，协助用户开发软件的工具性软件。</td></tr></tbody></table><p><strong>【考点2**</strong>】软件的生命周期**</p><p>软件生命周期是指软件产品从提出、实现、使用维护到停止使用退役的整个过程。可分为软件定义，软件开发及软件维护3个阶段。软件生命周期中，能够准确确定软件系统必须做什么和必须具备哪些功能的阶段是：需求分析。</p><p><img src="file:///C:/Users/lu/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png" alt="img">                  </p><p>定义阶段                    开发阶段                       维护阶段</p><p><strong>【考点3**</strong>】软件危机和软件工程的概念**</p><p>软件危机泛指在计算机软件的开发和维护过程中遇到的一系列严重的问题，集中表现在成本，质量。生产效率等几个方面。</p><p>所谓软件工程是指采用工程的概念、原理、技术和方法指导软件的开发与维护。是建立并使用完善的工程化原则，以较经济的手段获得，能在实际机器上有效运行的可靠软件的一系列方法；软件工程的主要思想强调在软件开发过程中需要应用工程化原则。软件工程的核心思想是把软件当作一个工程产品来处理。</p><p>软件工程包括3个要素：方法，工具和过程</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>方法</td><td>方法是完成软件工程项目的技术手段</td></tr><tr><td>工具</td><td>工具支持软件的开发、管理、文档生成</td></tr><tr><td>过程</td><td>过程支持软件开发的各个环节的控制、管理</td></tr></tbody></table><p><strong>【考点4**</strong>】软件工程过程**</p><p>软件工程过程是把软件转化为输出的一组彼此相关的资源活动，包含4种基本活动：</p><p>（1）P(plan)——软件规格说明；   （2）D(do)——软件开发；</p><p>（3）C(check)——软件确认；      （4）A(action)——软件演进。</p><p><strong>【考点5**</strong>】软件开发技术和软件工程管理**</p><p>1、软件工程的理论和技术性研究的内容主要包括软件开发技术和软件工程管理。</p><p>2、软件开发技术包括软件开发方法学、开发过程、开发工具和软件工程环境，其主体内容是软件开发方法学。</p><p>3、软件开发方法包括分析方法，设计方法和程序设计方法。</p><p>4、软件工程管理包括软件管理学，软件工程经济学，软件心理学等。</p><p>5、软件管理学包括人员组织，进度安排，质量保证，配置管理，项目计划等。</p><p>6、软件工程经济学是研究软件开发中成本的估算，成本效益的方法和技术。</p><p><strong>【考点6**</strong>】软件工程的原则**</p><p>软件工程的原则：抽象，信息隐蔽，模块化，局部化，确定性，一致性，完备性，可验证性。</p><p><strong>【考点7**</strong>】需求分析概述**</p><p>需求分析阶段的工作：需求获取，需求分析，编写需求规格说明书，需求评审。</p><p>需求分析方法有：</p><p>（1）结构化需求分析方法； </p><p>①面向数据结构的Jackson方法（ISD）；</p><p>②面向数据流的结构化分析方法（SA）；</p><p>③面向数据结构的结构化数据系统开发方法（DSSD）；</p><p>（2）面向对象的分析的方法（OOA）。</p><p>从需求分析建立的模型的特性来分：静态分析和动态分析。</p><p><strong>【考点8**</strong>】结构化方法和结构化分析方法**</p><p>1、结构化方法包括结构化分析方法，结构化设计方法，结构化编程方法。</p><p>结构化方法中，软件功能分解属于总体设计阶段。</p><p>2、结构化分析方法的概念</p><p>结构化分析方法是面向数据流自顶而下逐步求精进行需求分析的方法。</p><p>结构化分析方法在软件需求分析阶段的应用。</p><p>3、结构化分析的常用工具</p><p>（1）数据流图（DFD-Data Flow Diagram）：是结构化分析方法中用于系统逻辑模型的一种工具。它以图形的方式描绘在系统中流动和处理的过程。</p><p>数据流图中四种基本的符号。</p><p>1）箭头：表示数据流，数据流是数据在系统中传播的路径。</p><p>2）圆或椭圆：表示加工，加工又称为数据处理，是对数据流进行某些操作或变换。</p><p>3）双横：表示数据存储（数据源）。数据存储又称为文件，指暂时保存的数据，它可以是数据库文件或任何形式的数据组织。</p><p>4）方框：数据的源点或终点。它是软件系统外部环境中的实体，统称外部实体</p><p>（2）数据字典（DD）：它是结构分析方法的核心，是用来描述系统中所用到的全部数据和文件的文档,作用是对DFD中出现的被命名的图形元素进行确切解释。</p><p>​    数据字典由以下4类元素组成</p><p>1）数据流  2）数据流分量 3）数据存储 4）处理 </p><p>（3）判定树（决策树）：是一种描述加工的图形工具，适合描述时候处理中具有多个判断，而且每个决策与若干条件有关。</p><p>（4）判定表：与判定树类似，也是一种描述加工的图形工具。如果一个加工逻辑有多个条件、多个操作，并且在不同的条件组合下执行不同的操作，那么可以使用判定表来描述。</p><p><strong>【考点9**</strong>】软件需求规格说明书**</p><p>软件需求规格说明书（SRS，Software Requirement Specification）是需求分析阶段得出的最主要的文档。软件需求规格说明书的特点：有正确性、无歧义性、完整性、可验证性、一致性、可理解性、可修改性和可追踪性。其中最重要的是无歧义性。</p><p><strong>【考点10**</strong>】软件设计的基本概念**</p><p>软件设计是确定系统的物理模型。</p><p>软件设计是开发阶段最重要的步骤，是将需求准确地转化为完整的软件产品或系统的唯一途径。</p><p>从技术观点上看，软件设计包括软件结构设计、数据设计、接口设计、过程设计。</p><p>（1）结构设计定义软件系统各主要部件之间的关系； </p><p>（2）数据设计将分析时创建的模型转化为数据结构的定义； </p><p>（3）接口设计是描述软件内部、软件和协作系统之间以及软件与人之间如何通信； </p><p>（4）过程设计则是把系统结构部件转换为软件的过程性描述。</p><p>从工程管理角度来看，软件设计分两步完成：概要设计和详细设计。</p><p>（1）概要设计将软件需求转化为软件体系结构、确定系统级接口、全局数据结构或数据库模式； </p><p>（2）详细设计确立每个模块的实现算法和局部数据结构，用适当方法表示算法和数据结构的细节。</p><p><strong>【考点11**</strong>】软件设计的基本原理**</p><p>1、软件设计中应该遵循的基本原理和与软件设计有关的概念：</p><p>模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能。</p><p>抽象化：抽出事物的本质特性而暂时不考虑它们的细节。</p><p>信息隐藏和局部化：信息隐蔽是指在一个模块内包含的信息（过程或数据），对于不需要这些信息的其他模块来说是不能访问的，实现信息隐蔽依靠对象的封装。</p><p>模块独立性：模块独立性是指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少且接口简单。模块的独立程度是评价设计好坏的重要度量标准。</p><p><strong>【考点12**</strong>】耦合性和内聚性**</p><p>衡量软件的模块独立性是用耦合性和内聚性两个定性的度量标准。</p><p>耦合性：是对一个软件结构内不同模块之间互联程度的度量。耦合性的强弱取决于模块间接口的复杂程度。</p><p>内聚性：是一个模块内部各个元素间彼此结合的紧密程度的度量。</p><p>一个模块的内聚性越强则该模块的模块独立性越强。一个模块与其他模块的耦合性越强则该模块的模块独立性越弱。</p><p>在结构程序设计中，模块划分的原则是模块内具有高内聚度，模块间具有低耦合度。</p><p>耦合和内聚的种类。</p><p>耦合度由低到高：非直接耦合，数据耦合，标记耦合，控制耦合，外部耦合，公共耦合，内容耦合。</p><p>内聚性由强到弱：功能内聚，顺序内聚，通信内聚，过程内聚，时间内聚，逻辑内聚，偶然内聚。</p><p><strong>【考点13**</strong>】结构化设计方法**</p><p>结构化分析方法是面向数据流自顶而下，逐步求精进行需求分析的方法，基本思想将软件设计成由相对独立，单一功能的模块组成的结构，与结构分析方法衔接使用，以数据流图为基础得到软件的模块结构，适用于变换型结构和事物型结构的目标系统。</p><p>1、概要设计的任务：（1）划分出组成系统的物理元素  （2）设计软件的结构</p><p>2、概要设计的工具：</p><p>结构图（SC-Structure Chart）也称程序结构图，在结构图中，模块用一个矩形表示，箭头表示模块间的调用关系。可以用带注释的箭头表示模块调用过程中来回传递的信息。还可用带实心圆的箭头表示传递的是控制信息，空心圆箭心表示传递的是数据。</p><p>结构图的基本形式：基本形式、顺序形式、重复形式、选择形式。</p><p>结构图有四种模块类型：传入模块、传出模块、变换模块和协调模块。</p><p>程序结构图中的专业术语：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>深度</td><td>表示控制的层数</td></tr><tr><td>上级模块，从属模块</td><td>上，下两层模块a和b，且有a调用b，则a是上级模块，b是从属模块</td></tr><tr><td>宽度</td><td>整体控制跨度（最大模块的层）的表示</td></tr><tr><td>扇入</td><td>调用该模块的模块个数</td></tr><tr><td>扇出</td><td>一个模块直接调用的其他模块数</td></tr><tr><td>原子模块</td><td>树中位于叶子节点的模块</td></tr></tbody></table><p>3、面向数据流的设计方法</p><p>任何软件系统都可以用数据流图表示，典型的数据流类型有两种：变换型和事务型。</p><p>变换型系统结构图由输入、中心变换、输出三部分组成。</p><p>4、设计的准则</p><p>（1）提高模块独立性。</p><p>（2）模块规模适中。</p><p>（3）深度，宽度，扇出和扇入适当。如果深度过大，则说明有的控制模块可能简单了，如果宽度过大，则说明系统的控制过于集中，扇出过大说明模块过分复杂，需要控制和协调过多的下级模块，应适当加中间层次，扇出过小可以把模块进一步分解成若干小模块，或合并到上级模块中，扇入越大则共享该模块的上级数目越多。好的软件设计结构通常顶层高扇出，中间扇出较少，底层高扇入。</p><p>（4）使模块的作用域在该模块的控制域内。</p><p>（5）减少模块的接口和界面的复杂性。</p><p>（6）设计成单入口，单出口的模块。</p><p>（7）设计功能可预测的模块。</p><p>详细设计常用的设计工具（工程设计工具）：图形工具，表格工具和语言工具。</p><p>图形工具：</p><p>程序流程图：箭头表示控制流，方框表示加工步骤，菱形表示逻辑条件。</p><p>N-S图：有五种基本图形。</p><p>PAD图：问题分析图，有五种基本图型。</p><p>表格工具：判定表。</p><p>语言工具：PDL——过程设计语言（结构化的英语和伪码）。</p><p><strong>【考点14**</strong>】软件测试的目标和准则**</p><p>软件测试的目标：发现程序中的错误。</p><p>软件测试的准则：</p><p>（1）所有测试都是应追溯到需求。</p><p>（2）严格执行测试计划，排除测试的随意性。</p><p>（3）充分注意测试中的群集表现。程序中存在错误的概率与该程序中已发现的错误数成正比。</p><p>（4）程序员应避免检查自己的程序。</p><p>（5）穷举测试不可能。穷举测试是把程序所有可能的执行路径都进行检查，即使小规模的程序的执行路径数也相当大，不可能穷尽，说明测试只能证明程序有错，不能证明程序中无错。</p><p>（6）妥善保存测试计划，测试用例出错统计和最终分析报告。</p><p><strong>【考点15**</strong>】软件测试方法**</p><p>从是否需要执行被测软件的角度分为静态测试和动态测试;按功能分为白盒测试和黑盒测试</p><p>1、静态测试和动态测试</p><p>静态测试包括代码检查、静态结构分析、代码质量度量。不实际运行软件，主要通过人工进行。</p><p>动态测试是通过运行软件来检验软件中的动态行为和运行结果的正确性。动态测试的关键是使用设计高效、合理的测试用例。测试用例就是为测试设计的数据，由测试输入数据（输入值集）和预期的输出结果（输出值集）两部份组成。测试用例的设计方法一般分为两类：黑盒测试方法和白盒测试方法。</p><p>2、白盒测试和黑盒测试</p><p>（1）白盒测试 </p><p>白盒测试也称为结构测试或逻辑测试，是把程序看成装在一只透明的白盒子里，测试者完全了解程序的结构和处理过程。它根据程序的内部逻辑来设计测试用例，检查程序中的逻辑通路是否都按预定的要求正确地工作。</p><p>白盒测试的基本原则：</p><p>（1）保证所测模块中每一独立路径至少执行一次。</p><p>（2）保证所测模块所有判断的每一分支至少执行一次。</p><p>（3）保证所测模块每一循环都在边界条件和一般条件下至少各执行一次。</p><p>（4）验证所有内部数据结构的有效性。</p><p>（5）按照白盒测试的基本原则，“白盒”法是穷举路径测试。</p><p>白盒测试的方法：逻辑覆盖，基本路经测试。</p><p>（2）黑盒测试 </p><p>黑盒测试也称功能测试或数据驱动测试，是把程序看成一只黑盒子，测试者完全不了解，或不考虑程序的结构和处理过程。它根据规格说明书的功能来设计测试用例，检查程序的功能是否符合规格说明的要求。</p><p>黑盒测试的方法：等价划分法，边界值分析法，错误推测法。</p><p><strong>【考点16**</strong>】软件测试的实施**</p><p>软件测试过程分4个步骤，即单元测试、集成测试、验收测试和系统测试。</p><p>单元测试是对软件设计的最小单位——模块进行正确性检验的测试，单元测试的根据是源程序和详细设计说明书，单元测试的技术可以采用静态分析和动态测试。</p><p>单元测试期间对模块进行的测试：模块接口，局部数据结构，重要的执行通路，出错处理通路，边界条件。</p><p>驱动模块相当于被测模块的主程序，它接收测试数据，并传给所测模块，输出实际测试结果</p><p>桩模块通常用于代替被测模块调用的其他模块，其作用仅做少量的数据操作，是一个模拟子程序。</p><p>集成测试是测试和组装软件的系统化技术，主要目的是发现与接口有关的错误，集成测试的依据是概要设计说明书。</p><p>集成测试的方法：非增量方式组装和增量方法组装。</p><p>增量方式包括自顶而下的增量方式，自底而上的增量方式和混合增量方式。</p><p>确认测试的任务是验证软件的功能和性能，确认测试的实施首先运用黑盒测试方法，对软件进行有效性测试，即验证被测软件是否满足需求规格说明确认的标准。 </p><p>检查软件产品是否符合需求定义的过程是：确认测试。</p><p>系统测试是通过测试确认的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、支撑软件、数据和人员等其他系统元素组合在一起，在实际运行（使用）环境下对计算机系统进行一系列的集成测试和确认测试。</p><p>系统测试的具体实施一般包括：功能测试、性能测试、操作测试、配置测试、外部接口测试、安全性测试等。 </p><p><strong>【考点17**</strong>】程序调试**</p><p>在对程序进行了成功的测试之后将进入程序调试（通常称Debug，即排错）。</p><p>程序的调试任务是诊断和改正程序中的错误。</p><p>程序调试和软件测试的区别：</p><p>（1）软件测试是尽可能多地发现软件中的错误，而程序调试先要发现软件的错误，然后借助于一定的调试工具去执行找出软件错误的具体位置。</p><p>（2）软件测试贯穿整个软件生命期，调试主要在开发阶段。</p><p>程序调试的基本步骤：</p><p>（1）错误定位。从错误的外部表现形式入手，研究有关部分的程序，确定程序中出错位置，找出错误的内在原因；</p><p>（2）修改设计和代码，以排除错误； </p><p>（3）进行回归测试，防止引进新的错误。</p><p>软件调试可分为静态调试和动态调试。静态调试主要是指通过人的思维来分析源程序代码和排错，是主要的设计手段，而动态调试是辅助静态调试的。</p><p>主要的调试方法有：</p><p>（1）强行排错法； （2）回溯法； （3）原因排除法，包括演绎法，归纳法和二分法。</p><p><strong>第四章</strong>  <strong>数据库设计基础</strong></p><p><strong>【考点1**</strong>】数据库的基本概念**</p><p>数据（Data）是数据库存储的基本对象，是描述事物的符号记录。</p><p>数据库（DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合，它具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享，所以数据库技术的根本目标是解决数据共享问题。</p><p>数据库管理系统（DBMS）是数据库的管理机构，负责数据库中的数据组织、数据操纵、数据维护、控制及保护和数据服务等。数据库管理系统是数据库系统的核心。数据库系统包含数据库和数据库管理系统。</p><p>数据库管理系统的功能：</p><p>（1）数据模式定义：即为数据库构建其数据框架；</p><p>（2）数据存取的物理构建：为数据模式的物理存取与构建提供有效的存取方法与手段；</p><p>（3）数据操纵：为用户使用数据库的数据提供方便，如查询、插入、修改、删除等以及简单的算术运算及统计；</p><p>（4）数据的完整性、安全性定义与检查；</p><p>（5）数据库的并发控制与故障恢复；</p><p>（6）数据的服务：如拷贝、转存、重组、性能监测、分析等。</p><p>为完成数据库管理系统的功能，数据库管理系统提供相应的数据语言：</p><p>数据定义语言（DDL）：负责数据模式定义和数据物理存取构建。</p><p>数据操纵语言（DML）：负责数据的操纵。</p><p>数据控制语言（DCL）：负责数据完整性，安全性的定义与检查以及并发控制，故障恢复等功能。</p><p>数据语言按使用方式具有两个结构形式：交互式命令语言（自含型和自主型语言）和宿主型语言。</p><p>数据库管理员（DBA）的工作：数据库设计，数据库维护，改善系统性能，提高系统效率。</p><p>数据库系统（DBS）是指在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员和用户构成。</p><p>数据库应用系统（DBAS）是数据库系统再加上应用软件及应用界面这三者所组成，具体包括：数据库、数据库管理系统、数据库管理员、硬件平台、软件平台、应用软件、应用界面。</p><p><strong>【考点2**</strong>】数据管理的发展和基本特点**</p><p>数据管理技术的发展经历了三个阶段：人工管理阶段、文件系统阶段和数据库系统阶段，数据独立性最高的阶段是数据库系统阶段。</p><p>人工管理阶段特点：（1）计算机系统不提供对用户数据的管理功能（2）数据不能共享（3）不单独保存数据。</p><p>文件系统阶段的缺陷：（1）数据冗余（2）不一致性（3）数据联系弱。</p><p>数据库系统的发展阶段：第一代的网状、层次数据库系统；第二代的关系数据库系统；第三代的以面向对象模型为主要特征的数据库系统。</p><p>数据库系统的基本特点：</p><p>（1）数据的高集成性 （2）数据的高共享性和低冗余性 （3）数据高独立性 （4）数据统一管理与控制。</p><p>数据独立性是数据与程序间的互不依赖性，即数据库中的数据独立于应用程序而不依赖于应用程序。 </p><p>数据的独立性一般分为物理独立性与逻辑独立性两种。 </p><p>（1）物理独立性：当数据的物理结构（包括存储结构、存取方式等）改变时，其逻辑结构，应用程序都不用改变。 </p><p>（2）逻辑独立性：数据的逻辑结构改变了，如修改数据模式、增加新的数据类型、改变数据间联系等，用户的应用程序可以不变。</p><p><strong>【考点3**</strong>】数据系统的内部结构体系**</p><p>1、数据统系统的三级模式：</p><p>（1）概念模式，也称逻辑模式，是对数据库系统中全局数据逻辑结构的描述，是全体用户公共数据视图。一个数据库只有一个概念模式。 </p><p>（2）外模式，外模式也称子模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，一个概念模式可以有若干个外模式。 </p><p>（3）内模式，内模式又称物理模式，它给出了数据库物理存储结构与物理存取方法。一个数据库只有一个内模式。 </p><p>内模式处于最底层，它反映了数据在计算机物理结构中的实际存储形式，概念模式处于中间层，它反映了设计者的数据全局逻辑要求，而外模式处于最外层，它反映了用户对数据的要求。</p><p>2、数据库系统的两级映射 （详见教材第55页）</p><p>两级映射保证了数据库系统中数据的独立性。 </p><p>（1）概念模式到内模式的映射。该映射给出了概念模式中数据的全局逻辑结构到数据的物理存储结构间的对应关系；</p><p>（2）外模式到概念模式的映射。概念模式是一个全局模式而外模式是用户的局部模式。一个概念模式中可以定义多个外模式，而每个外模式是概念模式的一个基本视图。</p><p><strong>【考点4**</strong>】数据模型的基本概念**</p><p>数据模型按不同的应用层次分为：</p><p>概念数据模型：简称概念模型，是一种面向客观世界，面向用户的模型，不涉及具体的硬件环境和平台也与具体的软件环境无关的模式，它是整个数据模型的基础。</p><p>逻辑数据模型：又称数据模型，它是一种面向数据库的模型。分为层次模型，网状模型，关系模型和面向对象模型，其中层次模型和网状模型统称为非关系模型。层次模型用树型结构表示实体之间联系的模型。</p><p>物理数据模型：又称物理模型，它是一种面向计算机物理表示的模型。</p><p><strong>【考点5**</strong>】E<strong><strong>—R</strong></strong>模型**</p><p>1、E-R模型的基本概念 </p><p>（1）实体：现实世界中的事物可以抽象成为实体，实体是概念世界中的基本单位，它们是客观存在的且又能相互区别的事物。</p><p>（2）属性：现实世界中事物均有一些特性，这些特性可以用属性来表示。</p><p>（3）码：唯一标识实体的属性集称为码。</p><p>（4）域：属性的取值范围称为该属性的域。</p><p>（5）联系：在现实世界中事物间的关联称为联系。</p><p>两个实体集间的联系实际上是实体集间的函数关系，这种函数关系可以有下面几种：一对一的联系、一对多或多对一联系、多对多。</p><p>2、E-R模型的的图示法</p><p>E-R模型用E-R图来表示，E-R图包含了表示实体集、属性和联系的方法。</p><p>（1）实体的表示：用矩形表示实体集，在矩形内写上该实体集的名字。</p><p>（2）属性的表示：用椭圆形表示属性，在椭圆形内写上该属性的名称。</p><p>（3）联系的表示：用菱形表示联系，菱形内写上联系名。</p><p><strong>【考点6**</strong>】层次模型和网状模型**</p><p>层次模型是有根的定向有序树，是数据库系统中最早出现的数据模型。网状模型对应的是有向图。</p><p>层次模型和网状模型各自应满足的条件</p><table><thead><tr><th>模型名称</th><th>满足的条件</th></tr></thead><tbody><tr><td>层次模型</td><td>（1）有且只有一个结点没有双亲结点，这个结点称为根结点   （2）根以外的其他结点有且只有一个双亲结点</td></tr><tr><td>网状模型</td><td>（1）允许一个以上的结点无双亲   （2）一个结点可以有多于一个的双亲</td></tr></tbody></table><p><strong>【考点7**</strong>】关系模型及相关概念**</p><p>关系模式采用二维表来表示，由关系数据结构，关系操纵和关系完整性约束3部分组成，在关系数据库中，用来表示实体间联系的是关系。</p><p>关系：一个关系对应一张二维表。一个关系就是一个二维表，但是一个二维表不一定是一个关系。</p><p>元组：表中的一行即为一个元组。</p><p>属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名。</p><p>分量：元组中的一个属性值，是不可分割的基本数据项。</p><p>域：属性的取值范围。</p><p>在二维表中惟一标识元组的最小属性值称为该表的键或码。二维表中可能有若干个健，它们称为表的候选码或候选健。从二维表的所有候选键选取一个作为用户使用的键称为主键或主码。表A中的某属性集是某表B的键，则称该属性值为A的外键或外码。</p><p>关系操纵：数据查询、数据的删除、数据插入、数据修改。 </p><p>关系模型允许定义三类数据约束，它们是实体完整性约束、参照完整性约束以及用户定义的完整性约束。其中实体完整性约束、参照完整性约束必须满足的完整性约束条件。参照完整性约束不允许关系应用不存在的元组。实体完整性约束要求关系的主键中属性值不能为空，这是数据库完整性的最基本要求。</p><p><strong>【考点8**</strong>】关系代数**</p><p>关系代数是一种抽象的查询语言，关系代数的运算对象是关系，运算结果也是关系。运算对象，运算符和运算结果是运算的三大要素。集合运算符，专门的运算符，算术比较符和逻辑运算符。</p><p>关系模型的基本运算：（1）插入  （2）删除   (3)修改  （4）查询（包括投影、选择、笛卡尔积运算）还有扩充运算交、除、连接及自然连接运算。</p><p>关系代数的5个基本操作中并，差，交，笛卡尔积是二目运算。</p><p>设关系R和S具有相同的关系模式</p><p>1、并：R和S的并是由属于R或属于S的所有元组构成的集合。</p><p>2、差：R和S的差是由属于R但是不属于S的元组构成的集合</p><p>3、笛卡尔积：设R和S的元数分别为r和s，R和S的笛卡尔积是一个（r+s）元的元组集合，每个元组的前r个分量来自R的一个元组，后s个分量来自S的一个元组。运算后得到的新表的元组数是R*S，属性是r+s。</p><p>4、交：属于R又属于S的元组构成的集合。</p><p>5、投影：一元运算，对一个关系进行垂直切割，消去某些列，并重新按排列的顺序。</p><p>6、选择：一元运算，根据某些条件对关系进行水平分割。即选择符合条件的元组。</p><p>7、除：给定关系R（X，Y）和S（Y，Z），其中X，Y，Z是属性组，R中的Y和S中Y可以有不同的属性名，但必须出自相同的域集。</p><p>8、连接：也称θ连接运算，是一种二元运算，它的操作是从两个关系的笛卡尔积中选取属性间满足一定条件的元组，以合并成一个大关系。连接运算包括等值连接和不等值连接。连接运算后得到的新表的属性是运算前表中属性相加。即多于原来关系中属性的个数。</p><p>9、自然连接：自然连接满足的条件是（1）两关系间有公共域（2）通过公共域的相等值进行连接。</p><p><strong>【考点9**</strong>】数据库设计和管理**</p><p>数据库设计中有两种方法，面向数据的方法和面向过程的方法。</p><p>面向数据的方法是以信息需求为主，兼顾处理需求；面向过程的方法是以处理需求为主，兼顾信息需求。由于数据在系统中稳定性高，数据已成为系统的核心，因此面向数据的设计方法已成为主流。</p><p>数据库设计目前一般采用生命周期法，即将整个数据库应用系统的开发分解成目标独立的若干阶段。它们是：需求分析阶段、概念设计阶段、逻辑设计阶段、物理设计阶段。</p><p>一个低一级范式的关系模式，通过模式分解可以转化为若干个高一级范式的关系模式的集合，这种过程就叫规范化。</p><p>概念结构设计是将需求分析阶段得到的用户需求抽象为信息结构即概念模型的过程，它是整个数据库设计的关键。</p><p>逻辑结构设计的任务是将E—R图转换成关系数据模型的过程。</p><p>数据库的物理结构是指数据库在物理设备上的存储结构和存取方法。它依赖于给定的计算机系统。</p><p>常用的存取方法：索引方法，聚簇方法和HASH方法。</p><p>数据库管理的内容：</p><p>（1）数据库的建立，它是数据库管理的核心，包括数据模式的建立和数据加载。 </p><p>（2）数据库的重组。</p><p>（3）数据库安全性控制。</p><p>（4）数据库的完整性控制，数据库的完整性是指数据的正确性和相容性。</p><p>（5）数据库的故障恢复。</p><p>（6）数据库监控。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lululua.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>本地安装worldpress</title>
    <link href="https://lululua.cn/2019/09/09/worldpress/"/>
    <id>https://lululua.cn/2019/09/09/worldpress/</id>
    <published>2019-09-09T11:44:49.591Z</published>
    <updated>2019-09-09T12:02:38.325Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="下载XAMPP"><a href="#下载XAMPP" class="headerlink" title="下载XAMPP"></a>下载XAMPP</h4><pre><code>http://soft.onlinedown.net/soft/225718.htm</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><pre><code>Apache可能遇到的问题：无法启动Apache，解决办法：打开Apache中的Confing将listen改为8080,访问的话不能再用http://localhost因为这个默认是80，要改用http://localhost:8080MySql:点击Admin 创建一个自己的数据库,步奏可以参考https://jingyan.baidu.com/article/1e5468f955d65b484961b7bb.html</code></pre><h4 id="下载worldpress"><a href="#下载worldpress" class="headerlink" title="下载worldpress"></a>下载worldpress</h4><pre><code>将下好的worldpress解压到xampp\htdocs</code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>访问：http://localhost/解压的文件包名称根据提示安装</code></pre><h4 id="worldpress设置"><a href="#worldpress设置" class="headerlink" title="worldpress设置"></a>worldpress设置</h4><pre><code>省略。。。。(目前尚未研究)</code></pre><h4 id="wordpress搬家教程-从本地搬到服务器"><a href="#wordpress搬家教程-从本地搬到服务器" class="headerlink" title="wordpress搬家教程(从本地搬到服务器)"></a>wordpress搬家教程(从本地搬到服务器)</h4><pre><code>参考：https://jingyan.baidu.com/article/2a138328e57dba074b134f63.html</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lululua.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库系统(1)</title>
    <link href="https://lululua.cn/2019/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%80%E8%8A%82/"/>
    <id>https://lululua.cn/2019/09/09/数据库第一节/</id>
    <published>2019-09-09T02:26:45.411Z</published>
    <updated>2019-09-09T02:50:12.325Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h6 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h6><ul><li>数据结构化</li><li>数据的共享性高，冗余度低且易扩充</li><li>数据的独立性高<ul><li>物理独立性</li><li>逻辑独立性</li></ul></li><li>数据由数据库管理系统统一管理和控制<ul><li>数据的安全性保护</li><li>数据安全性检查</li><li>并发控制</li><li>数据恢复</li></ul></li></ul><h6 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h6><ul><li><p>第一类：概念模型</p><ul><li>1.信息世界中的基本概念<ul><li>1.实体</li><li>2.属性</li><li>3.码</li><li>4.实体型</li><li>5.实体集</li><li>6.联系</li></ul></li><li>2.概念模型的一种表示方法：实体-联系方法</li></ul></li><li><p>第二类：</p><ul><li>逻辑模型</li><li>物理模型   </li></ul></li><li><p>重要组成要素</p><ul><li>数据结构</li><li>数据操作</li><li>数据的完整性约束条件</li></ul></li><li><p>常用的数据模型</p><ul><li>层次模型<ul><li>层次模型的数据结构<ul><li>有且只有一个结点没有双亲结点，这结点称为根节点</li><li>根以外的其他结点有且只有一个双亲结点</li></ul></li><li>层次模型的数据操纵与完整性约束</li><li>层次模型的优缺点<ul><li>数据结构比较简单清晰</li><li>层次数据库的查询效率高</li><li>层次数据模型提供了良好的完整性支持</li><li>现实世界很多联系都是非层次性</li><li>应用程序的编写比较复杂</li><li>查询子女结点必须通过双亲结点</li><li>层次命令趋于程序化</li></ul></li></ul></li><li>网状模型</li><li>关系模型</li><li>面向对象数据模型</li><li>对象关系数据模型</li><li>半结构化数据模型</li></ul></li><li></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="数据库系统" scheme="https://lululua.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Git服务器</title>
    <link href="https://lululua.cn/2019/09/08/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://lululua.cn/2019/09/08/搭建Git服务器/</id>
    <published>2019-09-08T03:38:14.911Z</published>
    <updated>2019-09-09T02:51:42.158Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="1-从本地导出-git文件夹"><a href="#1-从本地导出-git文件夹" class="headerlink" title="1.从本地导出.git文件夹"></a>1.从本地导出.git文件夹</h4><pre><code>git clone --bare my_project my_project.gitmy_project:  .git结尾的文件my_project.git: 生成的文件</code></pre><h4 id="2-放到远程服务器上"><a href="#2-放到远程服务器上" class="headerlink" title="2.放到远程服务器上"></a>2.放到远程服务器上</h4><pre><code>$ scp -r my_project.git 用户名@服务器ip:/home/放到服务器的文件位置</code></pre><h4 id="3-在服务器上下载上传的文件"><a href="#3-在服务器上下载上传的文件" class="headerlink" title="3.在服务器上下载上传的文件"></a>3.在服务器上下载上传的文件</h4><pre><code>安装git:  yum install -y git创建用户：useradd 用户名用户密码：password 用户密码su 用户名// 这步很重要，不切换用户后面会很麻烦创建新的文件夹在文件夹里 执行 git init --bare，git init --bare --shared下载 git clone 用户名@服务器ip:/home/放到服务器</code></pre><p>遇到的问题：<br>    Git无法访问：解决办法找到本地计算机的.ssh文件，找到known_hosts删除你服务器的记录<br>    权限：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lululua.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言链表</title>
    <link href="https://lululua.cn/2019/09/07/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://lululua.cn/2019/09/07/链表基础知识总结/</id>
    <published>2019-09-07T15:44:37.562Z</published>
    <updated>2019-09-07T23:55:01.843Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><div class="blog-content-box">    <div class="article-header-box">        <div class="article-header">            <div class="article-title-box">                <span class="article-type type-1 float-left">原</span>                <h1 class="title-article">链表基础知识总结</h1>            </div>            <div class="article-info-box">                <div class="article-bar-top" style="height: 24px;">                                                                                                                                            <span class="time">2018年05月02日 19:47:49</span>                    <a class="follow-nickName" href="https://me.csdn.net/u012531536" target="_blank" rel="noopener">zql_3393089</a>                    <span class="read-count">阅读数 62396</span><span class="article_info_click" style="position: static;">更多</span>                                                                    <div class="tags-box space">                                <span class="label">分类专栏：</span>                                                                                                            <a class="tag-link" target="_blank" rel="noopener" href="https://blog.csdn.net/u012531536/article/category/7635058">                                            On the way                                        </a>                                                                                                </div>                                        </div>                <div class="operating">                                    </div>            </div>        </div>    </div>    <article class="baidu_pl">                <div id="article_content" class="article_content clearfix">                                                <div class="article-copyright">                <span class="creativecommons">                <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">                    </a>            <span>版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。 </span>               <div class="article-source-link2222">                    本文链接：<a href="https://blog.csdn.net/u012531536/article/details/80170893" target="_blank" rel="noopener">https://blog.csdn.net/u012531536/article/details/80170893</a>                </div>            </span>                    </div>                                                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">                                        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">                <div class="htmledit_views" id="content_views">                                            <p>链表和数组作为算法中的两个基本数据结构，在程序设计过程中经常用到。尽管两种结构都可以用来存储一系列的数据，但又各有各的特点。</p><p>数组的优势，在于可以方便的遍历查找需要的数据。在查询数组指定位置（如查询数组中的第4个数据）的操作中，只需要进行1次操作即可，时间复杂度为O(1)。但是，这种时间上的便利性，是因为数组在内存中占用了连续的空间，在进行类似的查找或者遍历时，本质是指针在内存中的定向偏移。然而，当需要对数组成员进行添加和删除的操作时，数组内完成这类操作的时间复杂度则变成了O(n)。</p><p>链表的特性，使其在某些操作上比数组更加高效。例如当进行插入和删除操作时，链表操作的时间复杂度仅为O(1)。另外，因为链表在内存中不是连续存储的，所以可以充分利用内存中的碎片空间。除此之外，链表还是很多算法的基础，最常见的哈希表就是基于链表来实现的。基于以上原因，我们可以看到，链表在程序设计过程中是非常重要的。本文总结了我们在学习链表的过程中碰到的问题和体会。</p><p>接下来，我们将对链表进行介绍，用C语言分别实现：链表的初始化、创建、元素的插入和删除、链表的遍历、元素的查询、链表的删除、链表的逆序以及判断链表是否有环等这些常用操作。并附上在Visual Studio 2010 中可以运行的代码供学习者参考。</p><p>说到链表，可能有些人还对其概念不是很了解。我们可以将一条链表想象成环环相扣的结点，就如平常所见到的锁链一样。链表内包含很多结点（当然也可以包含零个结点）。其中每个结点的数据空间一般会包含一个数据结构（用于存放各种类型的数据）以及一个指针，该指针一般称为next，用来指向下一个结点的位置。由于下一个结点也是链表类型，所以next的指针也要定义为链表类型。例如以下语句即定义了链表的结构类型。</p><p><span style="font-family:'Times New Roman';">typedef struct LinkList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p><span style="font-family:'Times New Roman';">{</span></p><p><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int Element;</span></p><p><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LinkList * next;</span></p><p><span style="font-family:'Times New Roman';">}LinkList;</span></p><h3><a name="t0"></a><span style="font-size:18px;">链表初始化</span></h3><p>在对链表进行操作之前，需要先新建一个链表。此处讲解一种常见的场景下新建链表：在任何输入都没有的情况下对链表进行初始化。</p><p>链表初始化的作用就是生成一个链表的头指针，以便后续的函数调用操作。在没有任何输入的情况下，我们首先需要定义一个头指针用来保存即将创建的链表。所以函数实现过程中需要在函数内定义并且申请一个结点的空间，并且在函数的结尾将这个结点作为新建链表的头指针返回给主调函数。本文给出的例程是生成一个头结点的指针，具体的代码实现如下：</p><p align="left"><span style="color:#0000FF;">linklist</span> *&nbsp; <span style="color:#880000;">List_init</span>()</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>= (<span style="color:#0000FF;">linklist</span>*)<span style="color:#A000A0;">malloc</span>(<span style="color:#0000FF;">sizeof</span>(<span style="color:#0000FF;">linklist</span>));</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">HeadNode</span> == <span style="color:#A000A0;">NULL</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#880000;">printf</span>(<span style="color:#A31515;">"</span><span style="color:#A31515;">空间缓存不足</span><span style="color:#A31515;">"</span>);</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; HeadNode-&gt;<span style="color:#000080;">Element</span>= 0;</p><p align="left">&nbsp;&nbsp;&nbsp; HeadNode-&gt;<span style="color:#000080;">next</span>= <span style="color:#000080;">NULL</span>;</p><p align="left">&nbsp;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span>HeadNode;</p><p align="left">}</p><p>当然,初始化的过程或者方法不只这一种，其中也包含头指针存在的情况下对链表进行初始化，此处不再一一罗列。</p><p>这里引申一下，此处例程中返回的链表指针为该链表的头结点，相对应的还有一个头指针的概念。头指针内只有指针的元素，并没有数据元素，但头结点除了指针还有数据。</p><p>头指针就是链表的名字，仅仅是个指针而已。头结点是为了操作的统一与方便而设立的，放在第一个有效元素结点（首元结点）之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。一般情况下见到的链表的指针多为头指针，但最近在一个程序员编程网站leetcode中发现，题目中所给的链表一般是首元结点作为第一个元素，而不是头指针。</p><p>下图为头指针与头结点以及首元结点的关系。</p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20180502195346635" alt=""><br></p><h3><a name="t1"></a><span style="font-size:18px;">链表创建</span></h3><p>创建链表需要将既定数据按照链表的结构进行存储，本文以一种最简单的方式来演示：使用数组对链表赋值。将原来在连续空间存放的数组数据，放置在不连续的链表空间中，使用指针进行链接。</p><p>链表创建的步骤一般使用给定的头指针以及需要初始化的数据序列作为输入参数，本文使用数组作为输入数据序列。在下面的例程中，先将首元结点使用数组第一个元素初始化，再在首元结点之后创建新的链表结点赋值数组内余下的数据。具体实现如下：</p><p align="left"><span style="color:#0000FF;">void</span> <span style="color:#880000;">CreatList</span>(<span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>,<span style="color:#0000FF;">int</span> *<span style="color:#000080;">InData</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">DataNum</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">i</span> = 0;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode = (</span><span style="color:#0000FF;">linklist</span>*<span style="color:#000080;">) HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">for</span>(<span style="color:#000080;">i</span> = 0;<span style="color:#000080;">i</span>&lt;<span style="color:#000080;">DataNum</span>;<span style="color:#000080;">i</span>++)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#000080;">Element</span> = <span style="color:#000080;">InData</span>[<span style="color:#000080;">i</span>];</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">i</span>&lt; DataNum-1)<span style="color:#008000;">//</span> <span style="color:#008000;">由于每次赋值后需要新建结点，为了保证没有多余的废结点</span></p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurrentNode-&gt;next =(linklist *)<span style="color:#000080;">malloc</span>(<span style="color:#0000FF;">sizeof</span>(linklist));</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#A000A0;">CurrentNode</span>= <span style="color:#0000FF;">CurrentNode</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>-&gt;next= NULL;</p><p align="left">}</p><p>程序内先新建了一个指针变量CurrentNode用来表示当前的结点指针。最初，我们让CurrentNode指向了首元结点HeadNode的位置。然后根据输入数组的大小进行循环赋值，赋值完成之后再重新申请一个结点空间用来存放下一个结点的内容，并且将当前结点指针CurrentNode指向新生成的结点。由于链表创建函数调用时已经存在一个首元结点，按照这个逻辑最终在使用最后一个数组数据赋值之后还会多生成一个结点。因此，为了保证没有冗余的结点，循环内需要用DataNum-1来控制结点数量。</p><p>另外，C语言的初学者需要注意：无论被调子函数内含在几个参数，虽然子函数内的形参使用的是主函数内实参的指针，但在子函数内是不会改变主函数里实参的地址的。也就是说，只要子函数不返回指针，子函数的内容就不会影响主函数内的参数指针。正如程序中CurrentNode的指针最初是主函数内的头指针传递进来的，虽然创建链表的函数内CurrentNode的指针一直在往后移动，但并不会改变主调函数内的首元结点的指针。本文链表的学习过程中会大量使用指针，建议各位学习者在打牢基础后再进行学习。</p><h3><a name="t2"></a><span style="font-size:18px;">插入链表结点</span></h3><p>链表创建完之后，下面我们将介绍如何向链表内插入结点。一般添加结点可以分为两类：一类是在链表尾部插入；另一类为在中间插入。</p><p>链表结尾添加结点的步骤就是新建一个链表结点，将其链接到当前链表尾指针。</p><p>在中间结点插入结点的步骤稍微复杂一些，其中也包含两种情况，分别是在指定结点前插入和指定结点后插入。其操作原理一样，本文只对指定位置后插入结点进行介绍。指定结点前插入结点留给大家尝试。</p><p>假设一个链表内存在几个几点A1，A2,A3,A4….，当根据要求需要在指定位置之后（比如A2结点）插入一个新结点时。首先我们需要新建立一个结点NodeToInsert，然后将新结点的next指向A3，并且将A2的next指针指向新建立的结点NodeToInsert，切记操作顺序不要改变。如果操作顺序变换一下，先将A2的next指向了新建立的结点，那么我们就丢失了A3的寻址方式。因此，在将A2的next指向其他任何地方之前，请务必将A3的地址存在NodeToInsert或者某个新建节点内。</p><p>插入结点的具体操作如下：</p><p align="left"><span style="color:#0000FF;">bool</span> <span style="color:#880000;">InsertList</span>(<span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">LocateIndex</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">InData</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">i</span>=1;<span style="color:#008000;">//</span> <span style="color:#008000;">由于起始结点</span><span style="color:#000080;">HeadNode</span><span style="color:#008000;">是头结点，所以计数从</span><span style="color:#008000;">1</span><span style="color:#008000;">开始</span></p><p align="left">&nbsp;&nbsp;&nbsp; linklist *CurrentNode= (<span style="color:#0000FF;">linklist</span> *) HeadNode;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#008000;">//</span><span style="color:#008000;">将</span><span style="color:#008000;">CurrentNode</span><span style="color:#008000;">指向待插入位置的前一个结点（</span><span style="color:#008000;">index -1</span><span style="color:#008000;">）</span></p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(CurrentNode&amp;&amp; i&lt;LocateIndex-1)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= <span style="color:#000080;">CurrentNode</span>-&gt;next;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">i</span>++;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; linklist *<span style="color:#000080;">NodeToInsert</span>=(linklist*)<span style="color:#0000FF;">malloc</span>(<span style="color:#0000FF;">sizeof</span>(<span style="color:#000080;">linklist</span>));</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">NodeToInsert</span> == <span style="color:#A000A0;">NULL</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#880000;">printf</span>(<span style="color:#A31515;">"</span><span style="color:#A31515;">空间缓存不足</span><span style="color:#A31515;">"</span>);</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">ERROR</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">NodeToInsert</span>-&gt;Element= <span style="color:#0000FF;">InData</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">NodeToInsert</span>-&gt;<span style="color:#000080;">next</span> = CurrentNode-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">NodeToInsert</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">OK</span>;</p><p align="left">}</p><h3><a name="t3"></a><span style="font-size:18px;">删除链表结点</span></h3><p>对应于插入链表结点，链表的基本操作中同样也有删除链表结点。删除结点包括删除指定位置的结点和指定元素的结点。其基本原理都是先锁定待删除的结点的位置，然后将该结点的后置结点链接到前置结点的next指针处。这样中间这个结点即我们要删除的结点就从原来的链表中脱离开来。相对于原来的链表，即删除了该结点。</p><p align="left"><span style="color:#0000FF;">bool</span> <span style="color:#880000;">DeleteList</span>(<span style="color:#0000FF;">linklist</span> * <span style="color:#000080;">HeadNode</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">index</span>, <span style="color:#0000FF;">int</span> * <span style="color:#000080;">DataToDel</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">i</span> = 1;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode</span> &nbsp;= <span style="color:#000080;">HeadNode</span>;&nbsp; </p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">NodeToDelete</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#008000;">//</span><span style="color:#008000;">将</span><span style="color:#008000;">CurrentNode</span><span style="color:#008000;">指向待删除位置的前一个结点（</span><span style="color:#008000;">index -1</span><span style="color:#008000;">）</span></p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(CurrentNode&amp;&amp; i&lt;<span style="color:#000080;">index</span>-1)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= CurrentNode-&gt;next;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">i</span>++;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; NodeToDelete = CurrentNode-&gt;next;</p><p align="left">&nbsp;&nbsp;&nbsp; *<span style="color:#000080;">DataToDel</span> =NodeToDelete-&gt;Element;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>-&gt;next= <span style="color:#000080;">NodeToDelete</span>-&gt;next;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">free</span>(<span style="color:#000080;">NodeToDelete</span>);</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">OK</span>;</p><p align="left">}</p><p>此处为什么还要重新建立一个指针来记录或者保存待删除的结点呢？明明一个简单的步骤CurrentNode -&gt;next = CurrentNode -&gt;next-&gt;next;就可以将这个结点CurrentNode-&gt;next删除了，为什么要多此一举呢？</p><p>此处新建的链表类型的指针NodeToDelete是为了释放CurrentNode-&gt;next。直接使用CurrentNode -&gt;next = CurrentNode -&gt;next-&gt;next只是将该节点从链表中剔除，但是没有将其空间从内存中释放。而且,经过了CurrentNode -&gt;next = CurrentNode -&gt;next-&gt;next这个赋值语句之后，我们已经丢失了原本需要删除的结点的地址。所以，在删除之前新建了个结点用来保存待删除的结点地址，以便后面对内存空间的释放。</p><h3><a name="t4"></a><span style="font-size:18px;">获取链表长度&amp;链表遍历</span></h3><p>获取链表的长度实际上和遍历链表具有相同的操作。遍历的过程将链表内的结点都访问了一边。获取链表长度的具体步骤是遍历链表之后能够记录并返回链表结点个数。</p><p>本文给出获取链表长的函数代码。</p><p align="left"><span style="color:#0000FF;">int</span> <span style="color:#880000;">GetListLength</span>(<span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>)</p><p align="left">{</p><p align="left">&nbsp;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">ListLength</span> = 0;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode</span>= (<span style="color:#0000FF;">linklist</span>*)<span style="color:#000080;"> HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">CurrentNode</span>)<span style="color:#008000;">//</span> <span style="color:#008000;">当前指针不为空时可以计数累加</span></p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListLength++;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= <span style="color:#000080;">CurrentNode</span>-&gt;next;&nbsp;&nbsp;&nbsp; <span style="color:#008000;">//</span><span style="color:#008000;">指针移到下一结点</span></p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span>ListLength;</p><p align="left">}</p><p>在该函数中，出现了CurrentNode = CurrentNode -&gt;next的表示方法，这是将CurrentNode -&gt;next这个结点的指针移动到了当前这个结点CurrentNode，下一次使用CurrentNode指针的时候CurrentNode实际已经指向了下一个结点CurrentNode -&gt;next。所以这也是常说到的结点后移。</p><p>对于链表内的赋值操作我们总结出几种情况：</p><h3><a name="t5"></a><span style="font-size:18px;">获取链表元素</span></h3><p>接下来我们将“给定链表中的某一个位置，返回该位置的数据值”和“返回链表内某一个元素的位置”这两个问题放在一起介绍。</p><p>这两种情况的思路都是需要遍历链表。在给定元素值的情况下，定义一个元素序号随着遍历的过程累加，遍历的过程校验链表的结点是否与给定的元素匹配，如果匹配则返回元素位置的序号；在给定位置的情况下就更简单一些，元素序号累加到对应位置，返回对应结点的元素即可。</p><p>本文只列出给定元素值的例子：</p><p align="left"><span style="color:#0000FF;">int</span> <span style="color:#880000;">LocateElement</span>(<span style="color:#0000FF;">linklist</span> * <span style="color:#000080;">HeadNode</span>,<span style="color:#0000FF;">int</span> <span style="color:#000080;">DataToLocate</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">int</span> <span style="color:#000080;">LocateIndex</span> = 1;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode</span>= (<span style="color:#0000FF;">linklist</span>*)<span style="color:#000080;"> HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">CurrentNode</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#000080;">Element</span>== <span style="color:#000080;">DataToLocate</span>)</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span><span style="color:#000080;">LocateIndex</span>;<span style="color:#008000;"> //</span><span style="color:#008000;">找到位置返回</span></p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= <span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#880000;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">LocateIndex</span>++;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> -1;<span style="color:#008000;"> //</span><span style="color:#008000;">如果没有这个值，返回</span><span style="color:#008000;">-1</span></p><p align="left">&nbsp;</p><p align="left">}</p><p>本函数的逻辑是如果遍历链表之后能够找到与所给元素匹配的结点，则将该结点的位置返回。但如果没有匹配的结点的话，则返回一个-1，表示获取元素位置失败。</p><h3><a name="t6"></a><span style="font-size:18px;">链表置空</span></h3><p>链表置空又可以称为销毁链表。同样是在遍历的前提下，一直到链表结尾结束，所有遍历到的链表结点均释放掉空间，具体代码如下：</p><p align="left"><span style="color:#0000FF;">bool</span> <span style="color:#880000;">DestroyList</span>(<span style="color:#0000FF;">linklist</span> * <span style="color:#000080;">HeadNode</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">pNext</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">CurrentNode</span>= (<span style="color:#0000FF;">linklist</span>*)<span style="color:#000080;"> HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">CurrentNode</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pNext</span> = <span style="color:#000080;">CurrentNode</span>-&gt;<span style="color:#880000;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#A000A0;">free</span>(<span style="color:#000080;">CurrentNode</span>);</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">CurrentNode</span>= <span style="color:#000080;">pNext</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">HeadNode</span>-&gt;<span style="color:#880000;">next</span> = <span style="color:#A000A0;">NULL</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#A000A0;">OK</span>;</p><p align="left">}</p><h3><a name="t7"></a><span style="font-size:18px;">链表逆序</span></h3><p>链表的逆序有很多种思路，本文介绍一种将当前结点的下一结点一直往头指针之后移动的思路。</p><p>假设当前有5个结点，head、a1、a2、a3、a4、a5，他们的头指针是head。我们的思路便是将a1作为当前元素一直往后遍历，并且将a1后面的数据依次挪到head之后。 &nbsp;&nbsp;</p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20180502195718402" alt=""><br></p><p>在第一次搬移的过程中，需要将a1的下一个元素a2放在head之后。如图所示，当前结点选定为a1，起一个变量名为current，当前结点的下一个结点为pNext，则a2便成了pNext = current-&gt;next。如果想要将pNext移到head之后，我们按照图中第1步先将a3连接到a1的后面，然后第2步再将head后面的整体链表放到要移动的a2的后面，也就是pNext-&gt;next= head-&gt;next，第3步将a2移到head之后。这三个步骤下来，我们的第一次反转工作就算完成了。此时的链表链表就变成了head、a2、a1、a3、a4、a5，如图所示：</p><p style="text-align:center;">                              <img src="https://img-blog.csdn.net/20180502195849229" alt=""><br></p><p>如果上面移动的步骤不按图中进行会出现什么情况呢？假设现在按照3-2-1的步骤来实现a2移动到head后面。当先进行第三步之后，即head-&gt;next = pNext;这一步直接将a2挪到了head之后。然后我们接下来应该再将原来head后面的一串数据链接到刚刚移动到head后面的a2后面，此处由于head后面的数据已经被pNext更新了，此时head后面是a2结点，所以在执行第二步以后，链表就变成了无限循环的链表，而且循环的元素值是a2。</p><p>按照上图正确的顺序实现第一次反转以后，可以判定当前的current指针是否已经是尾指针，如果不是就可以继续执行。第二次反转后链表就变成了head、a3、a2、a1、a4、a5。因此当把链表内的最后一个元素也移动到head之后时，链表逆序的工作就算完成了。</p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20180502195918818" alt=""><br></p><p>具体的代码实现如下。</p><p align="left"><span style="color:#0000FF;">linklist</span> * <span style="color:#880000;">ListRotate</span>(<span style="color:#0000FF;">linklist</span> * <span style="color:#000080;">HeadNode</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span>* <span style="color:#000080;">current</span>,*<span style="color:#000080;">pNext</span>,*<span style="color:#000080;">pPrev</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pPrev</span> = (<span style="color:#0000FF;">linklist</span>*)<span style="color:#A000A0;">malloc</span>(<span style="color:#0000FF;">sizeof</span>(<span style="color:#0000FF;">linklist</span>));</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">pPrev</span> == <span style="color:#A000A0;">NULL</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#880000;">printf</span>(<span style="color:#A31515;">"</span><span style="color:#A31515;">空间缓存不足</span><span style="color:#A31515;">"</span>);</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">ERROR</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pPrev</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">current</span> = <span style="color:#000080;">HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">current</span>-&gt;<span style="color:#000080;">next</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pNext</span> = <span style="color:#000080;">current</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">current</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">pNext</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pNext</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">pPrev</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pPrev</span>-&gt;<span style="color:#000080;">next</span> = <span style="color:#000080;">pNext</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#000080;">pPrev</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">}</p><h3><a name="t8"></a>链表判断是否有环</h3><p>判断链表是否存在环的过程中，通常最先想到的方法就是从定义下手，有环的话就没有尾结点，也就是说不存在一个结点的next指针是null。通过这种思路可以对有环无环进行判定，但需要判定到何时呢？</p><p>当遍历了4000个结点都没有遇到null结点，难道就可以断定这就是一个有环的链表吗？如果它的第4001个结点就是尾结点呢？很多情况下，我们是不知道链表的长度的，所以我们很难确定需要判定到哪一个结点才能确定链表是否为环形链表。因此我们需要借助快指针、慢指针的概念，这是目前用来判断链表内有环无环的最通用有效的方法。</p><p>假设有这样一种情况，有两辆车，一辆车每秒钟可以跑n米，另外一辆速度要快一些，每秒能跑2n米，这两辆车都匀速运行。如果在一个没有交叉点的跑道上，这时跑道上有一个终点，快车和慢车同时在起始点相遇出发之后，一直到终点，快车和慢车的距离只会越拉越大，等到快车到达终点的时候，两者之间的距离差最大。假想一种情况，如果跑道的终点与起始点连接了起来，虽然说从慢车的角度看，快车在前方越来越远。但快车的角度看，慢车在后面越来越远，但在前面看的话确实越来越近。所以在一个环形的跑道上，快车终究会有第二次与慢车相遇，此时正好超车一圈。</p><p>函数的执行过程如下：</p><p align="left"><span style="color:#0000FF;">bool</span> <span style="color:#880000;">IsListLoop</span>(<span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">HeadNode</span>)</p><p align="left">{</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">linklist</span> *<span style="color:#000080;">pFast</span>,*<span style="color:#000080;">pSlow</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pFast</span> = <span style="color:#000080;">pSlow</span> = <span style="color:#000080;">HeadNode</span>;</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">while</span>(<span style="color:#000080;">pFast</span> &amp;&amp; <span style="color:#000080;">pSlow</span>)</p><p align="left">&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pSlow</span> = <span style="color:#000080;">pSlow</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">pFast</span>-&gt;<span style="color:#000080;">next</span>)</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pFast</span>= <span style="color:#000080;">pFast</span>-&gt;<span style="color:#000080;">next</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">else</span></p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#000080;">pFast</span>= <span style="color:#000080;">pFast</span>-&gt;<span style="color:#000080;">next</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">if</span>(<span style="color:#000080;">pFast</span> == <span style="color:#000080;">pSlow</span>)</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span><span style="color:#A000A0;">TRUE</span>;</p><p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; }</p><p align="left">&nbsp;&nbsp;&nbsp; <span style="color:#0000FF;">return</span> <span style="color:#A000A0;">FALSE</span>;</p><p align="left">}</p><p>&nbsp;</p><p>以上介绍了链表的部分基本操作，这些操作是实现很多算法的基础。希望大家共同学习进步，不足之处望指出。</p><p><span style="color:#FF0000;">&nbsp;</span></p>                                    </div>                    </div>    </article></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://lululua.cn/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言指针</title>
    <link href="https://lululua.cn/2019/09/07/%E6%8C%87%E9%92%88/"/>
    <id>https://lululua.cn/2019/09/07/指针/</id>
    <published>2019-09-07T15:12:45.269Z</published>
    <updated>2019-09-08T04:23:39.902Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>本文转载自：<a href="https://www.cnblogs.com/tongye/p/9650573.html" target="_blank" rel="noopener">https://www.cnblogs.com/tongye/p/9650573.html</a></p><div class="post">            <h1 class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/tongye/p/9650573.html" target="_blank" rel="noopener">C语言--指针详解</a><div id="cnblogs_post_body" class="blogpost-body ">    <p>　　这段时间在看 Linux 内核，深觉 C 语言功底不扎实，很多代码都看不太懂，深入学习巩固 C 语言的知识很有必要。先从指针开始。</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>一、什么是指针</strong></span></p><p>　　C语言里，变量存放在内存中，而<strong>内存其实就是一组有序字节组成的数组</strong>，每个字节有唯一的内存地址。CPU 通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。也就是说：<strong>指针是一种保存变量地址的变量</strong>。</p><p>　　前面已经提到内存其实就是一组有序字节组成的数组，数组中，每个字节大大小固定，都是 8bit。对这些连续的字节从 0 开始进行编号，每个字节都有唯一的一个编号，这个编号就是内存地址。示意如下图：</p><p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918115659254-712651853.png" alt=""></p><p style="text-align: left;">　　这是一个 4GB 的内存，可以存放 2^32 个字节的数据。左侧的连续的十六进制编号就是内存地址，每个内存地址对应一个字节的内存空间。而指针变量保存的就是这个编号，也即内存地址。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>二、为什么要使用指针</strong></span></p><p>　　在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p><p>1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p><p>2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p><p>3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>三、如何声明一个指针</strong></span></p><p><span style="font-size: 18px; background-color: #ffffff;"><strong>3.1 声明并初始化一个指针</strong></span></p><p>　　指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p;        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 int 类型的指针 p</span><span style="color: #0000ff;">char</span> *p        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 char 类型的指针 p</span><span style="color: #0000ff;">int</span> *arr[<span style="color: #800080;">10</span>]   <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span><span style="color: #0000ff;">int</span> (*arr)[<span style="color: #800080;">10</span>] <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个数组指针，该指针指向一个 int 类型的一维数组</span><span style="color: #0000ff;">int</span> **p;       <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针 p ，该指针指向一个 int 类型的指针</span></pre></div><p>　　指针的声明比普通变量的声明多了一个一元运算符 “*”。运算符 “*” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。</p><p>　　声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre><span style="color: #008000;">/*</span><span style="color: #008000;"> 方法1：使指针指向现有的内存 </span><span style="color: #008000;">*/</span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span><span style="color: #000000;">;</span><span style="color: #0000ff;">int</span> *p = &amp;x;　　<span style="color: #008000;">//</span><span style="color: #008000;"> 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span>/ 方法2：动态分配内存给指针 <span style="color: #008000;">/int *p;p = (int *)malloc(sizeof(int) * 10);　　　　// malloc 函数用于动态分配内存free(p);　　　　// free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</p><p>&nbsp;</p><p><span style="background-color: #ffffff;"><span style="font-size: 18px;"><strong>3.2 未初始化和非法的指针</strong></span>&nbsp;</span></p><p>　　 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在 Linux 上，错误类型是 Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> *<span style="color: #000000;">p;<br>    </span><em>p = <span style="color: #800080;">1</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);</span></p><pre><code>&lt;/span&gt;&lt;span style="color: #0000ff;"&gt;return&lt;/span&gt; &lt;span style="color: #800080;"&gt;0&lt;/span&gt;&lt;span style="color: #000000;"&gt;;  </code></pre><p>}</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这个程序可以编译通过，但是运行的话会报错，报错信息如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917175256031-967973584.png" alt=""></p><p>　　要想使这个程序运行起来，需要先对指针 p 进行初始化：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span><span style="color: #000000;">;<br>    </span><span style="color: #0000ff;">int</span> <em>p = &amp;<span style="color: #000000;">x;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);<br>　  </span><em>p = <span style="color: #800080;">2</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,</em><span style="color: #000000;">p);<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这段代码的输出结果如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180917212250007-280056505.png" alt="">&nbsp;</p><p>　　可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。&nbsp;</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>3.3 NULL指针</strong></span></p><p>　　<strong>NULL 指针是一个特殊的指针变量，表示不指向任何东西</strong>。可以通过给一个指针赋一个零值来生成一个 NULL 指针。&nbsp;</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> *p =<span style="color: #000000;"> NULL;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">p的地址为%d\n</span><span style="color: #800000;">“</span><span style="color: #000000;">,p);<br>}</span></p><p><span style="color: #008000;">/*</span><span style="color: #008000;"><strong><strong><strong>**</strong></strong></strong></span></p><ul><li>程序输出：</li><li>p的地址为0<br><strong><strong><strong>**</strong></strong></strong><span style="color: #008000;">*/</span></li></ul></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明改指针不指向一个可访问的内存位置。</p><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>四、指针的运算</strong></span></p><p>　　C 指针的算术运算只限于两种形式：</p><p>1） 指针 +/- 整数 ：</p><p>　　 可以对指针变量 p 进行 p++、p--、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下：</p><p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180921154218407-1813012241.png" alt=""></p><p>　　在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。举个例子：</p><p>&nbsp;</p><p>2）指针 - 指针</p><p>　　只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">10</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">7</span>,<span style="color: #800080;">8</span>,<span style="color: #800080;">9</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> sub;<br>    </span><span style="color: #0000ff;">int</span> *p1 = &amp;a[<span style="color: #800080;">2</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span> *p2 = &amp;a[<span style="color: #800080;">8</span><span style="color: #000000;">];<br>    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>五、指针与数组</strong></span></p><p>　　在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。</p><p><span style="font-size: 18px;"><strong>5.1 指针与数组的关系</strong></span></p><p>　　我们先声明一个数组：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">10</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个int类型的数组，这个数组有10个元素</span></pre></div><p>　　我们可以用 a[0]、a[1]、...、a[9] 来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。</p><p>　　接下来，我们再声明一个指针：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p;           <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个int类型的指针变量</span></pre></div><p>　　 p 是一个指针变量，指向内存中的一个区域。如果我们对指针 p 做如下的初始化：</p><div class="cnblogs_code"><pre>p = &amp;a[<span style="color: #800080;">0</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0]</span></pre></div><p>　　我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即 *(p + 1) 将指向 a[1] ；同样的， *(p + i) 将指向 a[i] 。因此，我们可以使用该指针来遍历数组 a[10] 的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，<strong>数组类型的变量或表达式的值是该数组第 1 个元素的地址</strong>，且数组名所代表的的就是该数组第 1 个元素的地址，故，上述赋值语句可以直接写成：</p><div class="cnblogs_code"><pre>p = a;        <span style="color: #008000;">//</span><span style="color: #008000;"> a 为数组名，代表该数组最开始的一个元素的地址</span>&nbsp;</pre></div><p>　　很显然，<strong>一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，<em>指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址</em>，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span>                                                                          <p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    </span><span style="color: #0000ff;">int</span> x[<span style="color: #800080;">10</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">7</span>,<span style="color: #800080;">8</span>,<span style="color: #800080;">9</span>,<span style="color: #800080;">0</span><span style="color: #000000;">};<br>    </span><span style="color: #0000ff;">int</span> <em>p =<span style="color: #000000;"> x;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">x的地址为：%p\n</span><span style="color: #800000;">“</span><span style="color: #000000;">,x);<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">x[0]的地址为：%p\n</span><span style="color: #800000;">“</span>,&amp;x[<span style="color: #800080;">0</span><span style="color: #000000;">]);<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">p的地址为：%p\n</span><span style="color: #800000;">“</span>,&amp;p);　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 打印指针 p 的地址，并不是指针所指向的地方的地址</span><br><span style="color: #000000;"><br>    p </span>+= <span style="color: #800080;">2</span><span style="color: #000000;">;<br>    printf(</span><span style="color: #800000;">“</span><span style="color: #800000;"></span></em>(p+2)的值为：%d\n<span style="color: #800000;">“</span>,<em>p);　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为 3，</span></em>(p+2)指向了 x[2]<br>}</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　结果如下：</p><p><img src="https://img2018.cnblogs.com/blog/765389/201809/765389-20180918160417548-189120951.png" alt=""></p><p>　　可以看到，&nbsp;x 的值与 x[0] 的地址是一样的，也就是说数组名即为数组中第 1 个元素的地址。实际上，打印 &amp;x 后发现，x 的地址也是这个值。而 x 的地址与指针变量 p 的地址是不一样的。故而数组和指针并不能完全等价。</p><p>（笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015 编译运行的话，则输出结果是一个 8位的十六进制数，也就是32位二进制，寻址空间为 4GB）&nbsp;</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>5.2 指针数组</strong></span></p><p>　　指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 <strong>指针数组是一个数组，数组中的每一个元素都是指针</strong>。声明一个指针数组的方法如下：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p[<span style="color: #800080;">10</span>];    <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针</span></pre></div><p>　　在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 *p[i]，而 <strong>p[i] 是一个指针</strong>。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。</p><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>5.3 数组指针</strong></span></p><p>　　<strong>数组指针是一个指针，它指向一个数组</strong>。声明一个数组指针的方法如下：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> (*p)[<span style="color: #800080;">10</span>];        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个数组指针 p ，该指针指向一个数组</span></pre></div><p>　　由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre> #include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>     </span><span style="color: #0000ff;">int</span> arr[<span style="color: #800080;">2</span>][<span style="color: #800080;">3</span>] = {<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>};               <span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个二维数组并初始化</span><br>     <span style="color: #0000ff;">int</span> (<em>p)[<span style="color: #800080;">3</span>];                                 <span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个数组指针，指针指向一个含有3个元素的一维数组</span><br><span style="color: #000000;"><br>     p </span>= arr;                                     <span style="color: #008000;">//</span><span style="color: #008000;"> 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0]</span><br>     printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,(</em>p)[<span style="color: #800080;">0</span>]);　　　　　　　　　　　　  <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为 1</span><br>     p++;　　　　　　　　　　　　　　　　　　　　　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0]</span><br>     printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,(*p)[<span style="color: #800080;">1</span>]);                      <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为5</span><br> }&nbsp;</p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>六、指针与结构</strong></span></p><p><span style="font-size: 18px;"><strong>6.1 简单介绍一下结构</strong></span></p><p>　　结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre><span style="color: #0000ff;">struct</span> message{　　　　　　      <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个结构 message</span>    <span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span>];             <span style="color: #008000;">//</span><span style="color: #008000;"> 成员</span>    <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;  };<p>typedef </p></span><span style="color: #0000ff;">struct</span> message s_message;　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 类型定义符 typedef</span><br><span style="color: #000000;"><br>s_message mess </span>= {<span style="color: #800000;">“</span><span style="color: #800000;">tongye</span><span style="color: #800000;">“</span>,<span style="color: #800080;">23</span>,<span style="color: #800080;">83</span>};　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个 struct message 类型的变量 mess,并对其进行初始化　</span><br><br>————————————————————————————————————–<br><span style="color: #008000;">/*</span><span style="color: #008000;"> 另一种更简便的声明方法 </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br>typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span><span style="color: #000000;">];<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> age;<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;<br>}message;</span></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　可以使用 <strong>结构名.成员</strong> 的方式来访问结构中的成员，如下：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>　　printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">“</span>,mess.name);　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果：tongye</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">“</span>,mess.age);　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果：23</span></p><p>　　<span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>6.2 结构指针</strong></span>　</p><p>　　结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：</p><div class="cnblogs_code"><pre>s_message *p;        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构</span>*p = &amp;mess;　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp;</span></pre></div><p>　　C语言中使用 -&gt; 操作符来访问结构指针的成员，举个例子：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><span style="color: #000000;"><p>typedef </p></span><span style="color: #0000ff;">struct</span><span style="color: #000000;">{<br>    </span><span style="color: #0000ff;">char</span> name[<span style="color: #800080;">10</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> age;<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> score;<br>}message;<p></p><p></p></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){<br>    message mess </span>= {<span style="color: #800000;">“</span><span style="color: #800000;">tongye</span><span style="color: #800000;">“</span>,<span style="color: #800080;">23</span>,<span style="color: #800080;">83</span><span style="color: #000000;">};<br>    message </span>*p = &amp;<span style="color: #000000;">mess;<br>}</span>&nbsp;</pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 14pt; background-color: #00ccff;"><strong>七、指针与函数</strong></span></p><p>　　<strong>C语言的所有参数均是以“传值调用”的方式进行传递的</strong>，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。&nbsp;</p><p><span style="font-size: 18px;"><strong>7.1 指针作为函数的参数</strong></span></p><p>　　传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值。</strong>用一个例子来说明：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">void</span> swap1(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b)　　　　　　  <span style="color: #008000;">//</span><span style="color: #008000;"> 参数为普通的 int 变量</span><br><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> temp;<br>　　temp </span>=<span style="color: #000000;"> a;<br>　　a </span>=<span style="color: #000000;"> b;<br>　　b </span>=<span style="color: #000000;"> temp;<br>}</span></p><p><span style="color: #0000ff;">void</span> swap2(<span style="color: #0000ff;">int</span> <em>a,<span style="color: #0000ff;">int</span> *b)　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作</span><br><span style="color: #000000;">{<br>　　</span><span style="color: #0000ff;">int</span> temp;　　　　                <span style="color: #008000;">//</span><span style="color: #008000;"> 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化</span><br>　　temp = *<span style="color: #000000;">a;<br>　　</span></em>a = *<span style="color: #000000;">b;<br>　　</span>*b =<span style="color: #000000;"> temp;<br>}</span></p><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br>{<br>　　</span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">1</span>,y = <span style="color: #800080;">2</span><span style="color: #000000;">;<br>　　swap1(x,y);                     </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x,y 的值本身作为参数传递给了被调函数</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d %5d\n</span><span style="color: #800000;">“</span>,x,y);         <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为：1     2</span><br><span style="color: #000000;"><br>　　swap(</span>&amp;x,&amp;y);                    <span style="color: #008000;">//</span><span style="color: #008000;"> 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突</span><br>　　printf(<span style="color: #800000;">“</span><span style="color: #800000;">%d %5d\n</span><span style="color: #800000;">“</span>,x,y);         <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为：2     1</span><br>　　<span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>}</span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>&nbsp;</p><p><span style="font-size: 18px;"><strong>7.2 指向函数的指针</strong></span></p><p>　　在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。&nbsp;声明一个函数指针的方法如下：</p><div class="cnblogs_code"><pre>返回值类型 （*<span style="color: #000000;"> 指针变量名）（[形参列表]）;<p></p></span><span style="color: #0000ff;">int</span> (*pointer)(<span style="color: #0000ff;">int</span> *,<span style="color: #0000ff;">int</span> *);        <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数指针</span></pre><p></p></div><p>　　上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">stdio.h</span><span style="color: #800000;">"</span><span style="color: #000000;">#include </span><span style="color: #800000;">"</span><span style="color: #800000;">string.h</span><span style="color: #800000;">"</span><p><span style="color: #0000ff;">int</span> str_comp(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> <em>m,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> <em>n);                             <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型</span><br><span style="color: #0000ff;">void</span> comp(<span style="color: #0000ff;">char</span> *a,<span style="color: #0000ff;">char</span> *b,<span style="color: #0000ff;">int</span> (</em>prr)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span></em>));       <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针</span></p><p><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()<br>{<br>    </span><span style="color: #0000ff;">char</span> str1[<span style="color: #800080;">20</span>];      <span style="color: #008000;">//</span><span style="color: #008000;"> 声明一个字符数组</span><br>    <span style="color: #0000ff;">char</span> str2[<span style="color: #800080;">20</span><span style="color: #000000;">];<br>    </span><span style="color: #0000ff;">int</span> (*p)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *) = str_comp;　　　　　　　　　　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型</span><br>    gets(str1);         <span style="color: #008000;">//</span><span style="color: #008000;"> 使用 gets() 函数从 I/O 读取一行字符串</span><br><span style="color: #000000;">    gets(str2);<br>    comp(str1,str2,p);  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 函数指针 p 作为参数传给 comp 函数</span><br>}</p><p><span style="color: #0000ff;">int</span> str_comp(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *m,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">n)<br>{<br>　　 </span><span style="color: #008000;">//</span><span style="color: #008000;"> 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2);</span><br>    <span style="color: #0000ff;">if</span>(strcmp(m,n) == <span style="color: #800080;">0</span><span style="color: #000000;">)<br>        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;<br>    </span><span style="color: #0000ff;">else</span><br>        <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;<br>}</span></p><p><span style="color: #008000;">/*</span><span style="color: #008000;"> 函数 comp 接受一个函数指针作为它的第三个参数 </span><span style="color: #008000;"><em>/</em></span><br><span style="color: #0000ff;">void</span> comp(<span style="color: #0000ff;">char</span> <em>a,<span style="color: #0000ff;">char</span> *b,<span style="color: #0000ff;">int</span> (</em>prr)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span><span style="color: #000000;">))<br>{<br>    </span><span style="color: #0000ff;">if</span>((*prr)(a,b) == <span style="color: #800080;">0</span><span style="color: #000000;">)<br>        printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">str1 = str2\n</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br>        printf(</span><span style="color: #800000;">“</span><span style="color: #800000;">str1 != str2\n</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>} </span></p></pre><p></p><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码" target="_blank" rel="noopener"><img src="//common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p>　　这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。</p><p>　　注意，声明一个函数指针时，() 不能漏掉，否则：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> *p(<span style="color: #0000ff;">void</span> *,<span style="color: #0000ff;">void</span>*);</pre></div><p>　　这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。</p><p>&nbsp;</p><p>参考文献：</p><p>1）C程序设计语言（第2版）</p><p>2）C和指针</p><p>&nbsp;</p><p>参考：</p><p><a href="https://blog.csdn.net/soonfly/article/details/51131141" target="_blank">https://blog.csdn.net/soonfly/article/details/51131141</a></p><p><a href="https://www.cnblogs.com/lulipro/p/7460206.html" target="_blank">https://www.cnblogs.com/lulipro/p/7460206.html</a></p></div></h1></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://lululua.cn/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序学习第二天</title>
    <link href="https://lululua.cn/2019/09/07/wxml2/"/>
    <id>https://lululua.cn/2019/09/07/wxml2/</id>
    <published>2019-09-07T05:09:24.590Z</published>
    <updated>2019-09-07T12:07:10.324Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h6 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h6><pre><code>添加 scroll-x就可看到滑动</code></pre><h2 id="理解display"><a href="#理解display" class="headerlink" title="理解display"></a>理解display</h2><pre><code>display: flex;display: inline-block;</code></pre><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><pre><code>属性：flex-direction:row/column 行或列</code></pre><p>问题：<br>white-space: nowrap;<br> justify-content: center;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://lululua.cn/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序学习第一天</title>
    <link href="https://lululua.cn/2019/09/06/wxml1/"/>
    <id>https://lululua.cn/2019/09/06/wxml1/</id>
    <published>2019-09-06T12:36:17.421Z</published>
    <updated>2019-09-07T12:14:49.653Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><pre><code>pages    index        index.js    Pages({})        index.json  可以设置顶部文字和颜色        index.wxml  相当于html        index.wxss  相当于cssapp.jsapp.json    导入页面的文件app.wxss    设置全局样式</code></pre><h4 id="设置顶部"><a href="#设置顶部" class="headerlink" title="设置顶部"></a>设置顶部</h4><pre><code>"navigationBarTitleText": "String" 顶部文字"navigationBarBackgroundColor": "color", 顶部颜色"navigationBarTextStyle": "black" 仅支持白色和黑色"enablePullDownRefresh": false, //是否开启下拉刷新</code></pre><h4 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h4><pre><code>在swiper标签加swiper-item，swiper-item就是每一页的内容幻灯片小圆点:indicator-dots="true"current,记录当前页面的index</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://lululua.cn/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>windows安装虚拟机</title>
    <link href="https://lululua.cn/2019/09/01/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://lululua.cn/2019/09/01/虚拟机/</id>
    <published>2019-09-01T11:48:14.695Z</published>
    <updated>2019-09-01T11:55:21.248Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>下载VMware Workstation，CentOS<br>在VMware Workstation中安装CentOS镜像<br>配置跟着里面安装就行</p><blockquote><p>在CentOS中还可以安装图形化界面</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>行列式</title>
    <link href="https://lululua.cn/2019/09/01/%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>https://lululua.cn/2019/09/01/行列式/</id>
    <published>2019-09-01T11:18:04.350Z</published>
    <updated>2019-09-01T11:59:45.145Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h5 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h5><pre><code>n个数就是n阶排列</code></pre><h5 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h5><pre><code>前面的数比后面的小</code></pre><h5 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h5><pre><code>前面的数比后面的大</code></pre><h5 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h5><pre><code>两种判断方法：    1.一个排列中前面的数比他大的有几个，总和    2.一个排列中前面的数比他小的有几个，总和</code></pre><blockquote><p>总和为奇数就是奇排列，为偶数就是偶排列</p></blockquote><blockquote><p>行列式的计算：其实可以观察矩阵用连线来记住，多少阶就一次连多少个数字，都具有一定的规律，<code>\</code>这样连线数据是想加，<code>/</code>再减去这样连线的数据就得到结果。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="线性代数" scheme="https://lululua.cn/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>豆瓣插件</title>
    <link href="https://lululua.cn/2019/09/01/%E8%B1%86%E7%93%A3%20%E6%8F%92%E4%BB%B6%E7%88%AC%E5%8F%96%E5%A4%B1%E8%B4%A5/"/>
    <id>https://lululua.cn/2019/09/01/豆瓣 插件爬取失败/</id>
    <published>2019-09-01T05:56:24.776Z</published>
    <updated>2019-09-01T11:46:27.440Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>user 在登录豆瓣个人中心网址上面的那串数字title 突入你想填的就行quote 用来浏览器F12取消一小段爬取那部分的html</code></pre><h4 id="豆瓣插件爬取失败"><a href="#豆瓣插件爬取失败" class="headerlink" title="豆瓣插件爬取失败"></a>豆瓣插件爬取失败</h4><p>使用： hexo douban -updata<br>       hexo g<br>       hexo s<br>就可以看到爬取效果</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote><p>上传的时候不能用hexo d 只能用<code>hexo deploy</code></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lululua.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>人物模型</title>
    <link href="https://lululua.cn/2019/08/24/live2d%E4%BA%BA%E7%89%A9%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lululua.cn/2019/08/24/live2d人物模型/</id>
    <published>2019-08-24T02:07:17.168Z</published>
    <updated>2019-09-01T11:37:37.871Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>1.站点配置文件下Git运行:npm install –save hexo-helper-live2d<br>2.站点配置文件写下（主题配置文件下不生效）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 添加萌妹子效果</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local  </span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko    //模型名字</span><br><span class="line">  display:    </span><br><span class="line">    position: right   //位置</span><br><span class="line">    width: 150    //妹子宽度</span><br><span class="line">    height: 300    //妹子高度</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></tbody></table></figure><p>更多模型：<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a><br>更换模型 npm install 模型名称</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lululua.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>java文件输入输出流</title>
    <link href="https://lululua.cn/2019/08/23/%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/"/>
    <id>https://lululua.cn/2019/08/23/文件的读写/</id>
    <published>2019-08-23T05:37:52.750Z</published>
    <updated>2019-08-23T06:13:32.498Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><p>输入：<code>InputStream</code><br>read()方法：-1表示无</p></li><li><p>输出: <code>OutputStream</code><br>write()方法</p></li></ul><hr><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li>输入: <code>Reader</code></li><li>输出: <code>Writer</code></li></ul><hr><h3 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h3><ul><li>输入<code>FileInputStream</code></li><li>输出:<code>FileOutputStream</code></li></ul><hr><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>  输入：<code>BufferdReader</code><br>  输出：<code>BufferdWriter</code></p><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>  序列化：ObjectInputStream<br>  反序列化：ObjectOutputStream<br>  <span style="color: red">要求对象实现Serializable接口</span></p><hr><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p><img src="http://pwmvr65mz.bkt.clouddn.com/201908231353_863.png" alt="常用的操作"><br><img src="http://pwmvr65mz.bkt.clouddn.com/201908231355_407.png" alt="常用的处理流"></p><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>文件的操作要进行错误处理</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="java" scheme="https://lululua.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>实用推荐</title>
    <link href="https://lululua.cn/2019/08/23/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <id>https://lululua.cn/2019/08/23/网站推荐/</id>
    <published>2019-08-23T03:34:07.080Z</published>
    <updated>2019-09-07T05:17:58.959Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h3><ul><li>1.在线平面设计 <a href="https://www.fotor.com.cn" target="_blank" rel="noopener">https://www.fotor.com.cn</a></li><li>2.<a href="https://pixabay.com/zh/" target="_blank" rel="noopener">https://pixabay.com/zh/</a></li><li>3.<a href="https://www.pexels.com/zh-cn/" target="_blank" rel="noopener">https://www.pexels.com/zh-cn/</a><h3 id="小图标"><a href="#小图标" class="headerlink" title="小图标"></a>小图标</h3> <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">https://fontawesome.com/v4.7.0/icons/</a><h3 id="截图推荐"><a href="#截图推荐" class="headerlink" title="截图推荐"></a>截图推荐</h3> snipaste:能将图片贴在屏幕，很好地观察，快捷键：快速截屏F1,快速贴图F3,退出贴图shift+Esc。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows安装MySQL</title>
    <link href="https://lululua.cn/2019/08/23/Windows%20%E4%B8%8A%E5%AE%89%E8%A3%85%20MySQL/"/>
    <id>https://lululua.cn/2019/08/23/Windows 上安装 MySQL/</id>
    <published>2019-08-23T01:54:15.699Z</published>
    <updated>2019-09-21T04:09:15.888Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>1.下载<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">最新版本</a><br>2.<img src="http://lululua.cn/201908231000_464.png" alt="如图"><br>3.<img src="http://lululua.cn/201908231002_844.png" alt="如图"><br>4.安装MySQL<br> <img src="http://lululua.cn/201908231020_317.png" alt="安装模式"><br> 更改地址<img src="http://lululua.cn/201908231023_822.png" alt="更改地址"><br> <img src="http://lululua.cn/201908231024_793.png" alt=""><br> <img src="http://lululua.cn/201908231032_70.png" alt=""><br> 然后一点击下一步就可以<br>5.运行MySQL<img src="http://lululua.cn/201908231035_680.png" alt="运行MySQL"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="数据库系统" scheme="https://lululua.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>七牛云截屏上传返回图片地址</title>
    <link href="https://lululua.cn/2019/08/22/%E4%B8%83%E7%89%9B%E4%BA%91%E6%88%AA%E5%B1%8F%E4%B8%8A%E4%BC%A0/"/>
    <id>https://lululua.cn/2019/08/22/七牛云截屏上传/</id>
    <published>2019-08-22T14:09:08.556Z</published>
    <updated>2019-09-21T04:07:55.702Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.到<a href="https://github.com/jiwenxing/qimage-win/releases" target="_blank" rel="noopener">github</a>下载release版本</p></li><li><p>2.打开release中的 <code>settings.ini</code> 文件</p></li><li><p>3.去七牛云找到密匙填写<img src="http://lululua.cn/201908222218_401.png" alt="密匙"> </p></li><li><p>4.BUCKET_NAME：储存空间的名称</p></li><li><p>5BUCKET_DOMAIN：你自己的域名</p></li><li><p>6.UP_HOST = <a href="http://up-z2.qiniup.com" target="_blank" rel="noopener">http://up-z2.qiniup.com</a></p></li><li><p>7.DEBUG_MODE：调试开关，截屏上传失败可以把false改为true</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lululua.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>鼠标点击特效</title>
    <link href="https://lululua.cn/2019/08/21/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%86%E7%82%B8%E6%95%88%E6%9E%9C/"/>
    <id>https://lululua.cn/2019/08/21/鼠标点击爆炸效果/</id>
    <published>2019-08-21T08:53:07.782Z</published>
    <updated>2019-08-21T09:18:16.453Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><ul><li><p>1.主题配置文件找 <code>layout</code> 文件夹中的 <code>_layout.swig</code>在body中加入</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{% if theme.fireworks %}</span><br><span class="line">   &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; </span><br><span class="line">   &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; </span><br><span class="line">   &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;</span><br><span class="line">  {% endif %}</span><br></pre></td></tr></tbody></table></figure></li><li><p>2.主题配置文件找<code>source</code> 文件夹中的 <code>js</code>新建src文件夹，在src新建fireworks.js</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)}"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)};</span><br></pre></td></tr></tbody></table></figure></li><li><p>3.主题配置文件末尾加入：</p><pre><code># Fireworksfireworks: true</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://lululua.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
</feed>
