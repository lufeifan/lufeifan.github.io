<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言指针]]></title>
    <url>%2F2019%2F09%2F07%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[本文转载自：https://blog.csdn.net/u012531536/article/details/80170893 C语言--指针详解 这段时间在看 Linux 内核，深觉 C 语言功底不扎实，很多代码都看不太懂，深入学习巩固 C 语言的知识很有必要。先从指针开始。 一、什么是指针 C语言里，变量存放在内存中，而内存其实就是一组有序字节组成的数组，每个字节有唯一的内存地址。CPU 通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。也就是说：指针是一种保存变量地址的变量。 前面已经提到内存其实就是一组有序字节组成的数组，数组中，每个字节大大小固定，都是 8bit。对这些连续的字节从 0 开始进行编号，每个字节都有唯一的一个编号，这个编号就是内存地址。示意如下图： 这是一个 4GB 的内存，可以存放 2^32 个字节的数据。左侧的连续的十六进制编号就是内存地址，每个内存地址对应一个字节的内存空间。而指针变量保存的就是这个编号，也即内存地址。 &nbsp; 二、为什么要使用指针 在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处： 1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效； 2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等； 3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。 &nbsp; 三、如何声明一个指针 3.1 声明并初始化一个指针 指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别： int *p; // 声明一个 int 类型的指针 p char *p // 声明一个 char 类型的指针 p int *arr[10] // 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针 int (*arr)[10] // 声明一个数组指针，该指针指向一个 int 类型的一维数组 int **p; // 声明一个指针 p ，该指针指向一个 int 类型的指针 指针的声明比普通变量的声明多了一个一元运算符 “*”。运算符 “*” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。 声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题，稍后会讨论这个问题。初始化操作如下： /* 方法1：使指针指向现有的内存 */ int x = 1; int *p = &amp;x; // 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址 / 方法2：动态分配内存给指针 / int *p; p = (int *)malloc(sizeof(int) * 10); // malloc 函数用于动态分配内存 free(p); // free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h 指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。 &nbsp; 3.2 未初始化和非法的指针&nbsp; 如果一个指针没有被初始化，那么程序就不知道它指向哪里。它可能指向一个非法地址，这时，程序会报错，在 Linux 上，错误类型是 Segmentation fault（core dumped），提醒我们段违例或内存错误。它也可能指向一个合法地址，实际上，这种情况更严重，你的程序或许能正常运行，但是这个没有被初始化的指针所指向的那个位置的值将会被修改，而你并无意去修改它。用一个例子简单的演示一下： #include "stdio.h" int main(){ int *p; p = 1; printf(“%d\n“,p); &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;return&lt;/span&gt; &lt;span style="color: #800080;"&gt;0&lt;/span&gt;&lt;span style="color: #000000;"&gt;; } 这个程序可以编译通过，但是运行的话会报错，报错信息如下： 要想使这个程序运行起来，需要先对指针 p 进行初始化： #include "stdio.h" int main(){ int x = 1; int p = &amp;x; printf(“%d\n“,p); p = 2; printf(“%d\n“,p);} 这段代码的输出结果如下： &nbsp; 可以看到，对指针进行初始化后，便可以正常对指针进行赋值了。&nbsp; &nbsp; 3.3 NULL指针 NULL 指针是一个特殊的指针变量，表示不指向任何东西。可以通过给一个指针赋一个零值来生成一个 NULL 指针。&nbsp; #include "stdio.h" int main(){ int *p = NULL; printf(“p的地址为%d\n“,p);} /*** 程序输出： p的地址为0***/ 可以看到指针指向内存地址0。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明改指针不指向一个可访问的内存位置。 &nbsp; 四、指针的运算 C 指针的算术运算只限于两种形式： 1） 指针 +/- 整数 ： 可以对指针变量 p 进行 p++、p--、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下： 在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。举个例子： &nbsp; 2）指针 - 指针 只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。举个例子： #include "stdio.h" int main(){ int a[10] = {1,2,3,4,5,6,7,8,9,0}; int sub; int *p1 = &amp;a[2]; int *p2 = &amp;a[8]; return 0;} &nbsp; 五、指针与数组 在C语言中，指针与数组之间的关系十分密切。实际上，许多可以用数组完成的工作都可以使用指针来完成。一般来说，用指针编写的程序比用数组编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。 5.1 指针与数组的关系 我们先声明一个数组： int a[10]; // 声明一个int类型的数组，这个数组有10个元素 我们可以用 a[0]、a[1]、...、a[9] 来表示这个数组中的10个元素，这10个元素是存储在一段连续相邻的内存区域中的。 接下来，我们再声明一个指针： int *p; // 声明一个int类型的指针变量 p 是一个指针变量，指向内存中的一个区域。如果我们对指针 p 做如下的初始化： p = &amp;a[0]; // 对指针进行初始化，p将指向数组 a 的第 1 个元素 a[0] 我们知道，对指针进行自增操作会让指针指向与当前元素相邻的下一个元素，即 *(p + 1) 将指向 a[1] ；同样的， *(p + i) 将指向 a[i] 。因此，我们可以使用该指针来遍历数组 a[10] 的所有元素。可以看到，数组下标与指针运算之间的关系是一一对应的。而根据定义，数组类型的变量或表达式的值是该数组第 1 个元素的地址，且数组名所代表的的就是该数组第 1 个元素的地址，故，上述赋值语句可以直接写成： p = a; // a 为数组名，代表该数组最开始的一个元素的地址&nbsp; 很显然，一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址，数组可以看做是一个用于保存变量的容器。更直接的方法，我们可以直接看二者的地址，并不一样： #include "stdio.h" int main(){ int x[10] = {1,2,3,4,5,6,7,8,9,0}; int p = x; printf(“x的地址为：%p\n“,x); printf(“x[0]的地址为：%p\n“,&amp;x[0]); printf(“p的地址为：%p\n“,&amp;p); // 打印指针 p 的地址，并不是指针所指向的地方的地址 p += 2; printf(“(p+2)的值为：%d\n“,p); // 输出结果为 3，(p+2)指向了 x[2]} 结果如下： 可以看到，&nbsp;x 的值与 x[0] 的地址是一样的，也就是说数组名即为数组中第 1 个元素的地址。实际上，打印 &amp;x 后发现，x 的地址也是这个值。而 x 的地址与指针变量 p 的地址是不一样的。故而数组和指针并不能完全等价。 （笔者注：上述输出结果是在 centos7 64bit 的环境下使用 gcc 编译器得到的，可以看到地址是一个12位的十六进制数，转换成二进制是48位，也就是说寻址空间有 256TB，但是笔者的电脑只有 8GB 内存，猜测是不是由于 linux 系统开启了内存分页机制，这里寻址的是虚拟地址？另外，在Windows下使用 vs2015 编译运行的话，则输出结果是一个 8位的十六进制数，也就是32位二进制，寻址空间为 4GB）&nbsp; &nbsp; 5.2 指针数组 指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 指针数组是一个数组，数组中的每一个元素都是指针。声明一个指针数组的方法如下： int *p[10]; // 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针 在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 *p[i]，而 p[i] 是一个指针。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。 &nbsp; 5.3 数组指针 数组指针是一个指针，它指向一个数组。声明一个数组指针的方法如下： int (*p)[10]; // 声明一个数组指针 p ，该指针指向一个数组 由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组，如下： #include "stdio.h" int main(){ int arr[2][3] = {1,2,3,4,5,6}; // 定义一个二维数组并初始化 int (p)[3]; // 定义一个数组指针，指针指向一个含有3个元素的一维数组 p = arr; // 将二维数组的首地址赋给 p，此时 p 指向 arr[0] 或 &amp;arr[0][0] printf(“%d\n“,(p)[0]); // 输出结果为 1 p++; // 对 p 进行算术运算，此时 p 将指向二维数组的下一行的首地址，即 &amp;arr[1][0] printf(“%d\n“,(*p)[1]); // 输出结果为5 }&nbsp; &nbsp; 六、指针与结构 6.1 简单介绍一下结构 结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下： struct message{ // 声明一个结构 message char name[10]; // 成员 int age; int score; }; typedef struct message s_message; // 类型定义符 typedefs_message mess = {“tongye“,23,83}; // 声明一个 struct message 类型的变量 mess,并对其进行初始化 ————————————————————————————————————–/* 另一种更简便的声明方法 */typedef struct{ char name[10]; int age; int score;}message; 可以使用 结构名.成员 的方式来访问结构中的成员，如下： #include "stdio.h" int main(){ printf(“%s\n“,mess.name); // 输出结果：tongye printf(“%d\n“,mess.age); // 输出结果：23 return 0;} &nbsp; 6.2 结构指针 结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针： s_message *p; // 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构 *p = &amp;mess; // 对结构指针的初始化与普通指针一样，也是使用取地址符 &amp; C语言中使用 -&gt; 操作符来访问结构指针的成员，举个例子： #include "stdio.h" typedef struct{ char name[10]; int age; int score;}message; int main(){ message mess = {“tongye“,23,83}; message *p = &amp;mess;}&nbsp; &nbsp; 七、指针与函数 C语言的所有参数均是以“传值调用”的方式进行传递的，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。&nbsp; 7.1 指针作为函数的参数 传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。指针参数使得被调函数能够访问和修改主调函数中对象的值。用一个例子来说明： #include "stdio.h" void swap1(int a,int b) // 参数为普通的 int 变量{ int temp; temp = a; a = b; b = temp;} void swap2(int a,int *b) // 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作{ int temp; // 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化 temp = *a; a = *b; *b = temp;} int main(){ int x = 1,y = 2; swap1(x,y); // 将 x,y 的值本身作为参数传递给了被调函数 printf(“%d %5d\n“,x,y); // 输出结果为：1 2 swap(&amp;x,&amp;y); // 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突 printf(“%d %5d\n“,x,y); // 输出结果为：2 1 return 0;} &nbsp; 7.2 指向函数的指针 在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。&nbsp;声明一个函数指针的方法如下： 返回值类型 （* 指针变量名）（[形参列表]）; int (*pointer)(int *,int *); // 声明一个函数指针 上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法： #include "stdio.h" #include "string.h" int str_comp(const char m,const char n); // 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型void comp(char *a,char *b,int (prr)(const char *,const char)); // 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针 int main(){ char str1[20]; // 声明一个字符数组 char str2[20]; int (*p)(const char *,const char *) = str_comp; // 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型 gets(str1); // 使用 gets() 函数从 I/O 读取一行字符串 gets(str2); comp(str1,str2,p); // 函数指针 p 作为参数传给 comp 函数} int str_comp(const char *m,const char *n){ // 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2); if(strcmp(m,n) == 0) return 0; else return 1;} /* 函数 comp 接受一个函数指针作为它的第三个参数 /void comp(char a,char *b,int (prr)(const char *,const char)){ if((*prr)(a,b) == 0) printf(“str1 = str2\n“); else printf(“str1 != str2\n“);} 这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。 注意，声明一个函数指针时，() 不能漏掉，否则： int *p(void *,void*); 这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。 &nbsp; 参考文献： 1）C程序设计语言（第2版） 2）C和指针 &nbsp; 参考： https://blog.csdn.net/soonfly/article/details/51131141 https://www.cnblogs.com/lulipro/p/7460206.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序学习第二天]]></title>
    <url>%2F2019%2F09%2F07%2Fwxml2%2F</url>
    <content type="text"><![CDATA[scroll-view添加 scroll-x就可看到滑动理解displaydisplay: flex; display: inline-block;view属性：flex-direction:row/column 行或列问题：white-space: nowrap; justify-content: center; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序学习第一天]]></title>
    <url>%2F2019%2F09%2F06%2Fwxml1%2F</url>
    <content type="text"><![CDATA[目录结构pages index index.js Pages({}) index.json 可以设置顶部文字和颜色 index.wxml 相当于html index.wxss 相当于css app.js app.json 导入页面的文件 app.wxss 设置全局样式设置顶部"navigationBarTitleText": "String" 顶部文字 "navigationBarBackgroundColor": "color", 顶部颜色 "navigationBarTextStyle": "black" 仅支持白色和黑色 "enablePullDownRefresh": false, //是否开启下拉刷新幻灯片在swiper标签加swiper-item，swiper-item就是每一页的内容 幻灯片小圆点:indicator-dots="true" current,记录当前页面的index document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows安装虚拟机]]></title>
    <url>%2F2019%2F09%2F01%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[下载VMware Workstation，CentOS在VMware Workstation中安装CentOS镜像配置跟着里面安装就行 在CentOS中还可以安装图形化界面 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[行列式]]></title>
    <url>%2F2019%2F09%2F01%2F%E8%A1%8C%E5%88%97%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[排列n个数就是n阶排列顺序前面的数比后面的小逆序前面的数比后面的大逆序数两种判断方法： 1.一个排列中前面的数比他大的有几个，总和 2.一个排列中前面的数比他小的有几个，总和 总和为奇数就是奇排列，为偶数就是偶排列 行列式的计算：其实可以观察矩阵用连线来记住，多少阶就一次连多少个数字，都具有一定的规律，\这样连线数据是想加，/再减去这样连线的数据就得到结果。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[豆瓣插件]]></title>
    <url>%2F2019%2F09%2F01%2F%E8%B1%86%E7%93%A3%20%E6%8F%92%E4%BB%B6%E7%88%AC%E5%8F%96%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[使用user 在登录豆瓣个人中心网址上面的那串数字 title 突入你想填的就行 quote 用来浏览器F12取消一小段爬取那部分的html豆瓣插件爬取失败使用： hexo douban -updata hexo g hexo s就可以看到爬取效果 注意 上传的时候不能用hexo d 只能用hexo deploy document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[人物模型]]></title>
    <url>%2F2019%2F08%2F24%2Flive2d%E4%BA%BA%E7%89%A9%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.站点配置文件下Git运行:npm install –save hexo-helper-live2d2.站点配置文件写下（主题配置文件下不生效）： 123456789101112# 添加萌妹子效果live2d: enable: true scriptFrom: local model: use: live2d-widget-model-wanko //模型名字 display: position: right //位置 width: 150 //妹子宽度 height: 300 //妹子高度 mobile: show: true 更多模型：https://github.com/xiazeyu/live2d-widget-models更换模型 npm install 模型名称 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java文件输入输出流]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[字节流 输入：InputStreamread()方法：-1表示无 输出: OutputStreamwrite()方法 字符流 输入: Reader 输出: Writer 节点流 输入FileInputStream 输出:FileOutputStream 缓冲流 输入：BufferdReader 输出：BufferdWriter 对象流 序列化：ObjectInputStream 反序列化：ObjectOutputStream 要求对象实现Serializable接口 常用 注意文件的操作要进行错误处理 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实用推荐]]></title>
    <url>%2F2019%2F08%2F23%2F%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[图片素材 1.在线平面设计 https://www.fotor.com.cn 2.https://pixabay.com/zh/ 3.https://www.pexels.com/zh-cn/小图标 https://fontawesome.com/v4.7.0/icons/截图推荐 snipaste:能将图片贴在屏幕，很好地观察，快捷键：快速截屏F1,快速贴图F3,退出贴图shift+Esc。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows安装MySQL]]></title>
    <url>%2F2019%2F08%2F23%2FWindows%20%E4%B8%8A%E5%AE%89%E8%A3%85%20MySQL%2F</url>
    <content type="text"><![CDATA[1.下载最新版本2.3.4.安装MySQL 更改地址 然后一点击下一步就可以5.运行MySQL document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[七牛云截屏上传返回图片地址]]></title>
    <url>%2F2019%2F08%2F22%2F%E4%B8%83%E7%89%9B%E4%BA%91%E6%88%AA%E5%B1%8F%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[1.到github下载release版本 2.打开release中的 settings.ini 文件 3.去七牛云找到密匙填写 4.BUCKET_NAME：储存空间的名称 5BUCKET_DOMAIN：你自己的域名 6.UP_HOST = http://up-z2.qiniup.com 7.DEBUG_MODE：调试开关，截屏上传失败可以把false改为true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[鼠标点击特效]]></title>
    <url>%2F2019%2F08%2F21%2F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%86%E7%82%B8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[1.主题配置文件找 layout 文件夹中的 _layout.swig在body中加入 12345{% if theme.fireworks %} &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt; {% endif %} 2.主题配置文件找source 文件夹中的 js新建src文件夹，在src新建fireworks.js 1"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)}"use strict";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:"linear",duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(".fireworks");if(canvasEl){var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)}; 3.主题配置文件末尾加入： # Fireworks fireworks: true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA面向对象（2)]]></title>
    <url>%2F2019%2F08%2F21%2Fjava2%2F</url>
    <content type="text"><![CDATA[类 类的组成：变量，方法，构造方法 构造方法：与类同名，不返回数字类型 方法 实例方法 静态方法 方法重载：该方法有多个名字但参数的个数和类型不同，可以用来实现多态 变量： 实例变量 静态变量 类的对象：可以访问类中的方法 继承： 声明 子类 extends 父类 继承父类的变量和方法 可以修改父类的变量和方法，还可以添加自己的变量和方法，名字相同就会进行覆盖和修改 关键字：this表示该类的对象 super：必须放在第一句用于访问父类的变量和方法（一般用于同名），可用来调用父类的构造方法 父类对象和子类对象的转换（好像是上转型对象） 包： import用于导入其他类，放在文件的首位 同包类可以相互访问,反之不得 控制符 static final abstract 接口： 定义接口：interface 实现接口：implements 调用接口则接口中的所有方法必须重写 可以实现多继承 接口定义的常量具有final，static，public属性 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA面向对象（1)]]></title>
    <url>%2F2019%2F08%2F21%2Fjava1%2F</url>
    <content type="text"><![CDATA[基本数据类型 整数型 进制的表示 浮点数型 注意单精度的书写要加f 逻辑型—boolean 字符型—char 数据类型的转换 标识符 可以由数字，字母，下划线_,美元符号$组成 不能以数字开头 通常类名开头要大写（java大小写敏感） 其余的小写字母开头 数组 数组的创建 数组的声明 int []a;(不能声明数组的长度) 为数组分配内存空间 a=new[5] 数组的定义 数组的引用类型int []a=new int[5]这里的a就是引用 数组默认初始化为0或者null 数组的遍历： 简单的循环语句 也可以用for(int age;age){}只读遍历 数组长度：数组名.length 可以获取 数组的复制：Array.Copy document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[视频嵌入]]></title>
    <url>%2F2019%2F08%2F20%2F%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>外接嵌入</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pr]]></title>
    <url>%2F2019%2F08%2F20%2FPr%2F</url>
    <content type="text"><![CDATA[教程推荐 :https://www.bilibili.com/video/av5540953/?p=9 画面放大缩小： 双击预览视频区 弹幕制作： 使用默认静态字幕弹幕效果：使用关键帧 -- 运动 设置关键帧的开始和结束位置（&lt;span style="color: red"&gt;记得打点&lt;/span&gt;） 视频速度：右键更改速度比例(鬼畜) 视频的衔接：左侧工具栏找到 - 视频过度 视频结尾：使用关键帧 – 运动 设置关键帧的开始和结束位置（记得打点） 导出：h.264 视频转场： 1.全选素材 2.Ctrl+d 3.转场素材可去设置默认 批量缩放素材： 找到首选项中的默认媒体缩放设置为 帧大小 批量调色： 1.效果控件将颜色复制在删掉 2.找到只要进行粘贴 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>剪辑软件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[音乐载入]]></title>
    <url>%2F2019%2F08%2F19%2F%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>外接嵌入</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2019%2F08%2F19%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1.下载node.js 下载地址 2.下载Git 下载地址 3.安装Hexo 官方Api 在新的文件夹右键 Git Bash Here 在Git中输入 npm install -g hexo-cli hexo init npm install 4.更换主题(本人使用NexT主题,NexT) 主题下载 更换主题：到根目录 _config.yml 找到 theme 5.更改语言 到根目录 _config.yml 将 language: 改为 zh-CN 6.增加标签和分类页 在主题配置文件找到 Menu Settings 将要打开的功能去掉# 7.更换头像 在主题配置文件找到 avatar 将url更改 8.更改标题和作者 站点配置文件Ctrl+F 搜索title，author将其更改 9.启用社交链接 在主题配置文件找到 social 将需要的功能打开，也可以自行添加 10.打开打赏功能 在主题配置文件找到 reward_settings 将false 改为true 找到 reward 更改图片地址 11.打开订阅公众号 在主题配置文件找到 wechat_subscriber 将false 改为true 12.添加动态背景 在主题配置文件找到 canvas_nest 将 enable: false更改为 true 可能需要下载库链接 13.设置阅读全文 1.打开source 在文章中加入&lt; !–more–&gt;(无空格) 2.在主题配置文件找到 auto_excerpt 将false 改为true ，length自行调节 14.添加评论,搜索，统计，分享，字数统计，阅读市场功能(可参照NexT使用文档) NexT使用文档 15.部署到Github(可参照NexT使用文档) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[页面框架]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[链接 百度 图片 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="top"&gt; &lt;div class="container"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="vlog"&gt; &lt;div class="container"&gt; &lt;div class="vlog-left"&gt; &lt;/div&gt; &lt;div class="vlog-right"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; *{ padding: 0; margin: 0; } #top{ width: 100%; height: 100px; border: 1px solid red; } .container{ width: 70%; height: 100%;; margin: 0px auto; border: 1px solid red; } #vlog{ width: 100%; height: 400px; border: 1px solid red; } .container .vlog-left{ width: 18%; height: 100%; border: 1px solid red; float: left; } .container .vlog-right{ width: 80%; height: 100%; float: right; border: 1px solid red; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>页面框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2019%2F08%2F18%2Fhello%2F</url>
    <content type="text"><![CDATA[(一)C语言的结构 １。程序的构成，main函数和其他函数。２。头文件、数据说明、函数的开始和结束标志。３。源程序的书写格式。４。C语言的风格。(二)数据类型及其运算１。C的数据类型（基本类型、构造类型、指针类型、空类型）及其定义方法。２。C运算符的种类、运算优先级和结合性。３。不同类型数据间的转换与运算。４。C表达式类型（赋值表达、算术表达式、关系表达式、逻辑表达式、条件表达式、逗号表达式）和求值规则。(三)基本语句１。表达式语句，空语句，复合语句。２。数据的输入与输出，输入输出函数的调用。３。复合语句。４。goto语句和语句标号的使用。(四)选择结构程序设计１。用if语句实现选择结构。２。用switch语句实现多分支选择结构。３。选择结构的嵌套(五)循环结构程序设计１。for循环结构。２。while和dowhile循环结构。３。continue语句和break语句。４。循环的嵌套。(六)数组定义和引用１。一维数组和多维数组的定义、初始化和引用。２。字符串与字符数组。(七)函数１。库函数的正确调用。２。函数的定义方法。３。函数的类型和返回值。４。形式参数与实在参数，参数值的传递。５。函数的正确调用，嵌套调用，递归调用。６。局部变量和全局变量。７。变量的存储类别（自动、静态、寄存器、外部），变量的作用域和生存期。８。内部函数与外部函数。(八)编译预处理１。宏定义：不带参数的宏定义；带参数的宏定义。２。“文件包含”处理(九)指针１。指针与指针变量的概念，指针与地址运算符。２。变量、数组、字符串、函数、结构体的指针以及指向变量、数组、字符串、函数、结构体的指针变量。通过指针引用以上各类型数据。３。用指针作函数参数。４。返回指针值的指针函数。５。指针数组，指向指针的指针，main函数的命令行参数。(十)结构体（即“结构”）与共用体（即“联合”）１。结构体和共用体类型数据的定义方法和引用方法。２。用指针和结构体构成链表，单向链表的建立、输出、删除与插入。(十一)位运算１。位运算符的含义及使用。２。简单的位运算。(十二)文件操作只要求缓冲文件系统（即高级磁盘I/O系统），对非标准缓冲文–件系统（即低级磁盘I/O系统）不要求。１。文件类型指针（FILE类型指针）。２。文件的打开与关闭（fopen,fclose）。３。文件的读写（fputc，fgetc，fputs，fread，fwrite，fprintf，fscanf函数），文件的定位（rewind,fseek函数）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
</search>
